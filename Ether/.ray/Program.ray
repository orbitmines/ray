// Compiler
// When using '1 Object', you still allow the compiler to use many objects there for abstract interpretation, it's just that for type checking you expect there to be just one.
// Chaining operators like ==.instance_of / <
//TODO If a variable is any, anything called on it will become a requirement , a function with an assigned type return; a requirement.
// "run at compile time" ; constexpr

// "accepts type X" but only really uses subtype "Y". So either allow subtype Y, or force that entire X type.
//TODO Notion of what is effected; what is changed by some function, and only limit certain changed with a keyword like confidential to pass it to a function with that

// variable rewrites (v, w) -> (w, z), match any in Graph, rewrite rules

  // compose matching domain/codomain

// Inverse is f' ?

// Usages of function

//TODO Shared state means what in the function control-graph

//TODO // Accessing variables while function in running.

// Recursively put code in front of every block
recur = <
  &caller = @me

  clock = Time.NOW()
  &next.push
    time_elapsed = clock.time_elapsed()
  //TODO Or allow access to super() which will be the super() of <> -> Do you ever need to access super() of that function you're accessing?

  recur()
>

<{expression: Expression}> // Before each statement in context
Node +=
  <{expression: Expression}> // Before constructor, or method call, so function returns can reference arbitrary types within the method body?

// Parsing
//TODO Ambiguity between return ME if, meaning ME or returning ME.if, the space prefers Expression if

//TODO Ambiguity if we say boolean, and have a class call bo, with operator ole, on an (another class). we can't just split the tokens.
// -> Resolve this ambiguity by preferring the attached version (since it's longer)





//TODO List of methods which shouldnt be called on local, but on this if possible:
// #, * (on global, not local)

//TODO local**# => Iterate threads
//TODO How to get the current thread, Does local** have a way of getting that current value have it be a ray, but iterate over all, not just next.

//Coroutines like race say start quest which says function.stop

//TODO What about other evaluation orders, they're shuffled in the right order in this control-flow.
//TODO What if I still want them stored out of order? -> Top-level expression is out-of-order.

class Function | Program = Boundary
  //TODO as (language: Language, compiler_options: {} = {})
  //TODO Things in history where we store a copy of the cached program, and then execute from cache
  //TODO Only translate subexpressions to certain languages. Superpose languages by superposing different implementations and then something like a corotine to which one finishes first.
  //TODO Then it's run as separate executable vs run according to their control-flow implementation.
  expression: Expression

  //TODO Should be placeable on any Expression, and should change the call to that, even parameterless.
  <{filled_parameters: Expression}> => //TODO .copy, which is just another history branch

  => (def: (x?): *) => defs.push_back(def)
    //TODO When parameterless => is an override by default, on Expression?

  {" "}({parameters: Expression}): Function
    //TODO Default &=, default override all the locations (just override the var), so when override =, it's also assign

  //TODO Define super() for any =
  //TODO Or refer to other branches which are labelled, so labels cross branches.

  //TODO Conditional edges/gotos
  //TODO .expand on an unknown function makes the length possibly infinite, optionally assume it terminates

  //TODO Coroutine where it's a race, and one is finite which always terminates the others are not, the whole function still always terminates.

  // return_type** => The function which generates the value. Which is a subfunction of the actual function which generated it.
  // TODO: Want to allow to access the whole function which generated the change you see in the sequence of functions called on the variable.
end

left-associative
right-associative //TODO

//TODO Certain things like the global <> prefer over calling the locally defined one, how to flag?
//TODO The obvious successors to this would be after, or in between each recursive function call (x levels deep). Benchmarking would use that. (Done by just implementing a function which does that and call that instead, finally and X)
// Execute expression on each successive function call in its context. So if called within (), it only works within that context.
external <{expression: Expression}>: void
// Label the current cursor within a program with a name.
external {label: *}\: Program //TODO Push to program.name
// Get the currently running function
external &: Program
// Get a contextual variable defined on the currently running function.
external &{method: *}: //TODO Infer

/{path: *}: Program OR (x): //TODO INFER
  //TODO Program which is callable with single parameter (recursively ensure path is available on x)

//TODO coroutines like race here.

// async/await branches/coroutines

return (expression: Expression) //TODO Allow out-or-order execution.
  // Ignore the values set by manually setting &caller, and only return to the original function.
  // For instance, history sets &caller to preserve history, but we want to continue the history function, not where it originally called from.
  caller = &caller%.first∙

  caller.next.out = expression
  caller.parent.push
  caller.next = .push //TODO Push so that it's after the instruction.

finally (expression: Expression)
  (&caller -> .collapse).last.push_back(expression) //TODO Do we want it to effect out-of-order, but specifically executed at the start.?
  //TODO This assumes that the returns are push_backable, instead of the returns continuing to the prev func. How to fix?
  //TODO Return: what if we say the .terminal expands into the continuation, but it's still terminal this way. But then the push_back would have to be before the expansion, not after it.

// TODO before_each/after_each recursively: filter, or filter on program to set it for nested expressions yes/no etc.. (expression: Expression)

namespace goto
  (program: Program, predicate: Expression?)
    &caller.push(program, ⊙: // TODO load condition on edge, or rather load it on the function boundary?)
    //TODO: Remove the goto from the program.
  end

  if (predicate: Expression) => this<predicate: predicate>
end

class Expression < language.Expression
  language: Language = ".ray.txt"

  dynamically
    protected fn = as Program
    delegate (: fn.in.type) => fn

  as (: Language): Expression => //TODO
  as (:== Program) => //TODO
end

class Language
  // The datastructure the language is encoded in.
  static Expression
end

//TODO Shaders are like parallel iterators; there's an unrollable loop in the Many iterator for threads.
//      -> This existence of a forloop, means the program assumes Many definitions are in turn also programs. -> Of course
class Function | Program < Boundary, Location, expression: Expression
  //TODO How to select .next to be only for Boundary. Because expression has been given separate name?
  //TODO .hierarchy in function is, parent contexts, child contexts.

  //TODO Use expression to .expand function.

  //TODO Is intermediate state the whole context? Or what do we do with sequence of operations on some variable? How to intuitively make that sequence only about that variable? and things it depends on

  //TODO Context information like line-number in parent expression, etc.. and larger context

  ∙: State
  // Program State
  // - A looped control-flow, has the values of each iteration stored in the state's history.
  //   - Different instantiated branches are also different branches in the state's history.
  static class State < Ray
    ⊢: Program

    //TODO State is a history? Then calling the .x is the version at that history.
    x: {
      context: *
      //TODO Things like &caller are in context

      //TODO Result is the last line/var of function, so it's the previous step?
      //TODO So 'in' is previous state.
      //TODO But in: should actually be the entire function context.
      result: out
    }
  end

  external (args: in.type): return_type

  if !?⊢
    step (
      override: boolean = true // Setting override to false, spawns a new path of execution which can be stepped independently.
    )
  end

  args | arguments => first.out
  return_type => last.out.type

  // .variables, .usages, domain, image, codomain, injective, surjective, bijective, homomorphism, isomorphism, endomorphism, automorphism, monomorphism (the static class variable which automatically becomes a instance var)

  // The function which called this function
  // This is empty when asking the &caller of the top-level context; the character.
  parent | caller : Program? => first.x //TODO Instead it's a collapsed initial?
  // The latest known character associated with this chain of function calls (set this variable to change it)
  who | character : Character (parent ? => parent.character : = ∙.x.last) //TODO What if the character is branched?
  dynamically assert character !== None

  //TODO .children TODO collapsed terminal.

  //TODO Superposing different implementations of the same function how? (Superposing languages)

  //TODO Some way to calculate resources used (storage, memory, time, how large the Ray is to construct a program/variable)

  callee => // from parameters one of which is the instance, other's are named; exclusion?

  in | parameters => ∙⊣this .x
  out | local => ∙.x

  //TODO Good name for the original function
  base: Program => //TODO Pointer to history.
  //TODO Base vs the original function filled with parameters, a good name for that

  recur (callee) => base.copy(callee: callee) //TODO + Parameters

  //TODO schedule, spawn entity if necessary, if already an NPC, use that NPC quests.
  //TODO < Quest, implement .stop

  // With the assumption that each non-expandable step terminates.
  static Total | Decidable | Terminating | Halting => static{expanded.length#.every != ∞}
  //TODO Automatically implements total/decidable/terminating/halting, because it's a filter. on static

  {: UUID} => //TODO Load the version and remove the current function graph

  as (== String) =>
    //TODO Store program with any state etc.. which would be used to pause certain quests/functions. For instance save/pausing a game.
    //TODO Use the program's expression if no state has changed. -> super()
end

// TODO Coroutines
//    - branch; separate thread
// TODO Concurrently accessing variables
//    - sync: Run concurrently, return when all are done, race: First one to finish, the rest is cancelled. rush: same as race, but they're allowed to finish, the ones that didnt finish first., defer: Run after current context finishes (no matter how it exists)
// TODO Await for an event to trigger, and then do things like race, with many awaits, and then continue in the code


// Language templating
⸨⸩{language: Language} (expression: language.Expression)

namespace RayLanguage // This namespace will be used for: < Language
  namespace Txt < Language
    equivalence ".ray.txt" => this

    static class Expression < String
      //TODO Then how to define the assumptions of newline meaning => etc..

      //TODO Expression comes from some file or more generally a context, have that information available here.

      external comment: String

      , (b: Expression)

      //TODO Space counts as --
      // => higher precedence than --
      // Allow space/newline (unless theres a newline between false and true?, depends on the indentation as well) ; Allow false, true .map(!)
      -- (b: Expression)
      //'-- . if this ~= ^"::ffff"'. If branch doesnt precede the --, so it's only for that line.
      //'--' shoudld be allowed to start as a this. like ' -- .embed_ipv4 if this ~= ^"::ffff"'
      //Allow multiline '--'
      //Allow returning out of a -- statement.

      // Like '--', but applies some expression and returns the variable it was applied to.
      ~~ (b: Expression)

      {" "}: (type) => //TODO Wrap whole expression in : type
    end

  end
end

Program
  ==
    // Used within this context, they have the same behavior
    //
    extensional