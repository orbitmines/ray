

+def Node < Entity
end

class Item
  // Every item has an inventory defined on it: '<-' is parent directories, '->' are child directories. Loops allowed.
  inventory: Ray = Ray(this)
  //TODO fields shoultn necessarily count as child directories, since we might have a structure on some location (arbitrary), but it's children are not the same as its fields. Take directories for example.
  // TODO They do, but the default .files/.directories in fs is a field, not the top-level properties.
  //TODO But even then, there might be overlap in the two, what to do in that case? (Say the item defines something at .directories)

  //TODO We would also want to know how version control works, and how something lioke git is supported, since those visibility and sharing them is relevant
  //TODO Also, when visible, when is it synced to the instance.

  /./TODO Setting the visibility etc. of a filesystem, should go to some specific db.
  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    speculative if<assume: false> current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end
  //TODO What if speculative graphs are returned to something, and it changes the result of a function, that should in turn
  //TODO (this can escalate quickly) change the effects of functions caused by it recursively, and roll them back potentially.

  def visibility: Entity = inventory.previous?.value.visibility ?? "local" ;//TODO global.player.is_private_default_visibility = "private"
end

//TODO Version control
//TODO %/.history, for inventory, should turn the whole inventory nested, back in time.
//TODO Individual history per field, but a branch takes nestedly the history with it?
//TODO Needs to be at least git functionality
//TODO Changed signatures/types/functionality
//TODO Transaction system also makes use of this?
//TODO Every change is a commit, but a group of changes can be bundled into another commit (to mimic git)
//TODO  |-> That bundling is just an index to certain changes for a git, and parent/child commits are the next place that index is specified.
//TODO Branches/tags are indexed commits, branch is a moving index to some latest change.
//TODO .index maps to an object which as a type returns any properties with any subgraph/part of the object. (or another index)
//TODO Global timeline means what? (Option when reverting locally to revert everything around it to that too)
//      |-> Up to some parent?
//      |-> reverse of .expand (.collapse but then just a higher-level of description)
//      |-> This also includes setting already made changes into a new group which then becomes the 'git commit'
//TODO Needs a history conversion to something like git to support it, both ways.
//TODO Is .history an acyclic Tree.Vertex?
//TODO What if I set a variable with a history and I want to retain that history (and not the history of the variable it's set to)
   //TODO Or retain both?
   //TODO The .=(value) in history (encoded on the edge) carries with it the information of where it came from, with that history attached.
//TODO; Is syncing just another object with a different location, probably yes. So .save syncs an object. (What if they hasve similar histories, use that to check which changes need to be applied) - What if they don't overlap at all, you still want then to use = on all the fields.
//  |-> Many sync locations ; mirrors. Managed inventories are mirrors. .save = .push
//TODO Is syncing just setting that 'old object = new object', and then figuring out how the histories overlap (which is default behavior for =.)
//TODO The timestamp is just Ordered. Can only merge two repositories (and reorder the events) if ordered is the same type = or an equivalence exists between the two types.
//TODO -> That's just an overlapping graph, which is filled by looking up in the history graph. .previous. < this < .next. ; require two simultaneous events to be on two branches, which are then immediately merged. ; what if there';s a merge conflict between these two. There won't be because it's two different repositories.
//TODO -> What if I have a repository with a global order, and one which is a child repository, and I want to merge them, then there's a possible merge conflicts with two simultaneous events. -> Or are all the fields just .OR/.AND'ed.
//TODO What happens to the two merged branches. If no conflicts, keeping them parallel in the history is fine.
//TODO   |-> And what happens when there's a conflict.
//TODO Uncommitted files, and staged changes, like those added with git add, are simply visibility set to local/private.
//TODO    |-> Remove files from repository by changing visibility.
//TODO  -> Doesnt work with the following: v -- But what if: "local"/"private" & not -active-branch-
//TODO We have a "local" branch with changes keystrokes and all. Then the action of committing is, setting to another "local" branch the collective changes (or all individual keystrokes).
//TODO -> Then pushing is just remote = local commited branch.
//TODO Allow changes to history, you'd use that for 'another "local" branch the collective changes', not the one with keystroke information.
//TODO History is aware of other places the same inventory is kept. -> So the .location of the inventory.
//TODO  |-> It's different than location in some way, since we don't continuously update is necessarily.
//TODO Cherry-pick is a chain of commits apply to current branch
//TODO Managed inventory is mirror, but what if it's distributed like a 'remote repository', where both can write. You'd want it to be to the same object with different locations.
//TODO   |-> Same object with different locations, vs different but synced objects
//TODO   |-> If any locations are remote, behind the scenes, we implement it as a local repository and sync with different location
//TODO     |-> Location needs to be aware of which instance it's pointing to?
//TODO     |-> Functions might be remote functions like http API calls -> Abstract network away
//TODO   |-> Local might not know the value of access, only that it itself is included? ; How to support that?
//TODO   |-> Every object has one with location for local instance memory, and remote locations.
//TODO Keep track of where which remote is, or include that in some update. Only send required updates.
//TODO Last updated, things like that?
//TODO Define mirrors which aren't defined on the other locations, so only define it for locally (visibility = "local"?)

//TODO So caller could be at a location with a different instance too.
//TODO Different values for fields based on who is looking at them. So access 'caller ==.instance_of global.player' for instance.
//TODO  -> Dynamic variable? -> No. change it to a parameterless method

//TODO Or is it visibility for anyone with the encryption key? How's that defined.
//TODO Can have many encryption keys to access the history of the chat.
repository defines encryption? (Not necessarily individual items?), No not necessarily. Can be child values doing their own thing.
//TODO Can have visibility to the encrypted value, but not the actual value, how's that difference known
//Different visibility for different entity (callers) //TODO Different value for different entities.

//TODO Encryption is just some equivalent (with key) but differently structured value.
//TODO What are some other things that follow that pattern?: It's Setting a variable like visibility to something that can cast down to Entity like the string "private".

//TODO How to locally store the unencrypted in cache, so you don't have to constantly decrypt. When do you want to not do that and force decryption on every access?
//TODO So we have an encrypted object which casts down to some type? If the key is provided, where is the key stored?
def Encrypted<Encrypted = *, T> = Encoded<T>
//TODO This is, an encrypted value which gets decrypted, we want it the other way around as well?

  // TODO This method is provided by the encrypted data (or not, if it's unknown) And it's not a ref to a local method, it's a general reference to a method implemented on the host. What if it's not supported (i.e. imported by this instance), then disallow, or say you need to include a package (unsafe potentially)
  //TODO So methods need a way to say it's from this package (location). Which by default is the Ether. location, so those are supported by default. And if it references an unsupported method, it needs to be installed on the local side.
  //TODO How is it checked that for instance a method on Player, is already supported by me, so you don't have to sent it over.
  //TODO => Can do some quick checks like are the method signatures equal etc.. If there's a change, I want to support that change.
  def decode key: * = (global.player ?? global.instance).crypt[location] => T //TODO location might inherit the key from a parent group
  //TODO The result can be an encrypted value again, so it would have to be decrypted nestedly.

  //TODO This .crypt value would not be accessible/visible to imported code (in the form of the decrypt func)
   //How to differentiate between the many things on the same location
   //TODO Or fill the items on the location automatically with the decrypt key/
end
def Encoded<Encoded = *, T> = Encoded
  def decode() => T //TODO Use (), to indicate you want () to be called on it. Not a parameterless property.
  def as :== T => T = decode()
end

// TODO Should we include this?
// Every mapping acts as an encoding function?
+def Node<T>{def as :== T => T} //TODO Want to allow this syntax of a type.
  def as :== Encoded<T> => Encoded<T>(
    def decode() => T = this
  )
end
//TODO It needs to be a quest that you have the encoded value, but not the decode function, find it is the quest.
//TODO Rename Encrypted to Encoded, with a function, and Encrypted is a constructor which takes encryption schemes.

//TODO How does version control with with things like A-B- testing of functions and things like that, need to thinka bout that too.


def History =
  static def Repository
    //Top-level inventory


  end
  static def Branch // The Edge
  end
  static def Commit // The vertex.
  end
end

//TODO Encrypted chats between players, World = groups of players,
//TODO Have an option to have any file encrypted as part of "visibility = 'private'", but make clear that if access to the devices is lost
//TODO so is the file.
//TODO Chat which is an array to which pushes might happen out of order. have some way of saying that locally that out-of-order isn't
//TODO a problem, or simply reorder as a merge.
//TODO Optionally: Lock the encryption key with the password, or key dongle. (Want this to remain optional, but you also want people to be able to login if they don't have access to their own pc; so everything is 'private' by default, Make that default an option.)
//TODO You'd have libraries or 'apps' like Discord be able to say 'a discord server/channel' instead of this sort of channel.
//TODO Slowpoke would be access checking whether you have sent in the previous x time. : But about this you want the entity to know about it so visibility.visibility = "public"

class Entity < Item
  // The known locations this item is referenced. This could be properties of an object, or a location in a World.
  location: Ray = inventory //TODO Maybe inventory = location, and with a filter on .inventory = boolean
end

class World
end

def Instance
end

def Player
  // The known instances currently running this player.
  instance: Instance

  +def location
    // When filled, this indicates that the provided instance is rendering this location.
    primary: instance?
    dynamically assert @{.primary == primary}.count == 1 if primary // Only one primary location per instance.
  end
end

// "local" means only on the local instance. (Not even local child instances)
+def String{== "local"}
  def as :== Entity = Entity{== global.instance}
end
// "private" means any instance running this player. Note that any backup server, like the central Ether server, has
// that property. Backup servers are configured using //TODO
+def String{== "private"}
  def as :== Entity = Entity{== global.player || == global.instance}
end
+def String{== "public"}
  def as :== Entity = Entity{true}
end



// TODO .desktop inventory.fs defined by external.
// TODO ether.orbitmines.com

//TODO Allow storage to set visibility = private, if there's an equivalence. (Generally allow this)

//TODO All networking is abstracted away behind players/instances/inventories.

//TODO A separate ether world which gives out unique user ids.

// Everything is an Item, and possibly an Entity.

def Visibility = InheritFromInventory | Entity

//TODO You can have anything with really long values, which don't need to be loaded directly, but can be loaded partially.
//     -> Networking code for doing this partially.
//TODO This partial loading should also support encodings which can be decoded partially too.
//     -> If it cannot be decoded partially, it should have the value stored on another level of description how?
//TODO Or partial downloads of arbitrary parts of a file. (Allow access the parts out-of-order if present)
class Item
  // TODO history could include When it's used, how it's made, how it's discovered, how it's constructed.

  //TODO ANY ITEM MIGHT be managed by another instance

  // Items require Quests ; In order to find items you need quests.
  obtained_by: Quest

  // TODO Is issued_by here some top-level world
  issued_by: World = global.desktop
  certificate: Certificate

  //TODO Can't really implement visibility s public/private/protected, since you have 'The memory object Player', and 'The actual player to expose it too', or are they the same thing? They should probably be the same thing.
  // Read-access
  //TODO Want a dynamic default, until it is set.

  //TODO Read-access with a specific encryption key
  //TODO Locally set to a different value than what the managed inventory says?> ever used?
  // TODO what if that location is say referenced in two places, one authorized by me which says private, and another unauthorized which says public, it shouldn't switch mine to public.


  // Write-access (defines allowable values one can write to each field)
  access: Query<static> //TODO access is Visibility for each field.

  // TODO A program of possibly entities that are allowed to see this. Things like private instances which are allowed to see it. (Or the local instance) - Can also include things like 'within renderdistance'.
  // TODO, Want to add things like : has been at this location in this world before for instance.
        //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item): So has this type of item, then it's visible.

  //TODO If every item is an inventory, then this is not used, but where it came from, is.
  //TODO This inventory = Location *in* an Inventory/
  inventory: Inventory?
  //TODO If every item is an inventory, we want to know whether that inventory can persistently store information.
  //TODO If a single item is in multiple inventories, how is persistence done? Is it stored in one, refs, in another, stored in both, want to allow for all of these options, how to deduplicate if it's known it's in two inventories: merger, or what?

  //TODO We have copy as well, but we could also copy by ref, or have both set refs to a single one.
  //  -> All object setting/getting becomes moving between inventories.
  def move inventory: Inventory
  //TODO Transaction
  end

  dynamically if inventory
    // TODO On change, if has access, save. Otherwise, save local copy.
    def save
      // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
      //TODO Write to inventories
    end
    def delete

    end
  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
  def as :== Map
    // TODO Perspective switch to a 'high-level overview'
  end

  def as :== World = this ==.instanceof World ? this : TODO
    //TODO: How does 'World' differ from structure the item is made of.
    //TODO: World might not necessarily be accessible (Say the hidden dynamics of some function of some language)
    // TODO Internal structure of an item.
  end
end

+def Node < Item //TODO There's a circularity here, but it should be supported.

  //TODO obtained_by
    issued_by: global.desktop,
    certificate //TODO,M
end


// TODO You want to say, have a world in your inventory, which is your desktop. Which contains items. Those items are not directly in your inventory? But they can be put there.
class World < Entity
  //TODO What are quests and location of a world?

  // TODO What if I define my own alias for this world, it doesn't get stored in the global World config, but I want it in my own
  //   -> Allow overriding of default config: inventories by the user.
  // A instance can still host a world where parent != that instance.
  //TODO .parent would be .indexed_by, and another .parent would be, how did you get to this world? (So a path)
  def parent => World? = this.name.issued_by != this ? this.name.issued_by : None

  // TODO Instancelist maintained by the world, but others could be running it too.
  // Known instances which this world runs on (TODO Others might be discovered later, so .hosts might be non-halting)
  hosts: Instance = Instance{hosting == this}

  // TODO World generation vs world rendering, in certain cases world rendering would be similar to world generation.

  //TODO What about behavior dictated by the world/instance: These things are automatically shown, these things not.
    //TODO Might want to tie a quest to a location too.

  // Internal dynamics -> Want a primitive in .ray to be a dynamic space.

  // Split into two groups: Spaces with arbitrary propagation vs limitations:
        How do you make spatial propagation hard/limit it in a distributed sense when usually one can just skip ahead programmatically?
        -> Similarly how we make item copying expensive/impossible. Scarcity of the items.

  //TODO Spawn-location defaults to something like .first. (If accessible) What if it's not, then demand it's provided.

  spawn_location: Location

  // TODO, An entity should be a graph within the graph, both of those shouldn't interfere with each other. (As in effecting .next)

  // All information on what's in a world could be partial client-side. It might not have all the information of the world.
  def entities = worlds & players & npcs
  //TODO These are basically indexes of things moving through this world.
  players: Player
  npcs: NPC
  //TODO You should have a way of saying, this is my location (so also pitch etc.) based on that what information is available about which entities (could be partial)

  // Child worlds, where this world is acting as a parent category
  def #`world: this != global.Ether ? String.NonEmpty : String.NonEmpty & not global.Ether.name.ignore_case` => World?

  if this == global.Ether
    def #`global.Ether.name.ignore_case` => World = global.Ether
  end

  def worlds = (this.#`String.NonEmpty` -> .#`String.NonEmpty`).compact.reduce(&) //TODO Should overlay Both cases of "Ether".ignore_case and not.
  //TODO: Should know that, because of using reduce(&), that intermediate results are possible for .last (Don't need to compute all children to get some values out of this). That should also work for '(this.#`String.NonEmpty` -> & .#`String.NonEmpty`).compact.last'
  //TODO worlds{parent == None} should know that  it doesn't need to go into the children.

  // Players can be registered under a certain world, similar to how certain games/apps have UserName#Tag, where the
  // #Tag is the world.
  def @`player: String.NonEmpty` => Player?
end



// Spatial Propagation
// - Separate graphs for moving pieces?
// - One way of doing 'air you can move through' Split the graph one is moving into, and knit it back together on the opposite end of the structure that's moving.
   // Does disallow overlapping structures within the same space.
// - Or something more inspired by physics, based on the structure that's there in the graph, allow/disallow.
    // More spatial structure around matter
    // If something like an arm is attached, the further from the attachment the faster it has to move
// - World only has update events, you want those to be massively parallel, so what can influence what? -> What would actual execution on a GPU look like, how much does having it in a graph impact performance?
//

//TODO You might have some way to navigate the structure of a world, but that doesn't mean it's just accessible. In a way
//TODO in which you can, for instance, just loop over all the nodes. You might have to explore some other way.
//TODO So a world defines how you can interact with it.
//       -> It defines how you can move through it, at those Nodes, additional worlds are defined.
//       -> Comparing is just movement is matching some other world I can move in (
//       -> I might not necessarily host all these worlds top-level (visibility) or on some indexed #property. (Indexed just means I've saved that location in my inventory somewhere)
//       -> But when I'm there, I might find those worlds and then gain access to them (if only temporarily)
//       -> So parent worlds, are just the path defined to get there.
//       -> The host, is merely the top-level instance on which we're exploring. (But that might change at each step)
//          -> Hosting, just means I got this step of information from this instance. (Each step might be deferred to another host)
//          -> So each node of information has with it: it came from here.
//          -> In the case of providing information from disk from instance to client: The instance nodes are decorated with host locations of the disk for instance or memory, and the player is from the instance.
//          -> What if I wanted to know the history of where it came from? So from disk to instance (to memory) to instance ... , until it came to me. -> So the instance can choose whether to provide that information.
//       -> A location also needs information like : A path to get here. (Which is just additional structure, but those in turn can be vague locations)
//          -> Path information crosses multiple hypergraphs.
//       -> World has something like dependent/optional inheritance on Abstract Directionality.
//       -> Interface with which you walk through a world is itself a graph. Say a 2d-visual-field.
//       -> Highly parallel rewritable structure in world.
//       -> Location should also specify what interface is used like yaw/pitch/screen size etc..
// TODO How does a location work if it's a dynamic space?
// TODO Abstractly, we never know (without looking) if another location also matches this description.

//TODO Say I have an abstract Map on which is a path which is the Location. It's a Location, with structure defined on it with points which abstractly represent those points in the path.
//      -> Say I have 4 abstract point, each point in a list, the points are described abstractly. Abstractly means arbitrary structure after a .expand (So .expand doesn't necessarily just fill in the ray, it could be structure like: 500 steps from here there's this thing which is approximately like this. Where approximately is a type.

def Location //TODO = Ray of World OR: You want Location to be more abstractly, a subregion: subgraph - which could be a specific location, of a World. It could also be a description of surroundings, which is not yet certain where exactly in the world that is.
  world: World? //TODO Could be many: it's in one of these worlds.
  //TODO world could be a substructure too. we want the top-level world?
  //world is .context, top-level .context means ? .world
  /
  /TODO How do you store, 400-500 steps after this, but we don't know what's in between. ray{.[400..500] ==.some Structure} // ray{.[1km..10km] ==..Structure} -- radius, not back and forth. ray[1 km] = wall
  //TODO How many steps is 1m?
  //TODO Edges are decorated with length.
  //TODO Then depending on the discreetness per 1m, we have values like 0.00001m, which could highlight a superposition of position nodes.
  //TODO Want to also have things like .by_road.[1 km] which is another overlay on the main graph with effective gravity relative to free-roam
  //TODO    What if that is the same graph, but filtered which direction you can go.

  //TODO By default the elementary_length is not defined so any Distance is further away than a step. Want to also have some definition of: .next to the first thing that matches. (which would match with things distance is used for)
  //TODO After calling .elementary_length(1nm) on Ray decorate all rays and graphs connected to that with functionality that supports distances.
  //      -> Unless otherwise specified by the edge, defaults to that per step.
  //TODO So things like length > 1m should partially be defined as well.

  //TODO Location too has a visibility, to whom am I broadcasting that I'm here.
end

def Quest
  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  // - Effectiveness rating -> In the case of effecting other items.

  // Quest selection by NPCs
  // - Difficulty rating vs reward.

  //TODO Quests are also, places to spend resources on infinitely generating/speculative execution places
  //     -> If the result would be found, would that result into efficiency, or what else?

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate: Certificate?
  end
  def active = !completed
end

def Map
end

// TODO Items arranged in a particular way make another item. Something like = Hypergraph<Item> or it's a primitive item.
+def Hypergraph<Item> //TODO Hypergraph here? -> Item as Hypergraph<Item> implemented.
  def as :== Item
  end
end


//TODO Since the inventory is possibly managed by another Entity (instance), that means that it has access, and it can give others access.

// Managed inventories have some visibility/access, and thisw is one value for the manager (world), and another for the player, how to make that differentiation?
//TODO: How to indicate it is managed by the world, and synced to the player.
// Managed inventories at this location for a particular Entity.
def `entity: Entity` => 1 Inventory
// Managed inventories at this location by a particular World.
def `world: World` => 1 Inventory

// Inventories differ slightly from traditional file systems:
//   - There can be many items (files) defined at a single location. These could have additional operators defined on
//     them like AND/OR, and they could also be abstractly defined; They work just like any Type in `ray.txt`.
//   - Inventory works like directory: It defines a path. But at any path items (file) might be defined. Additionally,
//     it might host additional inventories and items like a directory. So any path is always a directory and a file.
//
// Technically every Object/Node, is *in* an Inventory.
//   - A value holds an arbitrary definition of that Type.
//   - Within it is recursively defines paths to other items (and thus inventories).
//
// When inventory is used as an Item, it is just "the path to that inventory".
//TODO Hosting you inventory is just hosting a world, which in it has locations at which the items are situated.
class Inventory
  //TODO owner = Location top-level,
  owner: Entity //TODO If everything is in an inventory, then inventory.inventory would be the entity. == path which is an entity
  //TODO Want owner to be a persistent Entity, since everything is an entity.
  //TODO path = structure on Location
  path: *[] = []
  def [path: *[]] => Inventory = this +.overwrite { .path = path }
  
  recursive = {
    def items => Item = (this -> ==.instance_of Inventory ? .items : .)[1..].reduce(&)
    def inventories => Inventory = (this -> .inventories)[1..].reduce(&)
  }
  
  // Get children of this inventory.
  //TODO .items might as well be .nodes for a World
  def items => Item
  def inventories => Inventory = items{==.instanceof Inventory}
  
  // Get the items defined at this inventory.
  def get => Item{visibility: Entity, inventory: Inventory}? // TODO These refined types should be implied.
    //TODO Load item as a .ray.txt file, with restrictions.

    //TODO Get a specific type
  
    // Many items might be stored at this location.
    item = sub() //TODO Support sub(), indicating that the method still needs to be implemented.
    item.visibility = path.map(.visibility){!= Visibility.InheritFromInventory}.last
    item.access//TODO Set access
    item.inventory &= this
    //TODO: Might have settings of certain instances to backup the player information to.
    item
  end
end

class Entity
  inventory: 1 Inventory // TODO *in* an inventory vs *has* an inventory.
  def quests => Quest = inventory{==.instanceof Quest}

  //TODO NOt this, but how to overwrite all properties which are not defined, recursively. How to get the type, and default value?
  +def def
    //TODO Adjusting def within a context should only monkeypatch it in that and children context.
    //TODO Property definition under the hood are def too?
    def `field: * => Type: * = default: *` //TODO How to differentiate default from a function body with the implementation
      //TODO Recursively how?
      super `field` => Type = inventory[field]()
      //TODO: What if inventory doesn't have that type stored.
      super `field`= value: Type
        //TODO Use .save/.delete the previous entries.
        //inventory[field] = value //TODO Should automatically implement &=, |= as well.
      end
    end
  end

  name: String.NonEmpty

  //TODO We have a world which is the memory system which is a child work of desktop, then if everything is an entity, the location is a place in that world.
  //TODO World = Inventory = Location, Location = child Inventory / subgraph/abstract description of World, child World = child Inventory
  //TODO Inventory is a refinement of World/Location. It's more strict.

  def world = location.world
  //TODO What if you only want to broadcast a particular part of your location, say the world it's in or?
  //   -> Actual location is one thing, the one broadcasted is another. Implemented as "at two locations", and one of them is chosen to be visible.
  //   -> How to indicate those two locations are supposed to represent the equivalent thing?

  //TODO Actually what you want for online, is a filter over possible worlds to interact with, and 'online' is equated to allow over internet. (what about other bluetooth things and such - included in online)
  // On top of 'visibility', an entity can be set offline instance-side: Indicating only offline communication.
  def online => boolean //TODO for a instance: set this value, for client: poll for data.

  //TODO Specific parameter types can be enforced using Entity instanceof SomeOtherEntityWithConstraints
  def `world: World`
    //TODO How to indicate that that entity ==.(some equiv graph) this.
    return this +.overwrite { // TODO Support +.overwrite as opposed to adding the results of the two to each-other. Type-checking should recognize the +.overwrite is defining at least the thing before the +.
      inventory = this.inventory[world],
      name = this.name{issued_by == world}
      location = this.location{.world == world}
    }
  end
end

def NPC < Entity
  //TODO Defines dynamics in a World
end

  //TODO: You want to be able to host a instance as an item to a world, with some visibility.

def Organization < Player
  //TODO Reserve namespace with dots to domain names.
  //TODO Organization has many 'names' which are domain names?
  //TODO Domains are the only duplicate names allowed by the central ether server, and they can be revoked.
end

//TODO So if a player has made their location known, another player can run an instance of that player in that location.
//      He might not be able to set input for that player, but it's still an instance running that player.
//      But you might want to run an instance, not the player (a specific location)
//      So streaming too, becomes running an instance.
// For strreaming, a player has a particular location which is the streaming location , that is being broadcast.
// TODO So watching a stream is simply following that location.
// So a streamer has a primary location. That location's location might be in a separate world which is the 'streaming window'.
// People watching the stream, would set their primary location, to that location.

// ==.instance_of .location Location is a type.

//TODO Some instance, which holds the 'first discovered by X' status, and issues certificates for that./
class Instance < World
  //TODO A instance is an instance, you can boot up other instances within the current instance.
  //TODO -> Child instances.
  //TODO A instance has many player instances running. (I.e. screens / separate windows)

  //TODO Instance needs a unique identifier more general than MAC, one of the names.

  //TODO Instance might be behind some nameinstance, delegating to many other instances.

  // A world might live on many entities/instances
  //TODO A player, or any entity can (co-)host worlds
  //TODO : From the perspective of this entity,
  hosting: World //TODO These worlds should come from an Item in the instance's inventory = is just (inventory as World){visibility = ??}

  //TODO How to represent that hosting and hosts in World are linked? 'hosts: Instance = Instance{hosting == this}' How is this, FOR ALL query constructed?
  //TODO How does the storage module know whether to store a reference or the whole object. It checks if the Object is stored separately and will use a reference then.
  //     -> Is there ever a time where that's not desired, say when the visibility or something is set differently for each reference of the object.
end

def @`player: String.NonEmpty` => Player = Ether.@`player`
def #`world: String.NonEmpty` => World = Ether.#`world`

def Certificate
  //TODO Want to set the visibility differently for another field in the object. How to still allow an overwrite though?
  //TODO Every field has as Item on it by default?
  //TODO Are fields stored under [World].field, or are they part of [World], and .field in world is something else. Or is it both?
  secret: Something
    visibility = //TODO Should only be default, can be overwritten
  end
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end


//TODO #World.#ChildWorld.@UserName where #ChildWorld.name.issued_by = #World
//TODO Equivalent .UI = .#Ether.UI
//TODO Equivalent: .#Ether.@UserName = .@UserName
//TODO .#world.@UserName.
//TODO; Require domain names registers on @"orbitmines.com" to be verified
// TODO; Allow circular using.
//TODO Uploadable public packages to .@name, default to using player names for this. register other organization names for this too.
// using .@"ether.orbitmines.com".UI, <TODO Version>
//TODO: If working in some folder, automatically change versioning numbers to the new ones, if the file is changed.
//TODO Should work with the versioning system somehow? another parameter here the version, which the IDE supports for automatically getting

private class Module
  static Constructor = (root: Module = Module()) => Module //TODO Constructor is parameterless, so you shouldnt need to call it with (), so just naming a variable this should work. BUt what if you would want to pass it a parameter, there's an ambiguity here.
  
  def (node: *) = ..path.reduce(acc = node, current => acc[current])

  `` = {
    def parent: Module?

    def property: *?
    def world: World?
    def player: Player?

    def path => *[] = (..parent <- this).compact.map(.world ?? .player ?? .property) //TODO This, because it's private shouldn't be overwritten? How does that work?
  }

  def `property: * & not ""` => Module
    return this if property ==<String> "."
    return this.parent ?? this if property ==<String> ".."
    return Module(..parent = this, ..property = property)
  end

  if !parent || parent..world
    def #`world: String.NonEmpty` = Module(
      ..parent = this,
      world = (parent..world ? parent..world : global.Ether).#`world`
    ) //TODO Check if not None

    def @`player: String.NonEmpty` = Module(
      ..parent = this,
      player = (parent..world ? parent..world : global.Ether).@`player`
    ) //TODO Check if not None
  end
end

def using at: Entity? = global.Ether, path: Module.Constructor
  environment = caller

  def eval inventory: Inventory
    item: Item = path(inventory)
    //TODO eval item
    //TODO Only allow certain things to be imported/changed by certain imports.
  end

  //TODO; If defined in player.inventory, define super() to call the original functionality.

  //TODO; Check if version exists on desktop if configured for remote, if it does use it.

  eval at.inventory if at // Load
  eval desktop.inventory // Load default settings
  eval player.inventory // Load player overwrites
end
