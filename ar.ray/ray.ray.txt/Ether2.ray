index | distance (start = first) =>


//TODO Bidirectional function like ray but only single step: l <= (x) => r, ambiguity with <=

local @= location to change the location the code gets executed



class Item
  // how it's made, how it's discovered, how it's constructed.
  //  -> The non-evaluated function so **%
  //TODO What does discovered by a player look like?

  // Items require Quests ; In order to find items you need quests.
  //Similar to function, who called?
  obtained_by: Quest

  issuer: World = global.desktop
  certificate: Certificate

  //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item), Or only that managed inventory has access, so acts as a certificate
  //TODO A specific directory for "Managed by other's"

  //TODO We have copy as well, but we could also copy by ref, or have both set refs to a single one.
  //  -> All object setting/getting becomes moving between inventories.
  def move location: Location
  //TODO Transaction
  end

  //TODO If has mirrors, schedule quests (can free memory; resource after quest is completed, can be a quest goal)
  dynamically if inventory
    // TODO On change, if has access, save. Otherwise, save local copy.
    def save
      // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
      //TODO Write to inventories
    end
    def delete

    end
  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
    // TODO Perspective switch to a 'high-level overview'
end


public key Player{public_key & challenge that they have the private key, like a timed message, or a specifically tailored message by this instance}


def Quest
  // Require things like "I've communicated with these replica servers before making this calculating -> when strong consistency is required." -What if they're not online, like offline players storage etc.. (For certain things like calculating player statistics which are kept local only, it would be "make sure your instance checks in with out server before X time", and we'll consider your changes) - So these are quests to complete for the replica servers


  // schedule quests (can free memory; resource after quest is completed, can be a quest goal)
  // Version control needs a way to access and what to do with paused functions

  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    speculative if<assume: false> current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end
  //TODO Speculative //= Quests
  //TODO Speculative programs which return something in turn possibly reevaluate all effects caused by its result being changed.


  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // TODO Conditions which need to be met before the quest can be completed.

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  //   - Difficulty also has time information in certain cases; how long does it take.
  // - Effectiveness rating -> In the case of effecting other items.

  // Quest selection by NPCs
  // - Difficulty rating vs reward.

  // Creating quests for one-self, or others.

  //TODO Quests are also, places to spend resources on infinitely generating/speculative execution places
  //     -> If the result would be found, would that result into efficiency, or what else?

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate: Certificate?
  end
  def active = !completed
end



class Entity
  inventory: 1 Inventory // TODO *in* an inventory vs *has* an inventory.


// For strreaming, a player has a particular location which is the streaming location , that is being broadcast.
// TODO So watching a stream is simply following that location.

def Certificate
  secret: Something
    visibility = //TODO Should only be default, can be overwritten
  end
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end


//TODO Version control, after change the filter would include/exclude new entries, like a new maxlength of username, add merge clause on how to deal with it. Basically database changes are merge conflict resolves

