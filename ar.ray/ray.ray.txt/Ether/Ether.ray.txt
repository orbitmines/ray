global.player?: Player = external
global.desktop: Server.Ether = external
global.Ether: Server.Ether = external // TODO ether.orbitmines.com

// Everything is an Item, and possibly an Entity.

def Visibility = InheritFromInventory | Entity

//TODO You can have anything with really long values, which don't need to be loaded directly, but can be loaded partially.
//TODO This partial loading should also support encodings which can be decoded partially too.
//TODO Or partial downloads of arbitrary parts of a file. (Allow access the parts out-of-order if present)
class Item
  // TODO history could include When it's used, how it's made, how it's discovered, how it's constructed.

  // Items require Quests ; In order to find items you need quests.
  obtained_by: Quest

  //
  issued_by: World
  certificate: Certificate

  // Read-access
  visibility: Visibility = Visibility.InheritFromInventory // = Entity{==.instanceof Player}
  // Write-access (defines allowable values one can write to each field)
  access: Query<static> //TODO Another item which defines superpositions on each field for possible values allowed to set.

  // TODO A program of possibly entities that are allowed to see this. Things like private servers which are allowed to see it. (Or the local server) - Can also include things like 'within renderdistance'.
  // TODO, Want to add things like : has been at this location in this world before for instance.
        //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item): So has this type of item, then it's visible.

  inventory?: Inventory

  def move inventory: Inventory

  end
  // TODO On change, if has access, save. Otherwise, save local copy.
  def save
  // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
    //TODO Write to inventories
  end
  def delete

  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
  def as :== Map
    // TODO Perspective switch to a 'high-level overview'
  end

  def as :== World = this ==.instanceof World ? this : TODO
    //TODO: How does 'World' differ from structure the item is made of.
    //TODO: World might not necessarily be accessible (Say the hidden dynamics of some function of some language)
    // TODO Internal structure of an item.
  end
end

+def Node
  def as :== Item = Item(
    //TODO obtained_by
    issued_by: global.desktop,
    certificate //TODO,M
  )
end

+def String{== "private"}
  def as :== Visibility = Entity{== global.player} //TODO This check needs to be secure, so noone can spoof it.
end
+def String{== "public"}
  def as :== Visibility = Entity{true}
end

// TODO You want to say, have a world in your inventory, which is your desktop. Which contains items. Those items are not directly in your inventory? But they can be put there.
def World < Item
  // Known servers which this world runs on (TODO Others might be discovered later, so .servers might be non-halting)
  hosts: Entity

  // Internal dynamics -> Want a primitive in .ray to be a dynamic space.

  // Split into two groups: Spaces with arbitrary propagation vs limitations:
        How do you make spatial propagation hard/limit it in a distributed sense when usually one can just skip ahead programmatically?
        -> Similarly how we make item copying expensive/impossible. Scarcity of the items.

  spawn_location: Location

  // TODO, An entity should be a graph within the graph, both of those shouldn't interfere with each other. (As in effecting .next)

  entities: Entity
  //TODO Might want to tie a quest to a location too.
  quests: Quest //TODO Shouldn't conflict with fields of other things.
  //TODO: .quests{active | completed} TODO: Requires .filter etc. to be defined on Quest, which it should by default? Because Many<>

  // TODO World generation vs world rendering, in certain cases world rendering would be similar to world generation.

  //TODO What about behavior dictated by the world/server: These things are automatically shown, these things not.

  def online => boolean //TODO
end

// Spatial Propagation
// - Separate graphs for moving pieces?
// - One way of doing 'air you can move through' Split the graph one is moving into, and knit it back together on the opposite end of the structure that's moving.
   // Does disallow overlapping structures within the same space.
// - Or something more inspired by physics, based on the structure that's there in the graph, allow/disallow.
    // More spatial structure around matter
    // If something like an arm is attached, the further from the attachment the faster it has to move
// - World only has update events, you want those to be massively parallel, so what can influence what? -> What would actual execution on a GPU look like, how much does having it in a graph impact performance?
//

// TODO How does a location work if it's a dynamic space?
def Location < Item //TODO = Ray of World OR: You want Location to be more abstractly, a subregion: subgraph - which could be a specific location, of a World. It could also be a description of surroundings, which is not yet certain where exactly in the world that is.
  world?: World //TODO Could be many: it's in one of these worlds.

  //TODO Location too has a visibility, to whom am I broadcasting that I'm here.
end

def Quest < Item
  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  // - Effectiveness rating -> In the case of effecting other items.

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate?: Certificate
  end
  def active = !completed
end

def Map
end

// TODO Items arranged in a particular way make another item. Something like = Hypergraph<Item> or it's a primitive item.
+def Hypergraph<Item> //TODO Hypergraph here? -> Item as Hypergraph<Item> implemented.
  def as :== Item
  end
end

class Inventory ..self: Item
  // TODO: Visibility should inherit from top-level parent Directory/Inventory if not set.
  def () => Item{visibility: Entity}
    item = sub() //TODO Support sub(), indicating that the method still needs to be implemented.
    item.visibility = path.map(.visibility){!= Visibility.InheritFromInventory}.last
    item.access//TODO Set access
    item.inventory &= this
    //TODO: Might have settings of certain servers to backup the player information to.
    item
  end

  // We wrap any functionality in this, so that it's still an Item
  `` = {
    owner: Entity
    def path => Item[] = (.inventory <- self).compact  //TODO How do you proof not Array.Unbounded?
    //TODO Since the inventory is possibly managed by another Entity (server), that means that it has access, and it can give others access.
    def `property: *` = item[property] //TODO Need some shortcut for not defined
  }

  def `dir: Item & not ""` => Inventory
    return this if dir ==<String> "."
    return this.inventory ?? this if dir ==<String> ".."
    return Inventory(owner = this.owner, self = dir)
  end

  def as :== Item = ..item
end
def FileSystem server: Server < Inventory
  is_local = server == global.desktop
end

class Entity < Item
  inventory: Inventory
  def quests => Quest = inventory{==.instanceof Quest}

  def store type
    def `field: *`
      this.def `field` => type = inventory[field]()
      this.def `field`= value: type = inventory[field] = value //TODO Should automatically implement &=, |= as well.
    end
  end

  store name Name
  store desktop Server.Ether //TODO Should be multiple here, and only change the one with this identifier, (can use MAC-address, but we need additional identifier stored for dual-boot)

  store location Location
  +def location //TODO Allow this syntax.
    primary?: boolean //TODO Whether this is the location we're actually currently rendering on screen.
  end
  def world = location.world
  //TODO What if you only want to broadcast a particular part of your location, say the world it's in or?


  // A world might live on many entities/servers
  //TODO A player, or any entity can (co-)host worlds
  //TODO : From the perspective of this entity,
  hosting: World //TODO These worlds should come from an Item in the server's inventory = is just (inventory as World){visibility = ??}

  //TODO Specific parameter types can be enforced using Entity instanceof SomeOtherEntityWithConstraints
  def `world: World` => Entity{name?: Name, location?: Location}
    return this +.overwrite { // TODO Support +.overwrite as opposed to adding the results of the two to each-other. Type-checking should recognize the +.overwrite is defining at least the thing before the +.
      inventory = this.inventory[world],
      name = this.name{issued_by == world}
      location = this.location{.world == world}
    }
  end
end

def NPC < Entity
  //TODO Defines dynamics in a World
end

def Player < Entity
  //TODO: You want to be able to host a server as an item to a world, with some visibility.

end
def Organization < Entity
end

//TODO Some server, which holds the 'first discovered by X' status, and issues certificates for that./
class Server < NPC, World
  +def inventory
    fs = FileSystem(server = this)
  end

  //TODO Server might be behind some nameserver, delegating to many other servers.
  static Ether < Server
    def @`player: String.NonEmpty` => Player
      //TODO
    end
    def #`channel: String.NonEmpty` => Channel
      //TODO
    end
  end
end

def @`player: String.NonEmpty` => Player = Ether.@`player`
def #`channel: String.NonEmpty` => Channel = Ether.#`channel`

def Channel < Item
  world: World
  name: Name

  def @`player: String.NonEmpty` => Player
    //TODO
  end
end

def Name = String.NonEmpty < Item
  channel?: Channel
end
def Certificate
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end

//TODO .#channel.@UserName.
//TODO; Require domain names registers on @"orbitmines.com" to be verified
// TODO; Allow circular using.
//TODO Uploadable public packages to .@name, default to using player names for this. register other organization names for this too.
// using .@"ether.orbitmines.com".UI, <TODO Version>
//TODO: If working in some folder, automatically change versioning numbers to the new ones, if the file is changed.
//TODO Should work with the versioning system somehow? another parameter here the version, which the IDE supports for automatically getting
def using at?: Entity = global.Ether, path: (inventory: Inventory) => Inventory
  environment = caller

  def eval inventory: Inventory
    item: Item = path(inventory)()
    //TODO eval item
    //TODO Only allow certain things to be imported/changed by certain imports.
  end

  //TODO; If defined in player.inventory, define super() to call the original functionality.

  //TODO; Check if version exists on desktop if configured for remote, if it does use it.

  eval at.inventory if at // Load
  eval desktop.inventory // Load default settings
  eval player.inventory // Load player overwrites
end
