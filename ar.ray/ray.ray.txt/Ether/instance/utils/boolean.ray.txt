class boolean = false | true = Binary.Digit.value // TODO This should automatically implement "0" | "1" as boolean, through Binary.Positive. : Generalized to: Anything that is implementing Array<T>, like Positive, should also apply to just a T.
  // TODO Verify that these are correct work for all cases.

  //TODO Can extract operator out of boolean, as a default metaprogramming class
  static class Operator = Unary | Binary
    static Unary = *{parameters#.empty}
    static Binary = *{parameters#{length == 1}}
    //TODO These with the metaprogramming setup instead.
    //TODO Allow ternary operators defined as:
    // def * {b} * {c}; which match to a * b * c
    // Which is almost the same structure as def *(b, c), but assumes structure on the edges
  end

  !{.}
    | this !&& this
    | this !|| this
    | this x|| true
    | this x!|| false

  && (b: boolean)
    | !(this !&& b)
    | !(!this || !b)

  || (b: boolean)
    | !(this !|| b)
    | !(!this && !b)

  nand | !&& (b: boolean)
    | !(this && b)
    // An implementation using gotos so that a conditional goto is the only (necessary) primitive.
    |
      goto 2nd_check if a
      goto 1
     2nd_check\
      goto 0 if b
     1\ return true
     0\ return false

  nor | !|| (b: boolean)
    | !(this || b)

  xor | x|| (b: boolean)
    | !(this x!|| b)
    | (this && !b) || (!this && b)

  xnor | x!|| (b: boolean)
    | !(this x|| b)

  // Allow casts to filters
  as <T>(:== T{}) => T{this}
end
{ false, true } *= boolean // Could also be 'false, true = boolean' in this case.
