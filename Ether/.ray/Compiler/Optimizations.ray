//TODO optimization store both arrays and add to both, vs iterating over each
//TODO Indexes like B-trees for lookups when a string etc..
//TODO optimize ignore_case check to both sides lower_case/upper_case
//TODO Ray.index compiles to a for-loop with i+1
//TODO If a single item is in multiple inventories, how is persistence done? Is it stored in one, refs, in another, stored in both, want to allow for all of these options, how to deduplicate if it's known it's in two inventories: merger, or what?

// Optimize boolean checks by saying unordered # the first thing that returns true collapses it
var = var#{== true}.first

//if boundtype is < infinite, .infinite should return false
// - How to know whether to store whole object vs a reference (optimization); Need to know which places references this, so that it doesnt get deleted while referenced (just like any pointer reference, reference counting/tracking)

//    Three-address code, Static single-assignment form, Constant folding,  “common subexpression elimination”, “loop invariant code motion”, “global value numbering”, “strength reduction”, “scalar replacement of aggregates”, “dead code elimination”, and “loop unrolling”.

// Cycle detection & merger

//Fast substring search algorithms exposed (e.g., KMP, Boyer-Moore)

//TODO HOw to say rewrite gotos to if statements because we target ifstatements but not gotos

// Dead code like a = b, a = c, 'a = b' is never used. (Unless something like history is accessed somewhere)

// Debugging like timer.
global**.[INSERT IN BETWEEN EACH STATEMENT DYNAMICALLY]

// How is something like the proof that after a .push_back(A), .last = A, unless another push_back is used. How do you represent that, and how is it used by the compiler?
// -> SHould be trivial & automatic

// When using multiple implementations of methods, you want enumerations of possible requirements, so for boolean this could be NAND, NOR, NOT & OR, NOT & AND. etc..

// Multiple implementations, but what are the tradeoffs?