//TODO Move to a geometry file?
//TODO support other scientific units
SI_Unit m "meter"

//Allow 1 / m, 1 per m 2/10m

class Quantity<Base = Number> = quantities: (quantity: Base, unit: Unit = Unit.None)[]{length > 0}
  //TODO Implement number

  // Ensure that every part of a quantity like '1d 10h 10ms' is part of an equivalence class.
  dynamically assert quantities.every _, unit => unit == quantities.0.unit
  // Require quantities are in order from largest -> smallest
  dynamically assert quantities.unit as quantities.0.unit[] -- .sorted(>)

  // Allow for syntax `1d 10h 10m 30s`
  def `quantity: Quantity` = quantities ,= quantity

  // Allow for syntax `10000000s ~~ normalizer = days hours minutes seconds`
  def as(:== Normalizer) = Unit.Normalizers.modulus(this)
  // Allow for syntax `10000000s as days hours minutes seconds`
  def as(normalizer : Quantity{quantities.every(.quantity == 1)}} = this ~~ .normalizer = normalizer

  def as(: (operator: (greater_than: > | >=) | < | <=) unit: Unit) => static
    quantities = this.quantities~{.unit operator unit}
    converted_to = quantities.(greater_than ? last : first).unit
    converted_quantities: Quantity = greater_than ? converted_to -> : <- converted_to

    quantities ~~ .(greater_than ? last : first) += converted_quantities as converted_to
  end
end

class Unit = name + symbol: boolean? + plural: boolean? + singular: !symbol && !plural
  static namespace Normalizers
    def modulus order: Quantity => Quantity.Normalizer = (x) => {
      result: Quantity?
      order.quantities.unit.for unit
        quantity = x as unit (-- .floor if !is_last)

        result ? result quantity : result = quantity

        x -= quantity
      end

      result
    }
  end

  (static.# ??= []).push this

  // Allow for syntax `name`
  // Allow for 'var: Decimal.Positive, ns = 10 ns' syntax.
  caller[name] = this if name
  //TODO Allow for duplicate names like 8m meaning meter and minute

  def reexport
    caller[name] = this
    defined_globally = true if caller == global
  end

  static None = Unit(global.None)

  static ~ ray: Tree
    //TODO If base is string, initialize unit.
    //TODO
  end

  def `unit: Unit`
    //TODO String units like 3h 20s
  end

  // Allow for syntax `year as ns`
  def as :== Quantity = 1, this
  def as other: ==.instance_of Unit = this as Quantity as other

  protected defined_globally = caller == global
  // There must be at least one unambiguous name defined
  dynamically assert this as String? != None
  def as :== String? = name
    // Stringify as an unambiguous name if not defined globally.
    -- #.remove(Unit#{!= this}.name) if defined_globally

  protected unit = this
  // Allows syntax 1`name` (1m)
  global.def `digits: Decimal.Positive.String, name: unit as String` => Quantity = digits, unit
  // Allows syntax 1.0`name` (1.0m)
  +def Decimal.Positive
    def `fraction: Decimal.Positive.String, name: unit as String` => Quantity = integer, ".", fraction, unit

    //TODO Should overwrite Number.def`node: not String` since it's more specific
    // Allows syntax 1 `name` (1 m)
    // Allows syntax 1.`name` (1.m)
    def `unit | unit as String` => Quantity = this, unit
  end
  // Allows syntax 1.0 `name` (1.0 m)
  // Allows syntax 1.0.`name` (1.0.m)
  +def Decimal.Real
    def `unit | unit as String` => Quantity = this, unit
  end

  def convert convert: (From < Number) => To < Number, ToUnit: Unit
    FromUnit = static

    global.+def Quantity<From>{.unit == this}
      def as :== ToUnit => Quantity<To>{unit == ToUnit} = convert(this)
    end

    //TODO This shouldn't be necessary the 'as' before should already do this.
    //TODO Automatically implement reverses of offset, multiple, magnitude, If reversible. Decimal.Positive => Decimal.Positive for instance is only reversible if the dynamically asserts holds of being divisble.
    //global.+def Quantity<To>{.unit == ToUnit}
    //  def as :== FromUnit => Quantity<From>{unit == FromUnit} = convert.reverse(this)
    //end
  end

  def offset offset: Number, ToUnit: Unit
    convert x: Number = x + offset, ToUnit
  end

  def multiple multiple: Number, ToUnit: Unit
    convert x: Number = x * multiple, ToUnit
  end

  def magnitude exponent: Number, ToUnit: Unit, Base: Decimal
    //TODO Support non-integer magnitude exponents for reals.

    //TODO These should automatically implement for Decimal, and Decimal.Real
    convert x: Decimal.Positive => Decimal.Positive, ToUnit
      dynamically assert
        // Positive exponents we can always shift within Decimal.Positive
        exponent >= 0
        // Otherwise check if we can divide by that exponent
        | x % 10^-exponent == 0 // TODO Should only implement method if this assert passes

      x << exponent //TODO This is a decimal (`Base`) shift, when working with binary values you want to access them as binary if you want that shift.
    end
    convert x: Decimal.Real.Positive => Decimal.Real.Positive, ToUnit
      if exponent == 0
        x
      elsif exponent > 0
        x.integer, x.fraction.0 ?? 0, ".", x.fraction[1..]
      else
        x.integer[..-1], ".", x.integer[-1] ?? 0, x.fraction
      end
    end
  end
end
 

def SI_Unit
  def `symbol: *` name: *
    def si_name(symbol_prefix, prefix) = symbol_prefix + symbol + symbol: true | prefix + name ("s" + plural: true)?
    private SI = {
      -30: si_name "q", "quecto"
      -27: si_name "r", "ronto"
      -24: si_name "y", "yocto"
      -21: si_name "z", "zepto"
      -18: si_name "a", "atto"
      -15: si_name "f", "femto"
      -12: si_name "p", "pico"
      -9: si_name "n", "nano"
      -6: si_name "Âµ" "micro"
      -3: si_name "m", "milli"
      -2: si_name "c", "centi"
      -1: si_name "d", "deci"
      0: si_name "" ""
      1: dsi_name "a", "deka"
      2: si_name "h", "hecto"
      3: si_name "k", "kilo"
      6: si_name "M", "mega"
      9: si_name "G", "giga"
      12: si_name "T", "tera"
      15: si_name "P", "peta"
      18: si_name "E", "exa"
      21: si_name "Z", "zetta"
      24: si_name "Y", "yotta"
      27: si_name "R", "ronna"
      30: si_name "Q", "quetta"
    }
      .map(magnitude, name => Unit(name: magnitude: magnitude))
      .reduce(|)


    SI#.for FromUnit = FromUnit.magnitude SI.magnitude - FromUnit.magnitude, SI

  end
end