global.player: Player? = external
global.desktop: Server = external // TODO inventory.fs defined by external.
global.Ether: Server = external // TODO ether.orbitmines.com

//TODO All networking is abstracted away behind players/servers/inventories.

// Everything is an Item, and possibly an Entity.

def Visibility = InheritFromInventory | Entity

//TODO You can have anything with really long values, which don't need to be loaded directly, but can be loaded partially.
//TODO This partial loading should also support encodings which can be decoded partially too.
//TODO Or partial downloads of arbitrary parts of a file. (Allow access the parts out-of-order if present)
class Item
  // TODO history could include When it's used, how it's made, how it's discovered, how it's constructed.

  // Items require Quests ; In order to find items you need quests.
  obtained_by: Quest

  //
  issued_by: World
  certificate: Certificate

  // Read-access
  visibility: Visibility = Visibility.InheritFromInventory // = Entity{==.instanceof Player}
  // Write-access (defines allowable values one can write to each field)
  access: Query<static>

  // TODO A program of possibly entities that are allowed to see this. Things like private servers which are allowed to see it. (Or the local server) - Can also include things like 'within renderdistance'.
  // TODO, Want to add things like : has been at this location in this world before for instance.
        //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item): So has this type of item, then it's visible.

  inventory: Inventory?
  

  def move inventory: Inventory
  //TODO Transaction
  end
  // TODO On change, if has access, save. Otherwise, save local copy.
  def save
  // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
    //TODO Write to inventories
  end
  def delete

  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
  def as :== Map
    // TODO Perspective switch to a 'high-level overview'
  end

  def as :== World = this ==.instanceof World ? this : TODO
    //TODO: How does 'World' differ from structure the item is made of.
    //TODO: World might not necessarily be accessible (Say the hidden dynamics of some function of some language)
    // TODO Internal structure of an item.
  end
end

+def Node
  def as :== Item = Item(
    //TODO obtained_by
    issued_by: global.desktop,
    certificate //TODO,M
  )
end

+def String{== "private"}
  def as :== Visibility = Entity{== global.player ?? global.desktop} //TODO This check needs to be secure, so noone can spoof it.
end
+def String{== "public"}
  def as :== Visibility = Entity{true}
end

// TODO You want to say, have a world in your inventory, which is your desktop. Which contains items. Those items are not directly in your inventory? But they can be put there.
class World < Entity
  //TODO What are quests and location of a world?

  // TODO What if I define my own alias for this world, it doesn't get stored in the global World config, but I want it in my own
  //   -> Allow overriding of default config: inventories by the user.
  // A server can still host a world where parent != that server.
  def parent => World? = this.name.issued_by != this ? this.name.issued_by : None

  // TODO Serverlist maintained by the world, but others could be running it too.
  // Known servers which this world runs on (TODO Others might be discovered later, so .hosts might be non-halting)
  store hosts Server

  // TODO World generation vs world rendering, in certain cases world rendering would be similar to world generation.

  //TODO What about behavior dictated by the world/server: These things are automatically shown, these things not.
    //TODO Might want to tie a quest to a location too.

  // Internal dynamics -> Want a primitive in .ray to be a dynamic space.

  // Split into two groups: Spaces with arbitrary propagation vs limitations:
        How do you make spatial propagation hard/limit it in a distributed sense when usually one can just skip ahead programmatically?
        -> Similarly how we make item copying expensive/impossible. Scarcity of the items.

  spawn_location: Location

  // TODO, An entity should be a graph within the graph, both of those shouldn't interfere with each other. (As in effecting .next)

  def entities = worlds & players & npcs
  store players Player
  store npcs NPC

  // Child worlds, where this world is acting as a parent category
  store #`world: this != global.Ether ? String.NonEmpty : String.NonEmpty & not global.Ether.name.ignore_case` World?

  if this == global.Ether
    def #`global.Ether.name.ignore_case` => World = global.Ether
  end

  def worlds = (this.#`String.NonEmpty` -> .#`String.NonEmpty`).compact.reduce(&) //TODO Should overlay Both cases of "Ether".ignore_case and not.
  //TODO: Should know that, because of using reduce(&), that intermediate results are possible for .last (Don't need to compute all children to get some values out of this). That should also work for '(this.#`String.NonEmpty` -> & .#`String.NonEmpty`).compact.last'
  //TODO worlds{parent == None} should know that  it doesn't need to go into the children.

  // Players can be registered under a certain world, similar to how certain games/apps have UserName#Tag, where the
  // #Tag is the world.
  store @`player: String.NonEmpty` Player?
end



// Spatial Propagation
// - Separate graphs for moving pieces?
// - One way of doing 'air you can move through' Split the graph one is moving into, and knit it back together on the opposite end of the structure that's moving.
   // Does disallow overlapping structures within the same space.
// - Or something more inspired by physics, based on the structure that's there in the graph, allow/disallow.
    // More spatial structure around matter
    // If something like an arm is attached, the further from the attachment the faster it has to move
// - World only has update events, you want those to be massively parallel, so what can influence what? -> What would actual execution on a GPU look like, how much does having it in a graph impact performance?
//

// TODO How does a location work if it's a dynamic space?
def Location < Item //TODO = Ray of World OR: You want Location to be more abstractly, a subregion: subgraph - which could be a specific location, of a World. It could also be a description of surroundings, which is not yet certain where exactly in the world that is.
  world: World? //TODO Could be many: it's in one of these worlds.

  //TODO Location too has a visibility, to whom am I broadcasting that I'm here.
end

def Quest < Item
  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  // - Effectiveness rating -> In the case of effecting other items.

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate: Certificate?
  end
  def active = !completed
end

def Map
end

// TODO Items arranged in a particular way make another item. Something like = Hypergraph<Item> or it's a primitive item.
+def Hypergraph<Item> //TODO Hypergraph here? -> Item as Hypergraph<Item> implemented.
  def as :== Item
  end
end


//TODO Since the inventory is possibly managed by another Entity (server), that means that it has access, and it can give others access.

// Managed inventories have some visibility/access, and thisw is one value for the manager (world), and another for the player, how to make that differentiation?
//TODO: How to indicate it is managed by the world, and synced to the player.
// Managed inventories at this location for a particular Entity.
def `entity: Entity` => 1 Inventory
// Managed inventories at this location by a particular World.
def `world: World` => 1 Inventory

// Inventories differ slightly from traditional file systems:
//   - There can be many items (files) defined at a single location. These could have additional operators defined on
//     them like AND/OR, and they could also be abstractly defined; They work just like any Type in `ray.txt`.
//   - Inventory works like directory: It defines a path. But at any path items (file) might be defined. Additionally,
//     it might host additional inventories and items like a directory. So any path is always a directory and a file.
// 
// When inventory is used as an Item, it is just "the path to that inventory".
class Inventory < Item
  owner: Entity
  path: *[] = []
  def [path: *[]] => Inventory = this +.overwrite { .path = path }
  
  recursive = {
    def items => Item = (this -> ==.instance_of Inventory ? .items : .)[1..].reduce(&)
    def inventories => Inventory = (this -> .inventories)[1..].reduce(&)
  }
  
  // Get children of this inventory.
  def items => Item
  def inventories => Inventory = items{==.instanceof Inventory}
  
  // Get the items defined at this inventory.
  def get => Item{visibility: Entity, inventory: Inventory}? // TODO These refined types should be implied.
    //TODO Load item as a .ray.txt file, with restrictions.

    //TODO Get a specific type
  
    // Many items might be stored at this location.
    item = sub() //TODO Support sub(), indicating that the method still needs to be implemented.
    item.visibility = path.map(.visibility){!= Visibility.InheritFromInventory}.last
    item.access//TODO Set access
    item.inventory &= this
    //TODO: Might have settings of certain servers to backup the player information to.
    item
  end
end

class Entity < Item
  inventory: 1 Inventory
  def quests => Quest = inventory{==.instanceof Quest}

  def store type
    def `field: *`
      this.def `field` => type = inventory[field]()
      //TODO: What if inventory doesn't have that type stored.
      this.def `field`= value: type
        //TODO Use .save/.delete the previous entries.
        //inventory[field] = value //TODO Should automatically implement &=, |= as well.
      end
    end
  end

  store name Name

  store location Location
  +def location //TODO Allow this syntax.
    primary: boolean? //TODO Whether this is the location we're actually currently rendering on screen.
  end
  def world = location.world
  //TODO What if you only want to broadcast a particular part of your location, say the world it's in or?

  // On top of 'visibility', an entity can be set offline server-side: Indicating only offline communication.
  def online => boolean //TODO for a server: set this value, for client: poll for data.

  // A world might live on many entities/servers
  //TODO A player, or any entity can (co-)host worlds
  //TODO : From the perspective of this entity,
  hosting: World //TODO These worlds should come from an Item in the server's inventory = is just (inventory as World){visibility = ??}

  //TODO Specific parameter types can be enforced using Entity instanceof SomeOtherEntityWithConstraints
  def `world: World` => Entity{name: Name?, location: Location?}
    return this +.overwrite { // TODO Support +.overwrite as opposed to adding the results of the two to each-other. Type-checking should recognize the +.overwrite is defining at least the thing before the +.
      inventory = this.inventory[world],
      name = this.name{issued_by == world}
      location = this.location{.world == world}
    }
  end
end

def NPC < Entity
  //TODO Defines dynamics in a World
end

def Player < Entity
  //TODO: You want to be able to host a server as an item to a world, with some visibility.
  store desktop Server //TODO Should be multiple here, and only change the one with this identifier, (can use MAC-address, but we need additional identifier stored for dual-boot)


end
def Organization < Player
  //TODO Reserve namespace with dots to domain names.
end

//TODO Some server, which holds the 'first discovered by X' status, and issues certificates for that./
class Server < NPC, World

  //TODO Server might be behind some nameserver, delegating to many other servers.

end

def @`player: String.NonEmpty` => Player = Ether.@`player`
def #`world: String.NonEmpty` => World = Ether.#`world`

def Name = String.NonEmpty < Item
def Certificate
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end


//TODO #World.#ChildWorld.@UserName where #ChildWorld.name.issued_by = #World
//TODO Equivalent .UI = .#Ether.UI
//TODO Equivalent: .#Ether.@UserName = .@UserName
//TODO .#world.@UserName.
//TODO; Require domain names registers on @"orbitmines.com" to be verified
// TODO; Allow circular using.
//TODO Uploadable public packages to .@name, default to using player names for this. register other organization names for this too.
// using .@"ether.orbitmines.com".UI, <TODO Version>
//TODO: If working in some folder, automatically change versioning numbers to the new ones, if the file is changed.
//TODO Should work with the versioning system somehow? another parameter here the version, which the IDE supports for automatically getting

private class Module
  static Constructor = (root: Module = Module()) => Module //TODO Constructor is parameterless, so you shouldnt need to call it with (), so just naming a variable this should work. BUt what if you would want to pass it a parameter, there's an ambiguity here.
  
  def (node: *) = ..path.reduce(acc = node, current => acc[current])

  `` = {
    def parent: Module?

    def property: *?
    def world: World?
    def player: Player?

    def path => *[] = (..parent <- this).map(.world ?? .player ?? .property).compact //TODO This, because it's private shouldn't be overwritten? How does that work?
  }

  def `property: * & not ""` => Module
    return this if property ==<String> "."
    return this.parent ?? this if property ==<String> ".."
    return Module(..parent = this, ..property = property)
  end

  if !parent || parent..world
    def #`world: String.NonEmpty` = Module(
      ..parent = this,
      world = (parent..world ? parent..world : global.Ether).#`world`
    ) //TODO Check if not None

    def @`player: String.NonEmpty` = Module(
      ..parent = this,
      player = (parent..world ? parent..world : global.Ether).@`player`
    ) //TODO Check if not None
  end
end

def using at: Entity? = global.Ether, path: Module.Constructor
  environment = caller

  def eval inventory: Inventory
    item: Item = path(inventory)
    //TODO eval item
    //TODO Only allow certain things to be imported/changed by certain imports.
  end

  //TODO; If defined in player.inventory, define super() to call the original functionality.

  //TODO; Check if version exists on desktop if configured for remote, if it does use it.

  eval at.inventory if at // Load
  eval desktop.inventory // Load default settings
  eval player.inventory // Load player overwrites
end
