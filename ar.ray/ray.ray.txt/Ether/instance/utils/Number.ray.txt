
//TODO Complex Numbers as &+ ?,
// sqrt, Trigonometry,

Binary +=
  * |= (b: Number % mod 2 = 0) => this << (b / 2)
  << |= b = this.push_back(0[]{length == b}) //TODO Overflow for i64 is done how?

// Lean: On a 32-bit architecture, USize is equivalent to UInt32. On a 64-bit machine, it is equivalent to UInt64.
//   -> How to conditionally get the architecture for this definition.

//TODO Number equipped with default numberline, so number.for works. for Real, a step function needs to be defined

//TODO factorial!

//TODO Perhaps switch .Positive and Base, what do you call one with a sign though?
//TODO Rename to .Signed

//TODO Unit's like 1m are transfinite numbers in the sense that 1m > Infinity, but not Infinity m

// "01101010" ~|| "10101000" & 0101010 ~|| 1010010 work
//TODO Automatic equivalence between Real.Positive -> Real & Base -> Base.Signed

// Binary{length == 1} == boolean

class Number
  Nat | ℕ <n> = Array{length == n}().last&&
  ℝ: Any Base ℝ
{ ℕ, ℝ } = Number

def Integer<n> = sign: "-"?, integer: Positive
  static def Positive = Array{length == n}().last&
  //TODO Addition/subtraction of this integer (addition is simple)
end

//TODO Define .sign on all numbers, so that you can do x.sign ().sum, empty string is + so nothing gets applied since it's empty string.

private class Digit = String  //[].reduce(|)

Base = &'ed version of all the numbers

  def value(digit: this = this)
    array = this.reduce(array = [] => array.push_back(void))

    this.for d
      `d` = this{<= d}.reduce(cursor = array => cursor.next)~
    end

    return local[digit]
  end
end

// TODO: Strings as a definition depend on Number, circularity here.
Bases = {
  Binary: Digit = "0" | "1"
  Ternary: Digit = "0".."2".reduce(|) //TODO .reduce is automatic
  Quaternary: Digit = "0".."3".reduce(|)
  Quinary: Digit = "0".."4".reduce(|)
  Senary: Digit = "0".."5".reduce(|)
  Septenary: Digit = "0".."6".reduce(|)
  Octal: Digit = "0".."7".reduce(|)
  Nonary: Digit = "0".."8".reduce(|)
  Decimal: Digit = "0".."9".reduce(|)
  Undecimal: Digit = ("0".."9", ("a" | "A")).reduce(|)
  Duodecimal: Digit = ("0".."9", ("a" | "A")..("b" | "B")).reduce(|)
  Tridecimal: Digit = ("0".."9", ("a" | "A")..("c" | "C")).reduce(|)
  Tetradecimal: Digit = ("0".."9", ("a" | "A")..("d" | "D")).reduce(|)
  Pentadecimal: Digit = ("0".."9", ("a" | "A")..("e" | "E")).reduce(|)
  Hexadecimal: Digit = ("0".."9", ("a" | "A")..("f" | "F")).reduce(|)
}

dynamically Bases.for Base, digit

  //TODO Because String has digit as String defined, any Array of digit Strings should automatically be defined, to as String too. with .map
  +def String = `Base`.Digit
    def as : == `Base`.Digit.value = `Base`.Digit.value(this)
  end
  //TODO String as Binary.Positive = "0101010" = Digit.value[] = Positive
  // TODO: Binary.Positive as String; Automatic isomorphism

  class `Base` < Number = sign: "-"?, integer: Positive

    //TODO Equip a default directionality. (Line: One with forward/backward from a specific point, but it isn't necessarily selected there.)

    //TODO Because sign is a String, Positive is castable to a String, `Base` is castable to a String
    static String = static as String

    static Digit = digit
    //TODO This should not be in the constructor, but taken outside of it.


    // TODO Some for of this.toString which would be sign.toString, integer.toString which would use 'String'. But then for static, on the types.


    // We use 'Positive' here, since a 0, in this construction can be signed. (Even though for most operations that difference won't matter)
    static class Positive = integer = Digit.value[]{length > 0}

      //TODO If extends Digit.value[], allow to cast `Base`.Positive[] to `Base`.Positive. But Decimal as Binary is different than Decimal[] as Decimal as Binary
      static def String = Array<Digit as String>

      def `fraction = Positive.String` => Real.Positive = integer, ".", fraction

      def times callback: () => *
        //TODO Support index?
        Array{length == this}().for => callback()
      end
    end

    { Rational, Irrational } = Real

    static class Real = sign = "-"?, real = Real.Positive
      static String = static as String //TODO This should be autmoatically implemented because Postitive implements it

      static class Positive = integer: `Base`.Positive, ".", fraction: `Base`.Positive.Unbounded
        static String = static as String

        //TODO How to simultaneously implement .rational/.irrational as boolean checks.
        static Rational = Positive{fraction ==.instance_of (
          // Finite
          `Base`.Positive
          // Or repeating
          | `Base`.Positive[]{length == Infinite}
        )}
        static Irrational = not Rational //TODO Allow this syntax
      end
    end
  end

  // "0001 is equivalent to 1" //TODO Reverse is true also, how's that done?
  `Base`.Positive{==.instance_of 0[], number: `Base`.Positive}
    as (== `Base`.Positive) => number
end

+def Binary.Positive

  def ~! = this.map(!)
  def ~`operator: boolean.Operator.Binary` b: Binary.Positive = this.reverse.zip_longest(b.reverse).map(l, r => (l ?? false)[operator](r ?? false)).reverse
  def ~`operator: boolean.Operator.Binary` b: Binary.Positive{.length == length} = this.zip(b).map(operator) //TODO: Or can the compiler deduce the reversing stuff is not necessary?
end

//TODO Should not always goto Decimal, should infer from context whether it is binary or not? How to do that; code it as a type?
def `digits: Decimal.Positive.String` => Decimal.Positive = digits
+def Decimal.Positive
  def `fraction: Decimal.Positive.String` => Decimal.Real = integer, ".", fraction
end
//TODO 1111₂⁸ x 1111₂⁸ subscript.
//TODO 1⁽¹⁸⁸⁻⁰⁰⁾ superscript to ^ (number)

// Allow (111₂)₂
`Base`
  v (base: Number): [RELEVANT BASE] =>
    // Unknown digit representation for the specified base.
    assert this.every <= base
//TODO We're also using subscript for length, so number should be not using v, but instead match to the whole string + subscript

//TODO Override the ^/* behavior of the Number type to use the list variant instead. -> Need some quick method for that
static prefer{== BASE_TYPE} Iterable.(^ | *) //TODO Should only work for the base static case
Node
  {expression: String.Superscript} => this ^ expression.decompose as Expression
  {expression: String.Subscript} => this v expression.decompose as Expression //TODO as Expression, should take the existing context which called this, and evaluate in that.

def 0`"x" | "X"``digits: Hexadecimal.Positive.String` => Hexadecimal.Positive = digits
//TODO This for binary
def 0`"b" | "B"``digits: Hexadecimal.Positive.String` => Hexadecimal.Positive = digits

//TODO: Possibly move these primitives to specific languages, and only work with arbitrary-length in the default case.
//TODO: -b: Something uX might only implement b: uX, casts lose information and likely need to overflow
def u`length: Decimal.Positive.String` = Binary.Positive{.length == length}
  // TODO Number arithmetic
  // - overflow, what to do? mod, or>?
end
def i`length: Decimal.Positive.String` = Binary.Positive{.length == length} // TODO, Use Binary vs Binary.Positive
  // TODO Number arithmetic
end

class Number < Ordered
  def - => Number
  def - b: Number => Number

  // Allows for the syntax 1 Object
  def `node: not String` = node{#.count == this}

  // TODO Generic Number interface which others should extend, things like >/< should come from another interface which is "NumberLine"
  // TODO Infinity is a looped integer. -infinity a .reverse"d loop. .reverse needs to be preserved for them to be differentiated?
  // TODO: external defines that Number > Number is done by some other operator, not looking through successors/predecessors.
end

Decimal
  % => this / 100

Probability = Number{0 <= . <= 1}

Number.Nat
Integer.Unsigned
  {" "}{node: *} => node{#.count == this}
Probability{!= 1}
  {" "}{node: *} => //TODO How to say %, what to do in case of non-divisible

{
  (Σ | ∑): sum -> +,
  ∏: product -> *
}.for symbol, method -> operation
  Applicable = Iterable<T: {`operation`(:T) => T}> //TODO A variable like this shouldn't be loaded into local, loop-specific var Howto?
  +def Applicable
    def `method` = reduce(operation)
  end
  namespace `symbol`
    // Allow syntax ∑ [1, 2, 3]
    def `iterable: Applicable` = iterable.`method`
  end
end

// ₂∫⁸()
// lim(x -> ∞) ₂∫⁸() // Implemented as infinitesimal step, how to indicate to actually step?
//TODO What is a limit actually, can we make that more general?
// √4
// ∛/∜ √(4 + 4)
// What else


//TODO Infinity / ∞

Byte = Binary{length == 8}
//TODO 1000 MB etc.. MiB ; how does that coincide with Unit, want Binary with some length to correspond to it?
