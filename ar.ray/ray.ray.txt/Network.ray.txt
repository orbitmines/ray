namespace Network

              // ETHER
  DEFAULT_PORT = 37839

  class IP < Location = -1 <- . -> +1
    static NUMBER_OF_SEGMENTS => Decimal.Positive
    static SEGMENT_LENGTH => Decimal.Positive
    static NUMBER_OF_BITS = NUMBER_OF_SEGMENTS * SEGMENT_LENGTH

    static +def Segment
      static Binary = Binary.Positive{length == SEGMENT_LENGTH}
    end

    static String = static as String

    def segments => Segment[]{length == NUMBER_OF_SEGMENTS}

    def as :== Binary.Positive = segments as Segment.Binary[]

    // CIDR notation
    def / prefix_length: Number{0 <= . <= NUMBER_OF_BITS} => static
      return this if prefix_length == NUMBER_OF_BITS

      binary_form = as Binary.Positive
      binary_form[prefix_length..] = 0 | 1

      binary_form
    end

    def + offset: Number{-(as Binary.Positive) <= . <= ~!(as Binary.Positive)} => static
      as Binary.Positive + offset
    end
    def - offset: Number{- ~!(as Binary.Positive) <= . <= as Binary.Positive} => static
      as Binary.Positive - offset
    end

    //TODO Range operator.

    static class v4 = segments.join(".") < IP
      static NUMBER_OF_SEGMENTS = 4
      static SEGMENT_LENGTH = 8

      static Segment = Decimal.Positive{< 2^8}
    end

    static class v6 = (left: Segment[]).join(":")?, zero_compression: defined_segments.empty ? "::" : "::"?, (right: Segment[]).join(":")?, (":", embedded_ipv4: IPv4)? < IP
      def defined_segments = left, right, embedded_ipv4 as Binary.Positive

      dynamically assert defined_segments.length (zero_compression
        ? < NUMBER_OF_SEGMENTS - 1 // '-1' Because: The symbol "::" MUST NOT be used to shorten just one 16-bit 0 field. (https://datatracker.ietf.org/doc/html/rfc5952#section-4.2.2)
        : == NUMBER_OF_SEGMENTS
      )
      // When there is an alternative choice in the placement of a "::", the longest run of consecutive 16-bit 0 fields MUST be shortened (https://datatracker.ietf.org/doc/html/rfc5952#section-4.2.3)
      dynamically assert left & right ~= 0[] -- .length < number_of_compressed_segments if zero_compression
      // When the length of the consecutive 16-bit 0 fields are equal, the first sequence of zero bits MUST be shortened. (https://datatracker.ietf.org/doc/html/rfc5952#section-4.2.3)
      dynamically assert left ~= 0[] -- .length != number_of_compressed_segments if zero_compression

      static NUMBER_OF_SEGMENTS = 8
      static SEGMENT_LENGTH = 16

      static Segment = Hexadecimal.Positive{length <= 4}

      def segments = left, 0[]{length == number_of_compressed_segments}(), right, embedded_ipv4 as Binary.Positive

      def number_of_compressed_segments = NUMBER_OF_SEGMENTS - defined_segments.length
      def compress_zeros => v6
        return this if zero_compression

        zeros = defined_segments ~= 0[] -- @{length == min() & leftmost} # TODO How to iterate over @ like min. and leftmost
        return (<- zeros) "::" (zeros ->)
      end
      def embed_ipv4 => v6
        return this if embedded_ipv4

        return segments[..-3], segments[-2..] as Binary.Positive as IPv4 -- .compress_zeros
      end

      def as :== String =>
        // mixed notation is RECOMMENDED if the following condition is met: the address can be distinguished as having IPv4 addresses embedded in the lower 32 bits solely from the address field through the use of a well-known prefix (https://datatracker.ietf.org/doc/html/rfc5952#section-5)
        -- .embed_ipv4 if this ~= ^"::ffff" // TODO Do we need to this.compress_zeros here?, or should this be picked up automatically. How to distinguish between seeing if it actually starts with the string vs the converted value.
        -- .compress_zeros
        .super()
        // The characters "a", "b", "c", "d", "e", and "f" in an IPv6 address MUST be represented in lowercase. (https://datatracker.ietf.org/doc/html/rfc5952#section-4.3)
        .lowercase

    end
  end
  IPv4 = IP.v4
  IPv6 = IP.v6

  Port = Decimal.Positive{< 2^16}

  class Socket
    static class Address = (ip: IPv4) | ("[",(ip: IPv6),"]"), (":", port: Port = DEFAULT_PORT)?
      protocol //TODO
    end
  end

end

+= Network

// Allow string CIDR notation
[IPv4, IPv6].for IP
  def String{==.instance_of (ip: IP.String) + "/" + (prefix_length: Decimal.Positive{<= IP.NUMBER_OF_BITS}.String)}
    def as :== IP = ip as IP / prefix_length
  end
end

+def Node
  static class Remote
    //TODO All object access go over network, and backup it in a local copy, what if that local copy is already defined somewhere?
    //Remote .location might not know about our copy, so how do we do remote_variable @ local
    //TODO Settings location to an instance, should say: anywhere in this instance, I don't know where. So if it's @ some_specific_location in local, it should still go to this method?
    //TODO What if the value is stored at a location, but we're looking for something which is at an unknown instance? But with particular structure?

    // If we want the local reference to a particular value, we don't consult remote.
    def @ instance: global.instance = instance[location]
  end
end
