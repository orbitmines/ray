

+def Node < Entity
end

class Item
  // The known locations this item is referenced. This could be properties of an object, or a location in a World.
  location: Ray = inventory

  // Every item has an inventory defined on it: '<-' is parent directories, '->' are child directories. Loops allowed.
  inventory: Ray = Ray(this)
  //TODO fields shoultn necessarily count as child directories, since we might have a structure on some location (arbitrary), but it's children are not the same as its fields. Take directories for example.

  //TODO We would also want to know how version control works, and how something lioke git is supported, since those visibility and sharing them is relevant
  //TODO Also, when visible, when is it synced to the instance.
  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    speculative if<assume: false> current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end

  def visibility: Entity = inventory.previous?.value.visibility ?? "local"
end
class Entity < Item

end

class World
end

def Instance
end

def Player
  // The known instances currently running this player.
  instance: Instance

  +def location
    // When filled, this indicates that the provided instance is rendering this location.
    primary: instance?
    dynamically assert @{.primary == primary}.count == 1 if primary // Only one primary location per instance.
  end
end

// "local" means only on the local instance. (Not even local child instances)
+def String{== "local"}
  def as :== Entity = Entity{== global.instance}
end
// "private" means any instance running this player. Note that any backup server, like the central Ether server, has
// that property. Backup servers are configured using //TODO
+def String{== "private"}
  def as :== Entity = Entity{== global.player || == global.instance}
end
+def String{== "public"}
  def as :== Entity = Entity{true}
end



// TODO .desktop inventory.fs defined by external.
// TODO ether.orbitmines.com

//TODO Allow storage to set visibility = private, if there's an equivalence. (Generally allow this)

//TODO All networking is abstracted away behind players/instances/inventories.

//TODO A separate ether world which gives out unique user ids.

// Everything is an Item, and possibly an Entity.

def Visibility = InheritFromInventory | Entity

//TODO You can have anything with really long values, which don't need to be loaded directly, but can be loaded partially.
//     -> Networking code for doing this partially.
//TODO This partial loading should also support encodings which can be decoded partially too.
//     -> If it cannot be decoded partially, it should have the value stored on another level of description how?
//TODO Or partial downloads of arbitrary parts of a file. (Allow access the parts out-of-order if present)
class Item
  // TODO history could include When it's used, how it's made, how it's discovered, how it's constructed.

  //TODO ANY ITEM MIGHT be managed by another instance

  // Items require Quests ; In order to find items you need quests.
  obtained_by: Quest

  // TODO Is issued_by here some top-level world
  issued_by: World = global.desktop
  certificate: Certificate

  //TODO Can't really implement visibility s public/private/protected, since you have 'The memory object Player', and 'The actual player to expose it too', or are they the same thing? They should probably be the same thing.
  // Read-access
  //TODO Want a dynamic default, until it is set.

  //TODO Read-access with a specific encryption key
  //TODO Locally set to a different value than what the managed inventory says?> ever used?
  // TODO what if that location is say referenced in two places, one authorized by me which says private, and another unauthorized which says public, it shouldn't switch mine to public.


  // Write-access (defines allowable values one can write to each field)
  access: Query<static> //TODO access is Visibility for each field.

  // TODO A program of possibly entities that are allowed to see this. Things like private instances which are allowed to see it. (Or the local instance) - Can also include things like 'within renderdistance'.
  // TODO, Want to add things like : has been at this location in this world before for instance.
        //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item): So has this type of item, then it's visible.

  //TODO If every item is an inventory, then this is not used, but where it came from, is.
  //TODO This inventory = Location *in* an Inventory/
  inventory: Inventory?
  //TODO If every item is an inventory, we want to know whether that inventory can persistently store information.
  //TODO If a single item is in multiple inventories, how is persistence done? Is it stored in one, refs, in another, stored in both, want to allow for all of these options, how to deduplicate if it's known it's in two inventories: merger, or what?

  //TODO We have copy as well, but we could also copy by ref, or have both set refs to a single one.
  //  -> All object setting/getting becomes moving between inventories.
  def move inventory: Inventory
  //TODO Transaction
  end

  dynamically if inventory
    // TODO On change, if has access, save. Otherwise, save local copy.
    def save
      // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
      //TODO Write to inventories
    end
    def delete

    end
  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
  def as :== Map
    // TODO Perspective switch to a 'high-level overview'
  end

  def as :== World = this ==.instanceof World ? this : TODO
    //TODO: How does 'World' differ from structure the item is made of.
    //TODO: World might not necessarily be accessible (Say the hidden dynamics of some function of some language)
    // TODO Internal structure of an item.
  end
end

+def Node < Item //TODO There's a circularity here, but it should be supported.

  //TODO obtained_by
    issued_by: global.desktop,
    certificate //TODO,M
end


// TODO You want to say, have a world in your inventory, which is your desktop. Which contains items. Those items are not directly in your inventory? But they can be put there.
class World < Entity
  //TODO What are quests and location of a world?

  // TODO What if I define my own alias for this world, it doesn't get stored in the global World config, but I want it in my own
  //   -> Allow overriding of default config: inventories by the user.
  // A instance can still host a world where parent != that instance.
  //TODO .parent would be .indexed_by, and another .parent would be, how did you get to this world? (So a path)
  def parent => World? = this.name.issued_by != this ? this.name.issued_by : None

  // TODO Instancelist maintained by the world, but others could be running it too.
  // Known instances which this world runs on (TODO Others might be discovered later, so .hosts might be non-halting)
  hosts: Instance = Instance{hosting == this}

  // TODO World generation vs world rendering, in certain cases world rendering would be similar to world generation.

  //TODO What about behavior dictated by the world/instance: These things are automatically shown, these things not.
    //TODO Might want to tie a quest to a location too.

  // Internal dynamics -> Want a primitive in .ray to be a dynamic space.

  // Split into two groups: Spaces with arbitrary propagation vs limitations:
        How do you make spatial propagation hard/limit it in a distributed sense when usually one can just skip ahead programmatically?
        -> Similarly how we make item copying expensive/impossible. Scarcity of the items.

  //TODO Spawn-location defaults to something like .first. (If accessible) What if it's not, then demand it's provided.

  spawn_location: Location

  // TODO, An entity should be a graph within the graph, both of those shouldn't interfere with each other. (As in effecting .next)

  // All information on what's in a world could be partial client-side. It might not have all the information of the world.
  def entities = worlds & players & npcs
  //TODO These are basically indexes of things moving through this world.
  players: Player
  npcs: NPC
  //TODO You should have a way of saying, this is my location (so also pitch etc.) based on that what information is available about which entities (could be partial)

  // Child worlds, where this world is acting as a parent category
  def #`world: this != global.Ether ? String.NonEmpty : String.NonEmpty & not global.Ether.name.ignore_case` => World?

  if this == global.Ether
    def #`global.Ether.name.ignore_case` => World = global.Ether
  end

  def worlds = (this.#`String.NonEmpty` -> .#`String.NonEmpty`).compact.reduce(&) //TODO Should overlay Both cases of "Ether".ignore_case and not.
  //TODO: Should know that, because of using reduce(&), that intermediate results are possible for .last (Don't need to compute all children to get some values out of this). That should also work for '(this.#`String.NonEmpty` -> & .#`String.NonEmpty`).compact.last'
  //TODO worlds{parent == None} should know that  it doesn't need to go into the children.

  // Players can be registered under a certain world, similar to how certain games/apps have UserName#Tag, where the
  // #Tag is the world.
  def @`player: String.NonEmpty` => Player?
end



// Spatial Propagation
// - Separate graphs for moving pieces?
// - One way of doing 'air you can move through' Split the graph one is moving into, and knit it back together on the opposite end of the structure that's moving.
   // Does disallow overlapping structures within the same space.
// - Or something more inspired by physics, based on the structure that's there in the graph, allow/disallow.
    // More spatial structure around matter
    // If something like an arm is attached, the further from the attachment the faster it has to move
// - World only has update events, you want those to be massively parallel, so what can influence what? -> What would actual execution on a GPU look like, how much does having it in a graph impact performance?
//

//TODO You might have some way to navigate the structure of a world, but that doesn't mean it's just accessible. In a way
//TODO in which you can, for instance, just loop over all the nodes. You might have to explore some other way.
//TODO So a world defines how you can interact with it.
//       -> It defines how you can move through it, at those Nodes, additional worlds are defined.
//       -> Comparing is just movement is matching some other world I can move in (
//       -> I might not necessarily host all these worlds top-level (visibility) or on some indexed #property. (Indexed just means I've saved that location in my inventory somewhere)
//       -> But when I'm there, I might find those worlds and then gain access to them (if only temporarily)
//       -> So parent worlds, are just the path defined to get there.
//       -> The host, is merely the top-level instance on which we're exploring. (But that might change at each step)
//          -> Hosting, just means I got this step of information from this instance. (Each step might be deferred to another host)
//          -> So each node of information has with it: it came from here.
//          -> In the case of providing information from disk from instance to client: The instance nodes are decorated with host locations of the disk for instance or memory, and the player is from the instance.
//          -> What if I wanted to know the history of where it came from? So from disk to instance (to memory) to instance ... , until it came to me. -> So the instance can choose whether to provide that information.
//       -> A location also needs information like : A path to get here. (Which is just additional structure, but those in turn can be vague locations)
//          -> Path information crosses multiple hypergraphs.
//       -> World has something like dependent/optional inheritance on Abstract Directionality.
//       -> Interface with which you walk through a world is itself a graph. Say a 2d-visual-field.
//       -> Highly parallel rewritable structure in world.
//       -> Location should also specify what interface is used like yaw/pitch/screen size etc..
// TODO How does a location work if it's a dynamic space?
// TODO Abstractly, we never know (without looking) if another location also matches this description.

//TODO Say I have an abstract Map on which is a path which is the Location. It's a Location, with structure defined on it with points which abstractly represent those points in the path.
//      -> Say I have 4 abstract point, each point in a list, the points are described abstractly. Abstractly means arbitrary structure after a .expand (So .expand doesn't necessarily just fill in the ray, it could be structure like: 500 steps from here there's this thing which is approximately like this. Where approximately is a type.

def Location //TODO = Ray of World OR: You want Location to be more abstractly, a subregion: subgraph - which could be a specific location, of a World. It could also be a description of surroundings, which is not yet certain where exactly in the world that is.
  world: World? //TODO Could be many: it's in one of these worlds.
  //TODO world could be a substructure too. we want the top-level world?
  //world is .context, top-level .context means ? .world
  /
  /TODO How do you store, 400-500 steps after this, but we don't know what's in between. ray{.[400..500] ==.some Structure} // ray{.[1km..10km] ==..Structure} -- radius, not back and forth. ray[1 km] = wall
  //TODO How many steps is 1m?
  //TODO Edges are decorated with length.
  //TODO Then depending on the discreetness per 1m, we have values like 0.00001m, which could highlight a superposition of position nodes.
  //TODO Want to also have things like .by_road.[1 km] which is another overlay on the main graph with effective gravity relative to free-roam
  //TODO    What if that is the same graph, but filtered which direction you can go.

  //TODO By default the elementary_length is not defined so any Distance is further away than a step. Want to also have some definition of: .next to the first thing that matches. (which would match with things distance is used for)
  //TODO After calling .elementary_length(1nm) on Ray decorate all rays and graphs connected to that with functionality that supports distances.
  //      -> Unless otherwise specified by the edge, defaults to that per step.
  //TODO So things like length > 1m should partially be defined as well.

  //TODO Location too has a visibility, to whom am I broadcasting that I'm here.
end

def Quest
  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  // - Effectiveness rating -> In the case of effecting other items.

  //TODO Quests are also, places to spend resources on infinitely generating/speculative execution places
  //     -> If the result would be found, would that result into efficiency, or what else?

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate: Certificate?
  end
  def active = !completed
end

def Map
end

// TODO Items arranged in a particular way make another item. Something like = Hypergraph<Item> or it's a primitive item.
+def Hypergraph<Item> //TODO Hypergraph here? -> Item as Hypergraph<Item> implemented.
  def as :== Item
  end
end


//TODO Since the inventory is possibly managed by another Entity (instance), that means that it has access, and it can give others access.

// Managed inventories have some visibility/access, and thisw is one value for the manager (world), and another for the player, how to make that differentiation?
//TODO: How to indicate it is managed by the world, and synced to the player.
// Managed inventories at this location for a particular Entity.
def `entity: Entity` => 1 Inventory
// Managed inventories at this location by a particular World.
def `world: World` => 1 Inventory

// Inventories differ slightly from traditional file systems:
//   - There can be many items (files) defined at a single location. These could have additional operators defined on
//     them like AND/OR, and they could also be abstractly defined; They work just like any Type in `ray.txt`.
//   - Inventory works like directory: It defines a path. But at any path items (file) might be defined. Additionally,
//     it might host additional inventories and items like a directory. So any path is always a directory and a file.
//
// Technically every Object/Node, is *in* an Inventory.
//   - A value holds an arbitrary definition of that Type.
//   - Within it is recursively defines paths to other items (and thus inventories).
//
// When inventory is used as an Item, it is just "the path to that inventory".
//TODO Hosting you inventory is just hosting a world, which in it has locations at which the items are situated.
class Inventory
  //TODO owner = Location top-level,
  owner: Entity //TODO If everything is in an inventory, then inventory.inventory would be the entity. == path which is an entity
  //TODO Want owner to be a persistent Entity, since everything is an entity.
  //TODO path = structure on Location
  path: *[] = []
  def [path: *[]] => Inventory = this +.overwrite { .path = path }
  
  recursive = {
    def items => Item = (this -> ==.instance_of Inventory ? .items : .)[1..].reduce(&)
    def inventories => Inventory = (this -> .inventories)[1..].reduce(&)
  }
  
  // Get children of this inventory.
  //TODO .items might as well be .nodes for a World
  def items => Item
  def inventories => Inventory = items{==.instanceof Inventory}
  
  // Get the items defined at this inventory.
  def get => Item{visibility: Entity, inventory: Inventory}? // TODO These refined types should be implied.
    //TODO Load item as a .ray.txt file, with restrictions.

    //TODO Get a specific type
  
    // Many items might be stored at this location.
    item = sub() //TODO Support sub(), indicating that the method still needs to be implemented.
    item.visibility = path.map(.visibility){!= Visibility.InheritFromInventory}.last
    item.access//TODO Set access
    item.inventory &= this
    //TODO: Might have settings of certain instances to backup the player information to.
    item
  end
end

class Entity
  inventory: 1 Inventory // TODO *in* an inventory vs *has* an inventory.
  def quests => Quest = inventory{==.instanceof Quest}

  //TODO NOt this, but how to overwrite all properties which are not defined, recursively. How to get the type, and default value?
  +def def
    //TODO Adjusting def within a context should only monkeypatch it in that and children context.
    //TODO Property definition under the hood are def too?
    def `field: * => Type: * = default: *` //TODO How to differentiate default from a function body with the implementation
      //TODO Recursively how?
      super `field` => Type = inventory[field]()
      //TODO: What if inventory doesn't have that type stored.
      super `field`= value: Type
        //TODO Use .save/.delete the previous entries.
        //inventory[field] = value //TODO Should automatically implement &=, |= as well.
      end
    end
  end

  name: String.NonEmpty

  //TODO We have a world which is the memory system which is a child work of desktop, then if everything is an entity, the location is a place in that world.
  //TODO World = Inventory = Location, Location = child Inventory / subgraph/abstract description of World, child World = child Inventory
  //TODO Inventory is a refinement of World/Location. It's more strict.

  def world = location.world
  //TODO What if you only want to broadcast a particular part of your location, say the world it's in or?
  //   -> Actual location is one thing, the one broadcasted is another. Implemented as "at two locations", and one of them is chosen to be visible.
  //   -> How to indicate those two locations are supposed to represent the equivalent thing?

  //TODO Actually what you want for online, is a filter over possible worlds to interact with, and 'online' is equated to allow over internet. (what about other bluetooth things and such - included in online)
  // On top of 'visibility', an entity can be set offline instance-side: Indicating only offline communication.
  def online => boolean //TODO for a instance: set this value, for client: poll for data.

  //TODO Specific parameter types can be enforced using Entity instanceof SomeOtherEntityWithConstraints
  def `world: World`
    //TODO How to indicate that that entity ==.(some equiv graph) this.
    return this +.overwrite { // TODO Support +.overwrite as opposed to adding the results of the two to each-other. Type-checking should recognize the +.overwrite is defining at least the thing before the +.
      inventory = this.inventory[world],
      name = this.name{issued_by == world}
      location = this.location{.world == world}
    }
  end
end

def NPC < Entity
  //TODO Defines dynamics in a World
end

  //TODO: You want to be able to host a instance as an item to a world, with some visibility.

def Organization < Player
  //TODO Reserve namespace with dots to domain names.
end

//TODO So if a player has made their location known, another player can run an instance of that player in that location.
//      He might not be able to set input for that player, but it's still an instance running that player.
//      But you might want to run an instance, not the player (a specific location)
//      So streaming too, becomes running an instance.
// For strreaming, a player has a particular location which is the streaming location , that is being broadcast.
// TODO So watching a stream is simply following that location.
// So a streamer has a primary location. That location's location might be in a separate world which is the 'streaming window'.
// People watching the stream, would set their primary location, to that location.

// ==.instance_of .location Location is a type.

//TODO Some instance, which holds the 'first discovered by X' status, and issues certificates for that./
class Instance < World
  //TODO A instance is an instance, you can boot up other instances within the current instance.
  //TODO -> Child instances.
  //TODO A instance has many player instances running. (I.e. screens / separate windows)

  //TODO Instance needs a unique identifier more general than MAC, one of the names.

  //TODO Instance might be behind some nameinstance, delegating to many other instances.

  // A world might live on many entities/instances
  //TODO A player, or any entity can (co-)host worlds
  //TODO : From the perspective of this entity,
  hosting: World //TODO These worlds should come from an Item in the instance's inventory = is just (inventory as World){visibility = ??}

  //TODO How to represent that hosting and hosts in World are linked? 'hosts: Instance = Instance{hosting == this}' How is this, FOR ALL query constructed?
  //TODO How does the storage module know whether to store a reference or the whole object. It checks if the Object is stored separately and will use a reference then.
  //     -> Is there ever a time where that's not desired, say when the visibility or something is set differently for each reference of the object.
end

def @`player: String.NonEmpty` => Player = Ether.@`player`
def #`world: String.NonEmpty` => World = Ether.#`world`

def Certificate
  //TODO Want to set the visibility differently for another field in the object. How to still allow an overwrite though?
  //TODO Every field has as Item on it by default?
  //TODO Are fields stored under [World].field, or are they part of [World], and .field in world is something else. Or is it both?
  secret: Something
    visibility = //TODO Should only be default, can be overwritten
  end
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end


//TODO #World.#ChildWorld.@UserName where #ChildWorld.name.issued_by = #World
//TODO Equivalent .UI = .#Ether.UI
//TODO Equivalent: .#Ether.@UserName = .@UserName
//TODO .#world.@UserName.
//TODO; Require domain names registers on @"orbitmines.com" to be verified
// TODO; Allow circular using.
//TODO Uploadable public packages to .@name, default to using player names for this. register other organization names for this too.
// using .@"ether.orbitmines.com".UI, <TODO Version>
//TODO: If working in some folder, automatically change versioning numbers to the new ones, if the file is changed.
//TODO Should work with the versioning system somehow? another parameter here the version, which the IDE supports for automatically getting

private class Module
  static Constructor = (root: Module = Module()) => Module //TODO Constructor is parameterless, so you shouldnt need to call it with (), so just naming a variable this should work. BUt what if you would want to pass it a parameter, there's an ambiguity here.
  
  def (node: *) = ..path.reduce(acc = node, current => acc[current])

  `` = {
    def parent: Module?

    def property: *?
    def world: World?
    def player: Player?

    def path => *[] = (..parent <- this).compact.map(.world ?? .player ?? .property) //TODO This, because it's private shouldn't be overwritten? How does that work?
  }

  def `property: * & not ""` => Module
    return this if property ==<String> "."
    return this.parent ?? this if property ==<String> ".."
    return Module(..parent = this, ..property = property)
  end

  if !parent || parent..world
    def #`world: String.NonEmpty` = Module(
      ..parent = this,
      world = (parent..world ? parent..world : global.Ether).#`world`
    ) //TODO Check if not None

    def @`player: String.NonEmpty` = Module(
      ..parent = this,
      player = (parent..world ? parent..world : global.Ether).@`player`
    ) //TODO Check if not None
  end
end

def using at: Entity? = global.Ether, path: Module.Constructor
  environment = caller

  def eval inventory: Inventory
    item: Item = path(inventory)
    //TODO eval item
    //TODO Only allow certain things to be imported/changed by certain imports.
  end

  //TODO; If defined in player.inventory, define super() to call the original functionality.

  //TODO; Check if version exists on desktop if configured for remote, if it does use it.

  eval at.inventory if at // Load
  eval desktop.inventory // Load default settings
  eval player.inventory // Load player overwrites
end
