// How to populate Arrays/graphs by default

// What's the graph interpretation of an inductive type like 'def Option<T> = Some(T) | None'

// Convert Binary.String -> Binary, youd want an implicit cast, but also already have all Binary methods on Binary.String ; Like "a coerced inheritance"
// Calling a method which accepts a boolean, with the boolean type: Abstract interpretation natively supported.
//   -> The result should be refinable, "now I know it's true, so what's the result".
//   -> Partial evaluation, leads to external values being abstractly interpreted as well.
//     -> I should be able to later say, similarly, that the result is now refined to 'true', any effects caused should be reset back.
//   -> So .OR possibilities need to carry with it information of why and how to possibly change them

// Partially evaluating the boolean OR operation even when superpositions are present, should be possible if there's a single 'true' amongst them.
//   -> How do we know/use a proof that a single true is enough, to discard the superpositions.

// Does every type like 'boolean' automatically include all the methods defined on it. So boolean.nor is the superposed method, which can later be called with a new 'this' value, how is that intuitively done?  (How does on static fill generics which might be required to call methods)

// How to map over every key in an object, default map-like things defined on every context? -> How to do this while ignoring things like 'local'

// .reduce(|) TODO How does it work to pass a binary operator to a reduce which has accumulator and current as the two arguments

// node > itself or node < itself, we're in a loop (or repeated value which we're forced to see as the same, or we're not comparing using the difference we have access to - this 'number'line)

// TODO - Ambiguities
// var? vs var ? true : false ; how to know if we need to convert var to a boolean or pass it to option.
//   -> Also var ? true : false , is it var.? true : false, or var.?.true.:.false
// .extends vs a check if it does extend
  // TODO Ambiguity if we use '<', because if I check 5 < 3, it's not 5 extends 3. Is there ever any time you'd need to use extends over <?. Yes a Type Ray which extends some other Ray, so it would be Ray < Ray,
  // What even does Ray extends Ray mean, what happens to all the structure?
// args.for(args) a could mean args.for(args).a, instead of defining a block. Or something like args.for a b = 5, with the default '= 5'
// statement if expression != statement.if.expression, similarly if expression then a else b


// TODO - Notes for Examples
// Partially extending like Decimal/Decimal.Positive, Every Decimal.Positive is a Decimal, since sign is Option

def a 1 2 3 4 5
a<3: c>(1 2 4 5)
a<3: c, 5: e>(1 2 4)

(def method). <T> // Defines on the constructor.
def Array.method // Defines on Array (on static)
end

."method!@$8" // .`"a"`, method calls.

// Executing a piece of code in between each statement becomes:
// TODO: How to stop this from recursively calling itself: "Any redefinition of 'do' will use its previous implementation of 'do' within it, to prevent recursive stacks"
//   -> Different way of monkey-patching
do = def do block
  clock = some_clock_func()
  ret = super()
  time_elapsed = clock.time_elapsed()
  return ret
end

// def method(a, `a`) ; method("b", b = 5)

def Object
  list1: Array
  list2: Array
end
// Allow something like this
def Object{ list1.disjoint(list2) }
end
def Object
  list1: Array
  list2: Array
  dynamically assert list1.disjoint(list2)
end
def Object<T> args { list1.disjoint(list2) }
  list1: Array
  list2: Array
end
def Object<T> args
  list1: Array
  list2: Array
  { list1.disjoint(list2) } // TODO If a { } is evaluated, it is evaluated as a 'dynamically assert', if the definer is = this, it gets applied to that object, as opposed to Binary{.length == length}
end

// TODO - Examples + Allowances
// Allow chaining of binary operators like Array<3 < length < 5>
// Allow chaining of conditionals with .AND -> Array<length > 3><length < 5>
// Also allow Array<length > 3 | length = 3> What about this syntax: Array<length (> 3 | = 3)>
// Like this == n ? TypeA : TypeB, allow 'match' to be a type definition.
// Allow def (array: Array), to automatically accept varargs.
// Multi-methods should work for things like throw, if top-level defined doesnt accept the error, perhaps the top-level one does.
// If variable with type Option is set, it should automatically implicitly cast it to Some()
// Certain variables like 'throw' need to be accessible even in nested function which aren't defined with that variable in scope. How to type-check and generalize this concept? Is it with some keyword for a variable?

// TODO - Notes on Grammar
// x+y x+y.func = x+(y.func) you want it to be explicitly (x+y).func

// TODO - Notes on Runtime
// Take the example of Decimal.String which should be defined first, then `Decimal.String`, then Decimal. can be defined.
// Lazy evaluation, keep structures like 'false | true | true' around without deciding execution order. ; Associativity proof is somehow relevent here, how does the runtime know about it?
// Pull static out of constructor if possible.
// Dead code like a = b, a = c, 'a = b' is never used. (Unless something like history is accessed somewhere)
// Any statement is executed in a .do block, so that one can implement a debugging .do overwrite.
// This type return should automatically be deduced.
    // def posOrNegThree (s : Sign) :
           match s with | Sign.pos => Nat | Sign.neg => Int :=
         match s with
         | Sign.pos => (3 : Nat)
         | Sign.neg => (-3 : Int)
// Warning in class, if return is used: because it's not used in the 'class definition'

// TODO - Notes on Version Control
// Accessing a variable of a function (either by partially filling it), but it got renamed in a new version. Alert the user.

// TODO - Features
// Observables which check if a variable is changed, dynamically assert would make use of that.



// TODO What if a library defines Nothing, different from the one here. How to decide what is used, A newly instantiated variable or that?
// Single-line function
def Maybe a = Just a | Nothing
ef Maybe(a) = Just a | Nothing
def Maybe(a)
  return Just a | Nothing
end

//TODO Is None instanceof void?

// Array<length.max() >= 5> or default the .max() if a comparison happens, how?

// TODO: Does this assigning to false | true also change Two.first to ref on .value to the Node.

  def () // TODO Generically define this for types like boolean and others, so basically, when evaluated as a program, only then reduce query defs like (true | false) otherwise retain program structure. Probably recursively keep doing that. so call (), then result call () again etc.. until impossible.
  end

class Program // TODO: Program is like Ray, it's a function equipped with an AbstractDirectionality which is the control-flow graph
// .previous is undo the last operation, .next is program execution.
// If not used, replace 'Program' with function.


(0, 1) != [0, 1] //TODO (0, 1) is .push_back, which is relevant for types.

// what about 0..10..20 // Goes to 20 through 10, relevant for graph




// Any ray has the range operator.
0..10.for i
end
(0..10).for i
end
0..(9 + 1).for i
end
0..10.for a b
  // TODO If two arguments are passed, we step with 2 and fill both?
end

// Range operator is always binary, because we can have '0..' and '..10', and thus always same type to same type? -> That doesn't need to be the case though. Allow 'this' as a type. So this | <custom type>, not including 'this' disregards that as an option?; it's actually b = this if a = undefined.
def x: Option<this> .. y: x == None ? this : <custom, type>
end

// Allow binary operators defined outside the classes?
def x: Number .. y: Number
end

// Complicated structures like a(3, 5) is simply a[arbitrary structure]
// TODO But what if we have static things defined on the function, or fields on the function
// a(5) = 5[a] (= 5.a if a is a variable)
// a[5] = 5(a)
"x"(this) = 1 // "Get the variable called x at (arg)" -> So "x" would be "All places where the variable x is defined"
// TODO Would you ever need to access this, or is it just an interesting semantic connection?



  def <...targs>
    // TODO Dynamic namespaces, if there exists a dependency on the args execute again for the type namespace vs the untyped one.
  end


def def
  def `*`(definition: (*) => *) = external
end



def Hypergraph
end
def Graph
  extends Hypergraph<Ray<edges.next.every(.value.length <= 1)>> // This needs to be applied to every entry, not on graph
  // TODO Not Many on edges

  // Somehow extends Hypergraph and also
  // TODO The change of type to the .next change should be reflected in the effect type of: One of the many's should be dropped.
  // This type definition is somehow different? All other type definitions change the overlapping graphs defined on .vertex.
  = Vertex<
    initial = Many< End < Many<End> = vertex > >
    vertex
    terminal = initial
  >
end
def Array
  extends Graph<Ray<next.length <= 1, previous.length <= 1>> // This needs to be applied to every entry, not on graph
  // TODO Not Many on terminal
end

// Query by default

' Like this we can construct valid syntax as a simple sentence without punctuation and such


// & for every object; this.targs & targs

// When to allow {}

// TODO Variables which are not allowed to change? Often used for generics too?

// Something like Nat defines +1 func, then on type static type calling Nat.+1 => Should again return Nat, because nothing changed even if superposed

// What if we dont know T? Allow Generics.Subclass (How to fill it afterwards then?) Should this be?
   //  -> So we allow to access variables of a function without the function being fully initialized.
   //  -> How to determine what can be accessed? Statically accessible variables, but also when not depended on args.
   //  -> But we also want access to variables if we can access them at runtime. TODO

   // 0.fn(+1), 0.ray(+1): "Equip 0 with a +1 ray"
   // .ray(+1) equips .previous() with !+1 which is -1
   0.ray(+1).if(x => x < 10).for i
   0.ray(+1).if(< 10).for i
   0.ray(+1).if(10 >=).for i

   // TODO Some other syntax for .ray ?
   0 -> +1
   -1 <- 0 -> +1
   -1 | -2 <- 0 -> +1 | +2
   0 -> +1 -> +2 // What does chaining this mean?


// What does function inheritance mean, but what about additional logic in there? - called with super()?, what if multiple inheritance?


Maybe(5).switch
  Just a 1
  Nothing: 2
  [type]:
  [type like Just a if a > 10]:
  [type like Object] Object
     x = 5
     y = 10
  end
  Object(x: 5 y: 10)
  Object(x: 5 y) if y > 10
  Just 5
  Just a = 5: // Automatically bind a
  Just 5..10 =>
end
if maybe == Just a = 5..10 // a =, is a name attached to the type, == defaults to using instance_of if a type? TODO what if type == type?
end
//if Just 5..10 == maybe
// TODO: Similar to binding a variable, bind comparison as a function
(maybe == Just a = 5..10).while
   maybe = Just 5
end

// Reflection lke .methods, both on static and def.

// Inline function var = () (=> Return) = ''; var = () = '' ambiguity with a = b = c





// for nested code, use something like | at the beginning of the line instead of some block, and then always till the newline
//TODO How to pattern match the syntax if it's interleaved like that. Two separate graphs.
// TODO, How does this work for non-text contexts?
def javascript
  |.ts
  |  export namespace Query {
  |    export class Instance {
  0.ray(+1).if(< 5).for i
  |      method = () => {}         //TODO How to use variables.
  end
  |    }
  |  }
end

// Default structure is to create a Node with many rays through it.
// Need better way of connecting in sequence or branching.
def Array <T>
  -o | .
   o-
  ---
  -o
   o- | .

  -o o- --- -o o- (ls l v r rs)
  l.value = ls | .
  l.end = v
  l2.end = v
  v.initial = l
  v.terminal = r

  // Two-way connections should have some single way of assignment

  -o ]o- ]-[ -o[ o-

  o- --- -o (l v l)
  l.value = . | l
  l.end = v
  v.initial = v.terminal = l
  // How to address loops
  [l.end, v.initial | v.terminal].unrolled()

  // Symmetric to both sides
  o- --- -o
  // but
  % -T- -o =(self | .)

  def Graph
    % -T-[ -o[ =(. | ]l)
  end

  // How to do this without looking so alien

  // Symmetric if the two variables are the same?
  o-  : end
  -T- : vertex
   -o : end

  end = Nothing | end

  def Graph
    o<  : end
    >T< : vertex
     >o : end

    end = Nothing | Many end
  end

  def Tree <T> () // End the constructor with () or do or = for assignment, or => for inline function
  end
  // Is there a difference between = / =>, or shouldnt there be?
  def Tree <T> => func(T)
  def Tree <T> = Maybe a | Nothing

  // Very messy this
  def Tree <T> do
    o- | o-  : parent | initial
    -T- : vertex
     -o | < -o : terminal | leaves

    initial = Nothing
    leaves = parent
    (parent = leaves)
  end

  // Block/Program should be instanceof Graph (control-flow graph)? Use program instead of block?
  // How to empty.
  // How to allow disconnected.
  // How to consistency check.
  // How to do one-way connections
  // Where to put the loop things for .unrolled and such
  // How to make Any Array subgraph of Graph and use the same methods. Different from inheritance, like a "limiting inheritance."; .next returns a different type namely not Many<>

end

// TODO Tagging arbitrary parts of structure.
// For arrays it's simple, we just use what other languages do too.
a, b, c = 1, 2, 3
first, ..middle, last =

def Object
  def field
  end
  def field2
  end
  def field3 = [1, 2, 3]
  def field4 = Just a | Nothing
end

// Doing it with assignment
def method a: Object, b = a.field, c = a.field2
end
//
def method a: Object [ field, field2 [ nested ] ]
def method a: Object { field: Function, field2: reassigned_field { nested } } // TODO Difference between reassignment to a field vs type
  { field, field2 { nested }, field3 [a1, ..a2, a3],
    field4 = Just field4a // What if it's Nothing here, don't bind?
    // Variable binding of a nested method in a type definition.
  } = a
end
// (Tagging of name inside a comparison)
maybe == Just a = 5..10
// TODO What about complicated structures/graphs?


// TODO What about a ray definition, which is two-directional. Which is just defining what !+1 is
def bidirectional
  +1
reverse
  -1
end

bidirectional!
+!(5) = -5
+5! = -5 // What does this call, it should know the function +(5)

def + a
reverse
  -a
end


// TODO What about initial loops?
def Branching
  def test
    // Intermediate variable declarations for blocks. branch1 = ..
    branch1 = branch
      return 1
    branch2 = branch
      return 2 // TODO Allow to operate on intermediate results, while all returns are pending.
    end

    dead_code
  end

  def test2
    (branch1 = branch
      return 1
    branch2 = branch
      // no return
    branch3 = branch
      // no return
    branch4 = branch
      goto branch2 // Need some way of doing gotos, in order to represent loops. Reversing direction of something like this is relevant for what?
    end).

    after_branch_2_and_3
  end

  def test3
    this.i == 00
    i = 0

    branch
      this.i = 11
      i = 1
    branch
      this.i == 22
      i = 2
    branch
      // What is i here?
      // Either: Each branch has a separate i, or it could be any of 0, 1, 2, depending on the order.
      // What about the "this" context. this.i is?
    end
  end
end

def Function
  def compose f2
    (args) => f2(this(args))
  end
end

  def ?
    a
  :
    b
  end


//TODO Is i++ < 10 not also a program? Because that would make Expression/Program .while ambiguous, unless you define Expression as "more top-level" than Program, how would you do that?
true.while

end
(i < 10).while
end
(i++ < 10).while // TODO: Should be accessible as the original expression, and the resulting value.
end
variable.while
end






def Block
  // TODO For meta-programming things like line-number and things of blocks being defined. That way a debugger can be made very easily.
end


// TODO; How to implement try/catch with similar passing of variables for control-flow like break.





// Non-zero decimal: Decimal.Positive<!= 0>

// Might want a construction like Object, which is context which allows stuff to be set to it, but all properties like `*`=, and local etc.. aren't in there so you can still set fields like local without it effecting behavior.




def Array<length > 2>
  var = ++some_other_var // TODO: What if length changes? Is it reverted? Is there a use-case where you want it reverted?, or is it only part of the constructor
  if predicate

  end
end
def patch_it
  def global.Array<length > 2>
    // TODO Anything in the constructor here is called for every instance which currently doesnt have it? Is there are use-case where you would want it to be?
  end
end

// Multiple implementation
Array.method |= (arg1) ; name = method(name) | implementation



// dynamic asserts can carry type information of multiple objects, like A.disjoint(B). How to account for that? It's type information living in some graph above the object?
// How do compilers search for possible implementations of a function?
// What about infinite loops.
// What are function decorators?
// What about graph-like control-flow
// What about monkey-patchi vs overriding the whole variable. Monkey patch could be without args, even if the original function has them.
//      -> What is monkey-patching a function?
//      -> "patch instead of def?"
//      -> access something like super.
//      -> monkey patch delete the method instead of multimethod.

// How to differentiate return value of a function, vs returning the Instance as a Function definition.
//      -> Default return is returning "this" -> For normal functions either "this" meaning the class, skipping the local context. Or not, and use normal return semantics.
// Variables accessible at runtime how? What decides we can access it.
// Closures & inline-functions (similarly methods are closures with environment of the class)
// Defining a bidirectional ray on a class/function. Methods and properties are one-way.
// Defining boolean and other structures
// For Type definitions like data Maybe a = Just a | Nothing, what decides that Just exists, what decides that I dont need to evaluate it? Just that it doesn't exist?
// Assigning to a variable in a new block; a = 5; { a = 6 } ; Is it a new variable or assignment to the other one?
//      -> In most languages in a def block you'd be able to access it not change it. You need a thing like "this", but for 'it's already defined in an arbitrary different context'
//      -> But in something like an if block, you'd want it outside the block by default?
//      -> Or explicit local value? Would be overused for functions, so it might depend on where the def is? Might get confusing.
// Functions without args are properties. But for the case of a class, you'd want the () to be called to indicate a new instance, not ref the class: Class.a vs Class().a
//   static.def () the constructor? Or leave it out.
// <> For partial assignment of a function. Partial assignment how does that work with arbitrarily structured. Or does it only work on Array inputs.
// variable do end, like static do end, or def static like monkey-patching to get a block where "something like this" is linked to static. ; def static must be patch static? which are executed in sequence?
// static variables are also accessible as a parent context, not just static.
// which block "returns"/"break"
// Arbitrary structure named variable assignment. (& function parameter)
// instance_of in inherited structures, how does that play into the usual instance_of
// Classes/Functions with the same name, how to resolve if we cant have the unique pointers.
// What does an initial loop mean in .txt form?
// Accessing variables while function in running.
// How to know whether a.b is the .b method, or the result of a parameterless method .b?
// "Ray" within some structure: Grng,aph, which might not have .next to Many><> like an Array.
// Nested contexts accessible when a function is still executing (if those contexts define things which dont end up in the main context window)
// Return value in closure/inline-func/func
// Monkey-patch a new method, and then the library implements that method itself, in the graph variant there's a disambiguation between the two, and a possible choice of which implementation you use. But what is the text variant going to do?
// Allow a wide variety of things in the string of defs, like α/β/.. other languages. Lean allows a ' at the end of variables, to mirror math.
// Like leans open Namespace in, flatten context to 'local' local += Namespace { ...local, ...namespace }
// 1 + 1 = 2 as a type: just structure.
// match groups inside arbitrary method name
// Overloaded methods result in some joined type with .and? on methods. def method(a: A) def method(a: B) => .method = [_, _]
// a: Type = 5 ; If there are multiple meanings of what 5 is; to different type constructors, it should implicitly know which one. "Type classes" in the lean case.
//   -> Is this ever relevant for .ray.txt? Or it'll always be CustomNumberType.5 or 5u/5u16 (it having defined method for numbers). Impl some "rust-like" interface on the number 3. -> Number 3 refs a function which returns that 3, so changes to it must persist somehow. 3 < Interface
// Point<T>{ x: T, y: T } ; Implement interface "+" on any generic type which also has a "+" def Point<T < +> def + b { x: x + b.x, y: y + b.y }  end
// TODO How is Point<T < +> different from Array<length < 3>
// equivalences: Implicit casts (lean: coercions), chained together Pos -> Nat -> Int "if there is a path to Int from Pos" - allow loops. Allow cast to a function
// single line for: remove all trailing '0' from a string; .repeat_while(o => o.pop_last(), o => o.last() == '0') // But better

// private/public/protected ; local/this is private/protected (public setting of a private field shouldnt overwrite the private one? or how does that work in other languages)
//   -> Just a flag set on the edge that encodes the name of the property.
// pass continuation variables to functions, so break, continues in another function throw error too. In the throw case it need to work nested, even to funcs called/defined outside the context
// If a namespace loads all variables into the current context, what happens with a name clash? Overwrite? Or monkeypatch - certainly not.
// Array<length = 2> is not assign length to 2? If length is not within the func parameter names. What if it is and it's redefined later
// Strip contrxt of everything but certain variables, and use that context to boot another context, like the default terminal environment
// "run at compile time" ; constexpr ; when can this be inferred?
//Todo define def in the language with monkeypatching included?
//in def def define return to change control flow how?
// def `name` checks it as a type. so that regex like hour(s)? would work
// def static if it's currently drfined as a context should load everything in that to the context, or make it accept a block
// map in the same direction +1 on all
// matching a string of characters looped until some other string comes across, not the last match to that string, and everything in between is captured, the do block after a method, do should not match to other vars
// All statements are always brought in parallel, but only once evaluation is necessary does it get the order and filtered statements which need to be executed.
// Overriding something like def to check all methods being defined what if when using that, dependencies on something like class exist, throw an error? or just define class before calling the method, and then redifining it? or just not pass that to def?
// instance_of fails list of error of what isn't satisfied, this needs to be customizable. Returns something like UnmatchedType<T> with the same functionality as T but not the same restrictions
// Types of blocks are deduced based on what is in the block.
//   -> Certain things like static blocks aren't executed by the block itself, or the compiler moves things out of the block, how to account for that?
// How to grammar: Array<length > 2> and (Array<length>) 2>; Array{length > 2}<T>(args); Array[length > 2]<T>(args); Do you ever need to use array_instance[length > 2] or not? If we'd use []. Yes you could say after the fact you'd want to enforce a different type: Basically change the type signature. When is that useful?
// Like if(> 2), allow map(.property), if(.property > 2)
// Conditional Types are called dependent types in literature.
// Type equivalence is called definitional equality
// TODO Equality of objects like class require an additional field for checking the uniqueness of the object, because one otherwise doesn't have access to that. -> So some form of definitional equality is the default say Array(1, 2, 3) / Array(1, 2, 3), I cant tell the difference between the two without some object ID/memory ID.
// For the theorem prover, you might want to store a specific proof instead of only saving the tactic by which it is solved, needs some effective way of storing and referencing this; probably in a directory outside the current file
//   -> In the background run some (in)equivalence of functions algorithm to check equivalences automatically if possible.
//   -> Define things like Array<length > 2> on a variable to change the type.
// TODO Extends as a method which accesses the caller context? Can then be written on the same line as the definition
// TODO Changing a functions type parameters to allow another type. method<parameter: Type>, is that useful for anything or just 'dangerous'
// Program type of Terminating, what else?
// Define 'return' as a goto?
// def split(ar: Array<length: 5>): // Array<length < ar.length> TODO: Need to allow use of variables from parameters. What if both the property and variable are named the same?
//    -> Things like Array<ar.length === 0 ? length = 0 : length < ar.length> ; want to allow arbitrary code blocks for things like if/elseif/ what else?
// How is something like the proof that after a .push_back(A), .last = A, unless another push_back is used. How do you represent that, and how is it used by the compiler?
// Char is lean is uint32 paired with a proof that it's a valid code point, allow that too.
// def array(n: ): Array<length = n>
// Every entry is > 5 : Array<every(>5), every(<10)> = Array<every(x => 5 < x < 10)>
// allow 5 < x < 10
// Nat refers to 0..Infinity, Nat instanceof Ray. Nat instanceof Array but an instance of Nat is a number "There exists ; is just some" def even(n: ) => Nat.some(half => n == double(half)). ; TODO How does this evaluate on the infinite .some ; Nat<every> is different from Array<length> one is referring to an instance the other to the static type Nat. Or dont use Nat<every>
//   -> You'd want things like Nat{<5}; or types like def method(n: < 5) and def method(n: % 2 == 0) (nested operator still looking for a left value) and def method(n: .even) so you do want to call it on static too. What decides whether it's on instance or static
//   -> 0..Infinity{<5} = 0..Infinity.if(<5) = 0..4 = (0..Infinity(4) = 4) ; A range is an Array with a constructor ()
//   -> Have something like Array.some without parameters return a type | between each entry. def method(a: [1,2,3].some{<=2}) = def method(a: [1,2,3].if(<=2).some) = def method(a: 1 | 2)
//      -> [1,2,3].some = (1 | 2 | 3) has a constructor which accepts any of the entries like the enums. (1 | 2 | 3)(2) = 2
// Type of block/program given to the file that's being executed. ; required to terminate for example ; or specify at the top of the file.
// Terminating program which also has a type signature like () => void
// TODO ...args listens to both Object & Array, arg1, arg2 = args, and { arg1, arg2 } = args what about do arg1 arg2 end = args
// Type loop
// goto labels are also defined out of order.
// TODO What if one thing refers to something as class and another as def?
// goto label in an IDE should bring the label back one space. ; if then a type defined instead add it back.
// THe moment a "program" hits the "statement" it gets executed, so "return do end" or "a = do end" doesnt execute the block
//    -> So a function like () => abc gets executed, one with parameters does not.
// def on Program which doesnt have any parameters. Program<() => void>, Program<(String, optionalLabel: String) => String>
//   -> More generally you can change the types of methods Program<another_method => String> / Program<method(String) => String>
// Nat{>5} and those conditional typing is also called refinement
// Running arbitrary parts of the program on different machines, have some native way of supporting that. And things like eventual consistency. For adding/subtracting what else?
// Generalized range for arbitrary graphs
// def (...args) unused could be def (...)
// What about implement for any type for which some predicate holds. Say def Function being defined on any type that implements def (...)  --> def Context<(*) => *>
// Tag an arbitrary parameter to the block using &. But it's not required. (Useful when later we have arbitrary structures)
// Variable * for any shouldnt interfere with * 2 things. *2 variable or * _
// Defining a new name Function and assigning it to another type def Function = Context<(*) => *> ; as if saying def Context<(*) => *>
// (*) => * means (...args: *) => *, what if another argument is used (Array) => *, it means (..args: Array) => *, or (arg: Array) => *
//    -> Any method which accepts a single variable of type array, which is passed multiple, is allowed to be passed (a, b, c). So (Array) => * means both (...args) and (arg: Array)
// Generic types can extend like this Function<(Args = *) => Return = *> so that Function<(*) => *> can be used. Args and Return are then defined for monkeypatching, even if not defined as such.?
// A Node has a definition (which is possibly in sequence) => which is the program that generated it. And successive methods called on it for it to become what it did.
// TODO How do tests and asserts fit into theorem proving?
// Is this a new primitive operator?: "defines what 'this' is" "dependent object just like type" Variables are pointers to .history().last() ; when a normal Node reference doesn't change. A reference to the last Node is done like that.
//     -> variable = node; def actual_variable variable.history.last end; def actual_variable=(value) variable.history.push_back(value) end
//     -> What if Node defines a .history, where is the .history actually being called?
// Something implementing `*`= and `*`, goes for 'the most specified option' or does `*`(`*`=) return `*`=.
// A function is just a Node with `*` properties defined where `*` is the variable called into the same program. (*) => * or generally (), is just a single property which returns that Node. Node.() => Node[Args]. Functions have (possibly) infinite context
// Enums are inductive types
// Higher-inductive types (equiv ray?) seem really relevant to what I'm trying to do with additional structure on Node, and the defining of a type like Graph.
// How do you define a Sphere?, Torus etc? 2d grid (2d overlapping graphs vs 2-dimensional until the other side of the sphere is reached) with modular unroll?
// Which is better: Defining .property= functions, vs defining a property with the = func defined. Which means the type nil? Would have a pointer to where it was supposed to be defined, and a .= method callable on it.
// What about the Array type, but then put on the value, so it's an integer. Make that type.
// Do labels go to the initial before a node, or are they on that node.
// get method information of parameterless method some other way
// Setting the current value '= expression' local = ? Uesful when
// How to translate injecting code in inaccessible functions, like creating an alias for elsif called elseif, you need to inject code inside the elsif function.
// extends sets the caller.super to that, what if there are multiple extends and there's ambiguity in a method to which parent
// Array<length > 2 if other_property = 1>
// Is it useful to define things like Array<length > 2> on the object itself, and how?
// method names check with instance_of so method name is a type.
// Dynamic space as a type how?
// When using multiple implementations of methods, you want enumerations of possible requirements, so for boolean this could be NAND, NOR, NOT & OR, NOT & AND. etc..
// TODO Theorem proving that multiple implementations are the same, after a theorem is found -> possibly add to possible implementations
// TODO Multiple implementations but prefer the one over the other for speed, is that done automatically? deduce which one is faster for which case?
// Last value is the return value?
// Should external be allowed to implement any method? Yes.
// If a method defines =external, and offers other implementations, external is optional.
// TODO Define all boolean operators on any type for Falsity/Truthy values. TODO: How to differentiate | in a type with the | for boolean evaluation
//   -> When a boolean is evaluation and has a binary operator with a non-boolean value, you would use some implicit cast to boolean.
// TODO Use theorem-prover to automatically generate all the possible boolean implementations. How?
// Simplest reduce case: (0..9.reduce(|)) is just placing the | decorator on each of the edges. -> Probably an efficiency thing/
// Theorem proving: assert that all logic operations are available when only nand or nor is provided, or when not, and and or are provided. etc.. and all possible permutations
//  -> Are these all the minimals: nand, (not, and), nor, (not, or), (and, xnor), (or, xnor), (or, xor), (and, xor)
// Any method (like boolean arithmetic) can be overridden by external.
// The only difference between a class and a normal def is that static and this are defined.
// boolean = Two.first needs to put it on the value: .relative_context(); use operator ~ for relative context?
// spaces only work for same line, static space also works, private works also like this
// Point(x=1) x=1 shouldn't be overridden by x=0 in the constructor
// instantiations of a type using something like WaveFunctionCollapse
// Graph Type need to allow loops at every step, and then an easy way to type for not having loops
// inverse-1 notation used to go to the reverse direction of a method
// The statement of terminating is basically saying: all loops are eventually escaped from.
// Taking the 'if' definition as an example, the type that gets returned needs to be a dependent type based on 'expression', then either 'yes => Return' or 'else => Return' needs to be implied.
// TODO: Patch separate, so you dont have to call class/def separately

// Types:
// "this function has different return types, depending on the value of its argument" ; match
// "this sorting function returns a permutation of its input"


// Defined on statement means it can be used like "statement if ..." TODO (how to generally define this)
def Statement
  def if expression: Expression
    return global.if expression
      return this()
    end
  end
end
// goto .. if as defining if on goto context which has (expression?) as external. So 'end' is optional here since no block is given. This 'if' overwrites the if defined on statement, but how? -> what decides presedence
// & How to Maybe Hijack depended on the argument expression


def Integer<number> = //TODO Set value to Array<length>, but how is an instance of integer 'instanceof Integer' Integer
def `number = Decimal` = Integer(number)

// Array<Array>, Array<Array>
// args = [], []
// definition(args) | definition(arg1 arg2)