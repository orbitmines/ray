//TODO Default public.read doesn't allow access to **, but what would?

//TODO const is none.write recursively set the access-level too.

//TODO Make sure that specific entries in a # or array similarly have their visibility respected.

//TODO protected

//TODO           Note that the write permission is just a wrapper for execute, namely:
single Access
  READ = "read"
  WRITE = "write"

  // Whether Node{} is allowed to execute on local instance.
  // If it has read access, it can read the function and execute it locally for them.
  EXECUTE = "execute"
end

//TODO This should be on instance, merge instance/player/entity?
+def Entity
  // Default Privacy Policy:
  // "private" is at least used for two cases:
  //   - People who don't have access to their own local machine.
  //   - People who want a backup of ALL their data.
  //     - For backups, you can use "private" & "encrypted" if you prefer to lock backed-up data behind an encryption scheme
  //       (this of course means it cannot be recovered by a central server in case of a loss of encryption keys)
  // Note that there are exceptions to the "public" policy:
  //   - Reading/Writing to locations which are explicitly set to something other than "public" like "default_privacy_policy" -> It's set as confidential.write.
  //   - Reading/Writing to Player.instance.private (Whether an instance is considered a privately-hosted one)
  //   - Reading "local"/"private" private encryption keys.
  //   - Writing to existing "local"/"private" private&public encryption keys. (You can write to new ones though)
  // Otherwise you can use/create policies like "private" & "managed" to indicate you only want to allow access to
  // your own managed servers which have access to the player. Or more creative things like being close to a player in a world.
  confidential.write default_privacy_policy
    Access.for ACCESS = `ACCESS`: Node{} = "localhost"
  end
end

+def Node
  confidential.write access
    Access.for ACCESS = `ACCESS`: Node{} = location.parent?.access[ACCESS] ?? .default_privacy_policy[ACCESS]
  end
end

//TODO Only provide this method when accessed through location @private? *{location == @private} What if you use == like this, should it know the location that variable is in and check it?
// Confidential, means we don't want it to be public, but we defer to "default_privacy_policy" whether this should be "localhost" or "private".
modifier confidential
  def as :== Node{}
    default_policy = .default_privacy_policy[this.access_fields]

    // If default_policy is set to something like public, we instead do the most permissive, but private policy instead.
    return default_policy > "private" ? "private" & "managed" : default_policy
  end
end

modifier none
  def as :== Node{} = false
end
//const = none.write //TODO Might be confusing what in its children is considered const, so perhaps slightly change this.(If child has different permission it's not really const recursively)

// Acts as the usual programming language private/protected keyword; It is only accessible within the defined class.
modifier internal
  def as :== Node{} = Node{location.parent ==.instance_of class}{==.instance_of location.just parent.static}
  //TODO You want this to work for local contexts too, so cant rely just on class.
end

//TODO These inhereit from general "Property decorator" thing. ( How to access everything behind the property itselkf??)
//TODO Rename to access modifier. {from some context/file window modifier}
class Modifier name: *
  modifier = this
  equivalence name -> modifier

  def ()
    // TODO
  end

  access_fields = Access.values

  Access.for ACCESS = def `ACCESS` = access_fields = ACCESS

  def as :== Node{}
end

def modifier
  def `*: name` = Modifier(name)
end

