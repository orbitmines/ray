
// static parts of the constructor are filtered out using the same rewriting strategies used for compiler optimizations.

//TODO Local context doesnt override this/static how?, It's still a node.
class
  //TODO class{==.instance_of Nameable}, instance_of class

  //TODO Class is always called on static if possible from a constructor. ; If no dependence on variables.

  {name: *} (def: (Args: *): *) //TODO Allow out-of-order
    // Allow Class.name |= "Class2" to add aliases
    dynamically &definer[local.name] = local if local.name
    local.name = name

   // Ambiguity: If all methods on an instance are on the static class, what happens to () and other things which are already defined on Class? How to access them? (Single default method defined on class, which wraps the actual object fully)

    static = local

    //TODO () solves for constraints
    (args: Args)
      (protected if name == "*") .static = static
      protected this = local //TODO Allow this<World>

      def(local: this, ...args) //TODO Call-by-ref here would be the default, so that if a parameter is changed, the successive patches get that same variable.
      return this

    // Monkey-patch a constructor
    += | patch = (patch: (): *) => def &= patch

    //TODO Call constructor for static
    local
  end

  local
end

//TODO The things defined on NOde + extensions of global (use class components), dont get the global value in closures; only things defined outside Node.

class * | Node

  ; (call: (): (T: ?)): T => call<local: &caller>()

  -- (call: (: this): (T: ?)): T => call(this) ?? this //TODO ?? Should check the location of None, if it originates in caller if function, then do ??, otherwise return that None
  ~~ (call: (: this): (T: ?)): this => call(this); this

  , (b) => [this].push_back(b)

  {block: (): *} => block<local: this>() //TODO When run on static, should add to constructor

  // Allow .(property | property2) / var (condition ? == : <=)
  {"."}({expr: (: this): *}) => expr<local: this>(this)

  {" "}({expr: *}) //TODO Doesnt work for =/&=
    this &= Program(args: expr) // TODO .for i => doesnt work./
      {"=>"?, block: (): *} => this = block

  {operator: "&" | "|" = "&"}=> &= (block: (): *)
    this["{operator}="](block)

  if (predicate: boolean)
  unless (predicate: boolean)

  // Necessary for supporting: A | B : Type. The : without a space has a lower precedence than |, so A | B: Type matches to A | (B: Type).
  // A | B : Type, A | B .map, A | B {length == 3}
  {" "}{property: not "|" | "&"} => this[property]

  [] => Array<this>



  //TODO Generalize: Pattern left is matched to pattern right: first, ..middle, last; first, middle: [], last, [first ..after]
  //{
  //  field: WithAdditionalType,
  //  field2 { nested },
  //  { nested2 } = field3,
  //  field4: Some field4a,
  //  [first, ..middle, last] = field5
  //  first2, ..after = field6
  //  //[first2, ..after] = field6
  //}: ParentType = Object
  // Type = Var, assigns the different things in type that match to var to that var.

  //TODO Accepts a block function in case of @, saying setting the location
  //TODO <- all parents, -> all children of current context
  //TODO Allow @ &caller
  //TODO Allow * for all locations
  @ | location

  // {pattern} = () => doesnt do the *= operation because of the ()
  // Each = is a new branch.
  // IN Ray every mutation is a = somewhere in the structure. (So there needs to be a way to decide what counts as reassignment or not
  // If assigned, it only assigns it for the current location, thus the variables value branches for different locations. You can still access
  //    the values of other locations by changing the location, var @ func for instance.
  // Basically if parameter was passed to the function, you want this behavior
  external = | assign (x): x //TODO Might have to set # equal to x

  //TODO .not is {!=.instance_of}
  //TODO .not in  not Network.Hosts*.keys.reduce(|) //TODO What's the proper syntax for this, very verbose
  // * operator allows you to access whether a default is loaded, and whether the current value is that default value, don't store (optionally) if that''s the case.
  // If # is used in something like as:== string, it should overwrite default behavior of doing a map on that function. Like the as string in IPv6
  //TODO If # is a Ray, we have a 'selected'. #.
  // If pushed to # for the first time, it should create a new variable, leave the one alone, and only update its location to the many>?
  // Want to combine the ideas of: All in Type vs All in Database. Want to allow all in Database, but then also say choose Type to mean any type how to disambiguate?
  // TODO Always whole type, use something else for All in Database
  external # | all : Iterable<static> //TODO Is a # just an .expand? or are both ever used simultaneously?
  // +/&+ are both components but normal + overrides.
  external ## | components : Iterable<static##.reduce(|)> //TODO Does this type work?
  external ### | class_components // Class components and monkey-patches

  //TODO Exclude vs include things like local and other defined properties on Node,
  external * | methods : { {key: *}: value: Program? } + { var: ({key: *}: value: Program?) } + Iterable<[key, value: Program?]>)
  // The program which still needs to run is the dynamics defined for that object, it might set intermediate values to the object. So it's not just a single update
  external ** | program : Program
  // Force the lazy program stored in **, to evaluate.
  external {"{", filter: Expression, "}"} | (filter (filter: Expression)) : static?

  {"{", constraint: (x: static): boolean "}"} => // Allow chaining

  in {.} | keys => this*.map(key, value => key)
  values => this*.map(key, value => value())

  // Add every constructed element to a database (only actually compiled when used)
  // Configurable
  //TODO This Should be another database, and optionally only on .save?
  static $ | records: static? = None
  records |= this

  // TODO Places in code where this variable gets referenced and updated.

  | | or (x: type) => #, (| x)
  & | and (x: type) => #, (& x)

  // Monkey-patch an instance
  += | patch (patch: (): *) => patch(local: this)

  //TODO sUBTRACT/ADD TYPES
  +
  -

  &+
  &- //TODO Removes all with that type.
  |+
  |- //

  ⊢/./!⊢ // Allow if x ⊢11

  // All
  {operator: *{"{.}=" not in this && . ~= (Char.Symbol & ¬"=")[]}= (x)
    this = this[operator](x)

  //TODO Allow superpose of Ray + Ray, without interfering with eachother???
  //But you want += to override (Difference is + vs &+/&- |+/|-) ; ++ is also used for superposing Many rays into a single object. which dont interfere.
  A &+ B == A & B // except for override by B
  //Can also be nested #
  A &+ (B & C)
  Ray & Ray &+ Ray = Ray & (Ray &+ Ray)
  // Program similarly, many programs selected, but each program has many pointers to execution threads.
  //TODO All these < Ray become &+ Ray.

  //TODO How to access additional type information like A.disjoint(B)
  // Even though 'this' is already a type, we allow the binding of a less restrictive type. That way it can be reassigned to.
  type: * = static
  : | ∊ | ∈ (type) => this ~~ .type = type
  ∉ (type) => this: not type
  ∍ | ∋ (member) => member ∈ this -- this //TODO This higher precedence than : so it is executed on the type when x ∈ String ∋ x^2
  ∌ (member) => member ∉ this -- this
  // Allow 'var?: type' syntax, because certain types would have to be wrapped in parentheses otherwise.
  ?: (type) => : type?
  dynamically assert this ==.instance_of type

  > // Greater type than this, components could be together this type.


                                    // Stops when hitting None
                                    -> | →

                                    // Some(5).match
                                    //   Some a: 5
                                    //   Some a: 5..10
                                    match => //TODO Use .if, vs " "if for expression

  //Map defined on Node, so that a superposed variable works with .map and maps them all
  // What else

  //TODO What about map in place of certain Ray, allowing you to flat map in a structure.
  //TODO What if I want to .map on String (&?)+ Ray, Then Ray would take preference for .map? Or is ray only mapping the specific ones??
  //TODO Or now it would map Both direction & itself, which might also be preferred in some cases.
  map

  // TODO Fork the variable history
  ++ | copy

  .= //TODO .= next ; x = x.next

  // Alternate syntax for an Array pattern. Usually: first, middle: [], last = array
  // Allows: first, ..middle, last = array
  ..{.} => this: this.type[]

  * (n: Decimal) => this[]^n

  //TODO Sequential composition for single Node. (overriden by Iterable)
  ,

  ~{label} => this<goto label> //TODO Should automatically give the right available types.

  // instance_of and == are the same?
  namespace === // Don't ignore location
  namespace ==
    // In variables have a way to get partial equality.
    <up_to?> () =>
      in?: -> as (*)
    instance_of (type)
      // ### : Class components (can be -'ed, so can lose a type)
      // Class constraints need to all apply.
      // If type is |, find matching one. If &, force lhs to match both

      // Taking all Rays on type, they must the structure (This structural match is the same the Grammar uses)
      //   Check if Rays are === (for things like infinite numberlines we cant check otherwise
      //   New variable names are on @ * on each node of the type. So type gets assigned variables.
      //   Type(pattern) has .next as all possibilities, then as long as this matches one of the .next possibilities
      //   All properties need to have the same structure (if we've already checked in a collection ===, skip, but the properties still need to be the same)
      //     A.zip(B).every(a, b => a instanceof b) && Structure is equal: A ==.isomorphic B)

    isomorphic // (Equal in structure, ignores values)
  namespace !=
  ≧ | ≥ | >= = ==
  ≦ | ≤ | <= =
  namespace >
  namespace >=
  //TODO ~= is subgraph
  namespace ~= (expression: Expression{: initial: "^" | "⊢" ?, ?, terminal: "$" | "⊣" ?})
  !~=
  //Shortcut for ==.instance_of
  {" "}(: | ∊ | ∈) (type) => this ==.instance_of type //TODO Only if used in if-block or ? how to say that

  ?? | else

  equivalent
    as (=== Instance) => .instance
    //TODO The inverse of this,
    as (=== Character) => Character(instance: this)  // If instance is not already instance_of Character

  as (:== boolean) => true

class Option<T> < T | .None
{ None } = Option
None
  {" "}({parameters: Expression}): Function //TODO This is supposedly the function initializer
    < Function

  // If this == None, and then push, it's the first entry. So this is allowed to be None, while still these methods are available?
  // If ==.instance_of Iterable?

  //TODO If None is called as a property, this is returned, so that this.(property if X) works.

  // If Node is equipped with a Ray it is !None, if it isn't it's None. SSo == None should be false, but ==.instance_of None is true
  // If the result of something like an if block is none, it is not added to the array, it needs to be there explicitly.
    local
 // None implements location and =
 //TODO Ray. arguments = , When vertex is set to None, should set recursively the boundaries etc. as well. And extend the initial boundaries with Function.

//TODO If None !";"⊣ should return true.
  as (=== boolean) => false
  as (=== Number) => 0

//TODO .canonical as the thing which resolves equivalent forms of the same Instance for example.

unique
  //TODO either same object or assert
  //TODO unique{} accepts an expression which it maps to before checking uniqueness
  dynamically assert #.

//TODO ? is unknown so it superposes by default.
//TODO ? is location depended, it sets the value to the type it's
//TODO Default assignment is ? if not an Option which is None, does that ever cause issues when you expect a singular value?
? =>

/path //TODO + String covnersions

delegate in | out => object
delegate in Number => object

// Require that one of the superposed values is of the given type
a | an (type) => ∃Node ==.instance_of type

equivalence