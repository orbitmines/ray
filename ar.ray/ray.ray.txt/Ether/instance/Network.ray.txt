//TODO external fills things like Network.Host when spawning a child instance.


namespace Network

                    // ETHER
  DEFAULT_PORT: Port = 37839

  class IP < Location = -1 <- . -> +1
    static NUMBER_OF_SEGMENTS: Decimal.Positive
    static SEGMENT_LENGTH: Decimal.Positive
    static NUMBER_OF_BITS = NUMBER_OF_SEGMENTS * SEGMENT_LENGTH

    static +def Segment
      static Binary = Binary.Positive{length == SEGMENT_LENGTH}
    end

    static String = static as String

    def segments => Segment[]{length == NUMBER_OF_SEGMENTS}

    def as :== Binary.Positive = segments as Segment.Binary[]

    // CIDR notation
    def / prefix_length: Number{0 <= . <= NUMBER_OF_BITS} => static
      return this if prefix_length == NUMBER_OF_BITS

      binary_form = as Binary.Positive
      binary_form[prefix_length..] = 0 | 1

      binary_form
    end

    def as :== String
      // Use CIDR notation if superposed values are filled in #.
      prefix_length = NUMBER_OF_BITS - (# as Binary.Positive ~= (0 | 1)[]$ -- .length)
      if prefix_length != NUMBER_OF_BITS
        binary_form = # as Binary.Positive
        binary_form[prefix_length..] = 0
        return recur(binary_form as static), "/", prefix_length
      end

      sub
    end

    def + offset: Number{-(as Binary.Positive) <= . <= ~!(as Binary.Positive)} => static
      as Binary.Positive + offset
    end
    def - offset: Number{- ~!(as Binary.Positive) <= . <= as Binary.Positive} => static
      as Binary.Positive - offset
    end

    //TODO Range operator.

    static class v4 = segments.join(".") < IP
      static NUMBER_OF_SEGMENTS = 4
      static SEGMENT_LENGTH = 8

      static Segment = Decimal.Positive{< 2^8}
    end

    static class v6 = (left: Segment[]).join(":")?, zero_compression: "::" (? if !defined_segments.empty), (right: Segment[]).join(":")?, (":", embedded_ipv4: IPv4)? < IP
      def defined_segments => Segment[] = left, right, embedded_ipv4 as Binary.Positive

      dynamically assert defined_segments.length (zero_compression
        ? < NUMBER_OF_SEGMENTS - 1 // '-1' Because: The symbol "::" MUST NOT be used to shorten just one 16-bit 0 field. (https://datatracker.ietf.org/doc/html/rfc5952#section-4.2.2)
        : == NUMBER_OF_SEGMENTS
      )
      // When there is an alternative choice in the placement of a "::", the longest run of consecutive 16-bit 0 fields MUST be shortened (https://datatracker.ietf.org/doc/html/rfc5952#section-4.2.3)
      dynamically assert left & right ~= 0[] -- .length <= number_of_compressed_segments if zero_compression
      // When the length of the consecutive 16-bit 0 fields are equal, the first sequence of zero bits MUST be shortened. (https://datatracker.ietf.org/doc/html/rfc5952#section-4.2.3)
      dynamically assert left ~= 0[] -- .length != number_of_compressed_segments if zero_compression

      static NUMBER_OF_SEGMENTS = 8
      static SEGMENT_LENGTH = 16

      static Segment = Hexadecimal.Positive{length <= 4}

      def segments = left, 0[]{length == number_of_compressed_segments}(), right, embedded_ipv4 as Binary.Positive

      def number_of_compressed_segments = NUMBER_OF_SEGMENTS - defined_segments.length
      def compress_zeros => v6
        return this if zero_compression

        zeros = left, right ~= 0[] -- #{length == min() & leftmost} # TODO How to iterate over @ like min. and leftmost
        return this if zeros.remove.count <= 1 //TODO Or just .count, default functionality of ~= is removed from surrounding context unless X?
        //TODO What if the result of ~= is another iterable #. ("A" | "B") | ("C" | "D"), how to know that a group doesnt belong to the iterable. Probably .expand.

        return (<- zeros) "::" (zeros ->), embedded_ipv4
      end
      def embed_ipv4 => v6
        return this if embedded_ipv4

        segments[..-3], segments[-2..] as Binary.Positive as IPv4
          // Prefer compressed zeros representation when possible (at least for the leading hexadecimal part) - (https://datatracker.ietf.org/doc/html/rfc5952#section-5)
          -- .compress_zeros
      end

      def as :== String
        this
          // mixed notation is RECOMMENDED if the following condition is met: the address can be distinguished as having IPv4 addresses embedded in the lower 32 bits solely from the address field through the use of a well-known prefix (https://datatracker.ietf.org/doc/html/rfc5952#section-5)
          -- .embed_ipv4 if this ==.instance_of "::ffff:0.0.0.0/96" // TODO Do we need to this.compress_zeros here?, or should this be picked up automatically. How to distinguish between seeing if it actually starts with the string vs the converted value. BEcause it's a ~= we should allow instantiation of IP where everything from there is a superposition
          // Prefer mixed notation for NAT64 (https://datatracker.ietf.org/doc/html/rfc6052#section-2.1)
          -- .embed_ipv4 if this ==.instance_of "64:ff9b::/96"
          -- .compress_zeros
          .super
          // The characters "a", "b", "c", "d", "e", and "f" in an IPv6 address MUST be represented in lowercase. (https://datatracker.ietf.org/doc/html/rfc5952#section-4.3)
          .lowercase
      end
    end
  end
  IPv4 = IP.v4
  IPv6 = IP.v6

  Port = Decimal.Positive{< 2^16}

  class Socket
    static class Address = (ip: IPv4) | ("[",(ip: IPv6),"]"), (":", port: Port = DEFAULT_PORT)?
      protocol //TODO
    end
  end

  // Acts as a /etc/hosts
  Hosts: { `String.NonEmpty`: IP } = {
    confidential.write "localhost": "127.0.0.1" | "::1"
    //TODO external could fill these from /etc/hosts
    //TODO What about "ether".ignore_case => "ether.orbitmines.com"
  }
  dynamically Hosts.for host, ip => equivalence host -> ip

  //TODO Domainname:port castable to IP using nameservers.
end

+= Network

// Allow string CIDR notation
[IPv4, IPv6].for IP
  def String{==.instance_of (ip: IP.String) + "/" + (prefix_length: Decimal.Positive{<= IP.NUMBER_OF_BITS}.String)}
    def as :== IP = ip as IP / prefix_length
  end
end

//TODO Store history of DNS resolves, and then allow to use it if DNS doesnt resolve by checking whether the instance running match the public-key stored there.

+def Node
  static class Remote
    //TODO All object access go over network, and backup it in a local copy, what if that local copy is already defined somewhere?
    //Remote .location might not know about our copy, so how do we do remote_variable @ local
    //TODO Settings location to an instance, should say: anywhere in this instance, I don't know where. So if it's @ some_specific_location in local, it should still go to this method?
    //TODO What if the value is stored at a location, but we're looking for something which is at an unknown instance? But with particular structure?

    // If we want the local reference to a particular value, we don't consult remote.
    def @ instance: INSTANCE = instance[location]
  end
end
