// TODO Variable years/months/date
// TODO Variable epoch
// TODO Variable string representation
// TODO Variable multiple in which time sec is stored.
// TODO What different calendars are used here?
// TODO Variable relativistic trajectory

// TODO "h"/"hour" "week" "days"/"day/sol X - set epoch to 0 start of that" "years" "months" "Earth.years"/"Mars.years" (and some others for other time coordinate systems)

SI_Unit s "second"

+def Unit
  static Temporal = seconds
end
+def Quantity
  static Temporal = Quantity{unit == Unit.Temporal}
end

+def Decimal.Positive
  //TODO Should overwrite for this case. How to indicate?
  // Allow '12:00' syntax.
  def : mm: Decimal.Positive = this hours mm minutes
end
+def `(* hours)? * minutes`
  // Allow '12:00:00' syntax.
  def : ss: Decimal.Positive = this ss seconds
end

class Calendar
  static class Segment
    static def ~(convert: base ... -> last) => Calendar.Segment
      unit = caller.global.Unit ~ convert //TODO Is this the right way to change caller?
      return unit
    end

    static EPOCH: (period: @, elapsed: Node{0 <= . < period}?)? | Number = 0

    def is_recurring = this ==.instance_of Ray && this.length@.some(== Infinity)

    dynamically assert @.every(==.instance_of Quantity.Temporal)
    //SUBSEGMENTS AS MONTHS/WEEKS
  end

  static segments = static*{==.instance_of Segment}
  protected static TimeDefinition = Time{(-> .epoch).every(.calendar == calendar)}
  static def equivalence (from: TimeDefinition) -> (to: TimeDefinition{calendar == this})
    within_same_calendar_system = from.calendar.static == to.calendar.static // This allows things like UTC which are only offset differences.

    +def Time{calendar == from.calendar} //TODO How do you automatically reverse this?
      def as(:== to.calendar)
        if epoch != 0
          // Keep epoch-structure. So '25 Gregorian years' from '2001-01-01 Gregorian' is translated into 'X Julian years' from 'X Julian'.
          Time(to.calendar, epoch: epoch as to.calendar) = this (as <= Unit.Temporal if !within_same_calendar_system)
        else
          Time(to.calendar) = to + (this - from) (as <= Unit.Temporal if !within_same_calendar_system)
        end
      end
    end
  end
end

//TODO Allow : Time = 12:00 which defaults to setting day/year/month unknown, and stringify ignores it then and just returns 12:00 back
//TODO .round(seconds)
class Time < Quantity.Temporal (calendar: Calendar = UTC) //TODO ? / Calendar@ should default to all instances of Calendar
  epoch: Time{== calendar} = 0 // Only equivalent calendars can be compared
    // :Time = "2025-01-01", epoch: "2000-01-01" -> = 25.years
    +def = x
      this -= x
      super(x)
    end
  end
  dynamically assert (this -> .epoch).length != Infinite //TODO Could put this in a keyword finite-self-ref or something

  def since_calendar_epoch => Time = (this -> .epoch as calendar if .epoch != 0).sum //TODO Summing with different epochs, should start with the first, calculate properly. Can be negatives too here.

  def as(:== calendar) = this

  // &Time.YEAR = .year since epoch=0, &Time.MONTH = .month since epoch=0 -> Effect + 1 month within this context
  calendar.segments.for segment = dynamically &Time.`segment.name.snake_case.upper_case` = since_calendar_epoch.`segment.name.snake_case`

  calendar.segments.for segment
    def `segment.name.snake_case` = segment.is_recurring ? recur(epoch) : //TODO
  end

  static def NOW: Time = //TODO
  dynamically {
    // YEAR = year, MONTH = month
    .calendar.segments.for segment = `segment.name.snake_case.upper_case` = `segment.name.snake_case`
  } = NOW
end
{ NOW } = Time

//TODO Make sure superpositions are working for weeks and times
//TODO Different format orders like YYYY- etc.. Www
//TODO Extend ISO_8601 With additional things like name of timezone etc... what other extensions?
class ISO_8601 < Time{calendar ==.instance_of UTC.static}
  = (
    date: (
      year: Decimal,
      semicolons: "-"?,
      (
        month = Month@[1 - month_of_year: Decimal.Positive{length == 2}{1 <= . <= Month@.count}],
        semicolons: "-"?,
        day_of_month: Decimal.Positive{length == 2}{1 <= . <= (month ~= (days_in_month: *) days).days_in_month}
      ) | (
        day_of_year: Decimal.Positive{1 <= . <= (year as days ~= (days_in_year: *) days).days_in_year}
      ) | (
        "W",
        week_of_year: Decimal.Positive{1 <= . <= (year as weeks ~= (weeks_in_year: *) weeks).weeks_in_year}, //TODO This numbering might need to be implemented slightly differently.
        (
          "-"
          weekday: Weekday@[1 - day_of_week: Decimal.Positive{1 <= . <= Weekday@.count}]
        )?
      )
    ),
    time: (
      "T" if date || !semicolons,
      hour_of_day: Decimal.Positive{length == 2}{< calendar.HOURS_IN_DAY},
      semicolons: ":"?,
      minute_of_hour: Decimal.Positive{length == 2}{< calendar.MINUTES_IN_HOUR},
      semicolons: ":"?,
      second_of_minute: Decimal.Positive{length == 2}{< calendar.SECONDS_IN_MINUTE}, //TODO Context Time.MINUTE/or something should set this second as possible leap-second
      "Z" | offset: (
        offset_operator: "+" | "-"
        offset_hours: Decimal.Positive,
        ":",
        offset_minutes: Decimal.Positive,
      )
    )
  )
  calendar += offset_operator offset_hours:offset_minutes // enforces bounds

  dynamically assert semicolons if offset
  dynamically assert date xor time

  //TODO The Quantity should be inferred from year/month etc.. values since they're defined on Time, somehow
end