

//TODO List of methods which shouldnt be called on local, but on this if possible:
// #, * (on global, not local)

//TODO local**# => Iterate threads
//TODO How to get the current thread, Does local** have a way of getting that current value have it be a ray, but iterate over all, not just next.

//Coroutines like race say start quest which says function.stop

//TODO What about other evaluation orders, they're shuffled in the right order in this control-flow.
//TODO What if I still want them stored out of order? -> Top-level expression is out-of-order.

class Function | Program = Boundary
  //TODO as (language: Language, compiler_options: {} = {})
  //TODO Things in history where we store a copy of the cached program, and then execute from cache
  //TODO Only translate subexpressions to certain languages. Superpose languages by superposing different implementations and then something like a corotine to which one finishes first.
  //TODO Then it's run as separate executable vs run according to their control-flow implementation.
  expression: Expression

  <{filled_parameters: Expression}> => //TODO .copy, which is just another history branch

  => (def: (x?): *) => defs.push_back(def)
    //TODO When parameterless => is an override by default

  {" "}({parameters: Expression}): Function
    //TODO Default &=, default override all the locations (just override the var), so when override =, it's also assign

  //TODO Define super() for any =

  //TODO Conditional edges/gotos
  //TODO .expand on an unknown function makes the length possibly infinite, optionally assume it terminates

  //TODO Coroutine where it's a race, and one is finite which always terminates the others are not, the whole function still always terminates.

  // return_type** => The function which generates the value. Which is a subfunction of the actual function which generated it.
  // TODO: Want to allow to access the whole function which generated the change you see in the sequence of functions called on the variable.
end

left-associative
right-associative //TODO

external {label: String}\: Program

namespace goto
  (program: Program, predicate: Expression?)
    caller.push(program, ⊙: // TODO load condition on edge, or rather load it on the function boundary?)
  end

  if (predicate: Expression) => this<predicate: predicate>
end

class Expression < language.Expression
  language: Language = ".ray.txt"

  dynamically
    protected fn = as Program
    delegate (: fn.in.type) => fn

  as (:== Program) => //TODO
end

class Language
  // The datastructure the language is encoded in.
  static Expression
end

class Function | Program < Boundary, Location, expression: Expression
  //TODO How to select .next to be only for Boundary. Because expression has been given separate name?
  //TODO .hierarchy in function is, parent contexts, child contexts.

  //TODO Use expression to .expand function.

  //TODO Is intermediate state the whole context? Or what do we do with sequence of operations on some variable? How to intuitively make that sequence only about that variable? and things it depends on

  // Program State
  // - A looped control-flow, has the values of each iteration stored in the state's history.
  //   - Different instantiated branches are also different branches in the state's history.
  ∙.x: {
    context: *
    //TODO Things like &caller are in context

    //TODO Result is the last line/var of function, so it's the previous step?
    //TODO So 'in' is previous state.
    //TODO But in: should actually be the entire function context.
    result: out
  }

  external (args: in.type): return_type

  if !?⊢
    step (
      override: boolean = true // Setting override to false, spawns a new path of execution which can be stepped independently.
    )
  end

  args | arguments => first.out

  in | parameters => ∙⊣this .x
  out => ∙.x

  return_type => last.out.type

  //TODO schedule, spawn entity if necessary, if already an NPC, use that NPC quests.
  //TODO < Quest, implement .stop

  // With the assumption that each non-expandable step terminates.
  total | decidable | always_terminates | always_halts => expanded.length#.every(!= ∞)
end

namespace RayLanguage // This namespace will be used for: < Language
  namespace Txt < Language
    equivalence ".ray.txt" => this

    static class Expression < String
      //TODO Expression comes from some file or more generally a context, have that information available here.

      external comment: String

      , (b: Expression)
      -- (b: Expression)

      {" "}: (type) => //TODO Wrap whole expression in : type
    end

  end
end