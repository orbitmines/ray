// Maybe allow one to define syntax dynamically. (Would be awful for language versioning though, if I introduce something which clashes with other syntax)

//def Nothing
//end

def AMethod
  variable = 5

  def method
  end
end

// Options for generics
def Generics (T) (args)
  variable = args.5
end
def Generics T
   def constructor args
      variable = args.5
   end
end

// TODO What if a library defines Nothing, different from the one here. How to decide what is used, A newly instantiated variable or that?
// Single-line function
def Maybe a = Just a | Nothing
def Maybe(a) = Just a | Nothing
def Maybe(a)
  return Just a | Nothing
end

def Two = Array<length = 2>
// TODO Things like Array<length.max() = 2> should be allowed, or Array<length.max() >= 5> or default the .max() if a comparison happens, how? Array<length > 5>, Also want to allow use of multiple variables like Array<length > var2>
def Two = _, _ // Generic way of in-sequence def
def false = Two[0]
def true = Two[1]
def Bit = Boolean = false | true
def Boolean = Bit = false | true // TODO Allow
def BinaryString = Array<Boolean>

def boolean = false | true do
  // Allow definitions like false | true, as the program on the vertex.value.
  // Additionally define methods vertex.[]
end

def boolean = false | true
def boolean
  return false | true
end
def boolean = false | true do
  // Return of this is ignored. and set to false | true. local.value = false | true
end
def boolean
  value = false | true
  // other methods
  return value
end
def boolean = false = Two.first | true = Two.last // TODO also def false & def true
// TODO false =, is within the local context, not in the current one. So reexport is necessary.
// Difference between false: boolean (false is type boolean), and other types you might give it.
// Like rust enum & lean inductive type, allow parameters ; Is this again definable as structure on a def. => On static.
//   -> Parameter is just an expected variable

// TODO No, it's not methods defined on the class boolean with value = false | true, we want any instantiation of the type boolean
// TODO "On any instantiation" and "on the type" and on "subgraphs of the type: 1 | 2 | 3, but only 1 | 2"

// TODO Def array, ray

def Two = Array<length = 2>
// TODO: Does this assigning to false | true also change Two.first to ref on .value to the Node.
def boolean = false = Two.first | true = Two.last do
  def !
  end
  def & b
  end
  def | b // TODO: Want this top-level defined.
  end
end

def Maybe a = Just a | Nothing
def Maybe2 a = Just a | Nothing
def Maybe2 a = Just a, a | Just a | Nothing | Nothing2
// TODO Difference between the two Just's and Nothing's or not? If defined in same context, same, otherwise not?
// TODO What about enums like rust
def Enum =
  A a b
  | B c

// TODO def `METHOD_NAME`= ; Difference between method names, and possible method names like @#$. Want to allow things like @name, @`a-zA-Z0-9_.repeating`

// TODO What if you override the parameter 'local' but want to override the block's parameter local using program(local: this)
// TODO Disallow use of local in func params? would be weird, let every variable call go to local, also weird. Partially fill it by default? also weird
// TODO What's a good solution here?

// TODO Pattern matched function names? Called instance_of
// TODO Is this used for anything other than numbers? You can at least dynamically get the name.
// TODO This is probably quite useful for meta programming, so instead of defining a loop and calling def in the loop, we
// TODO    have a single instantiation. -> Or the compiler needs to be aware of that there's a dynamic method def, and don't loop through it all.
// TODO                                 -> Probably want that anyway.
def 0-9.repeating
    return Number([method name]) // TODO: How to get method name; this.name? Or is name to often used by the user this.constructor
end
def `(0..9).repeating`."(0..9).repeating" // TODO: What's a nice syntax for this
  // TODO: Or define decimal as a function on number.c
end
// 0..9.repeating = 0..(9.repeating)
// x+y x+y.func you want it to be (x+y).func
// TODO So you want to be able to use variables within a function's name.
def NUMBER.repeating // TODO How to differentiate between NUMBER.repeating (arbitrary name) and the function.
end
def NUMBER // TODO differentiate between NUMBER and variable NUMBER; aka is it an overwrite of the variable or the thing itself
end
def Generics // The pattern "generics" TODO What does this mean
end

"0..9.repeating" = 2 // Set all variables of that name to 2.

// Allow binary operators defined outside the classes?
def x: Number .. y: Number
end
Number.def ..(y)
end
Number.def .. y
end
def Number
  def .. y
  end
end

a.5
a[5]
a<5>
a(5)
// Are all these somehow the same?
a.5 a[5] are
a<5> a(5) are
// Are these two subgroups the same? (I believe I asked this question before in the Ruby writer project back in 2017)
a(5) is saying getting property 5 has some result.
// Complicated structures like a(3, 5) is simply a[arbitrary structure]
// TODO But what if we have static things defined on the function, or fields on the function
// a.property = 1
// a(5)
// you dont want a("property") to be 1.
// TODO
// a[5] is a on the vertex, and 5 being the property going through it. -> name
// a(5) is 5 on the vertex, and a being the property going through it. ->
// a(5) = 5[a] (= 5.a if a is a variable)
// a[5] = 5(a)
def Number
  def plus y
  end
end

x.plus(y) = y[x.plus]
x.rotate(y, z) = (y, z)[x.rotate]

def !
end
!x = !(x) = x[!]

y + 1 = y.+(1) = 1[y.+]
+y = plus(y) = y[plus] = y[+]

x = 1
this.x = 1
this["x"] = 1
"x"(this) = 1 // "Get the variable called x at (arg)" -> So "x" would be "All places where the variable x is defined"
// TODO Would you ever need to access this, or is it just an interesting semantic connection?


// Partially filling in arguments of a function.
def a arg1 arg2
end
const c = a(arg2: b)
c(d) // <-- uses arg1
def a 1 2 3 4 5
  // TODO How to allow variables the names of numbers, while still declaring numbers normally?
  //        -> It's just a different context, so something like global.5 is a number object.
end
a<3: c>(1 2 4 5)
a<3: c, 5: e>(1 2 4)
// TODO: What if another argument is added, then all the functions normally called, do as if they need to be called again.
//          -> Use <> ; Is this a problem, or should we use something special for partially filling a function. That's probably a better option.
a|3: c, 5: e|

// TODO LIke TypeScript, allow an arbitrary getter/setter to return a specific type, which we define without defining method bodies

// Something like a def for def. Which is just .property =
// TODO someway to say: This function is automatically added to every context. Some default object or something.
//      -> Same with =, static, this etc..
// TODO This circularly defines itself, how to support that?
def def name ...args
    [].name = args
end // TODO Maybe dont allow def like this. Complicates things like shifting around the order of func/variable definitions.
// You want something like undefined, if = is called on .undefined, it defines the property. That way we can have:
// No dont define it on undefined, just have it as default behavior
def = args
end
// a.property is now undefined
a.property = args
end
// a.property called undefined.=(args)
// which is the same as doing.
a.def property args
end

// TODO You want if without a .if to always reflect the upper-level if. Not a this.if? Generalized to?
// You want if similarly to be a function TODO Do you?
def if
end
// TODO So how does else work?
if a
else
end

def Generics (T = Default) args
   // Normal stuff here is like a static {} block
   // This is not true if args is on top like this. Need some way to allow for both.
   //   -> No not necessary, if it doesn't use args it's static.
   //   -> Similarly, .args if used anywhere in the "class", it's stored as the variable .args
   //      -> This way you also dont have these useless constructors which are only this.var = var
   //   -> Similarly, generics like .T are stored in a variable. Can it be changed? Yes?
   //   -> a<5> if a has more parameters, returns a function with one parameter filled in.
   variable = args.5

   // define subclasses
   static.Subclass <T>
   end
   static.def Subclass <T> // <-- generic overrides the context of Generics
   end
   // Allow Generics<T>.Subclass
   // What if we dont know T? Allow Generics.Subclass
   // What if T has a default and we want to match any. Use something like?? Generics<Unknown>.Subclass
   //  -> So we allow to access variables of a function without the function being fully initialized.
   //  -> How to determine what can be accessed? Statically accessible variables, but also when not depended on args.
   //  -> But we also want access to variables if we can access them at runtime. TODO

   // So stuff like this
   for a in b
     args. // uses .args so included
   end
   b.for a do
     args.
   end
   // TODO Not the for(int i) stuff like other languages but stuff like.
   // 0.add(+1) gives you a ray which has a +1 direction selected.
   // Something like a 0.next(x => x + 1), or some other way of doing this easily.
   // 0.fn(+1), 0.ray(+1): "Equip 0 with a +1 ray"
   // .ray(+1) equips .previous() with !+1 which is -1
   // TODO Allow unary functions like +1, for closures which acts as a binary with the same name x+y -> How to do that
   // TODO .if acts as a .filter
   0.ray(+1).if(x => x < 10).for i

   end
   // Which could be shortened to
   0.ray(+1).if(< 10).for i
   end
   // also allow
   0.ray(+1).if(10 >=).for i
   end
   // TODO How to differentiate < 10 from .<10 function, or how to do these arbitrary names properly

   // TODO Some other syntax for .ray ?
   0+1

   // There is the ambiguity of whether this should be saved as static or not.
   test = 6
   // Could give one the ability to reference "Generics" through a keyword "static".
   // so .static is the class.
   // Analyses would yield no dependence on previous instructions (or it will) and then we can take it out of the constructor.
   static.test = 6
   // How to get defined methods on the class if we don't know args.
   // Because you want to allow things like
   args.for a
     // What if I want to call a out of order -> Now it wouldn't work, but for a class you'd want to be able to.
     // Not in this case, but calling out of order, means the order of functions being defined must be done first.\
     // If the variable is already defined, it uses the order.
     // There might not be an order which allows you to call it? Or can we always put the method up first.
     // -> We might have a situation like


     // -> Many defs of a function, take the last one. Have some console warning for the dead code if it isn't used in between.
     a()

     // TODO: How to put this in the other context. Why isnt 'this' reassigned?
     this.def a // TODO How to use the variable here for def. -> Allow, but it overwrites the variable a in the context.
       b()
     end
     this.a =
       b()
     end
     this.a = <T> args
       b()
     end
     this.a = b

     // This .for, and = accept blocks like "end", how does this work exactly in function parameters?
     // Ruby uses &block.
     // Difference between a block accepting with a function parameter, vs an argument of that block.
     // Block is just a callable function, so it's simply the last parameter.
     args.for args a
     end
     args.for(args) a
     end
     args.for -> a
     end
     args.for do a
     end

     // If .for has no other arguments we allow
     args.for a
     end
     args.for a b = 5 // TODO How is this default separated from a variable declaration, might need something like "do"
     end
     // Differentiate a b = 5 from variable declaration, as in b = 5, not a, b = 5

     def for f: Function
     end
     def block arg f: Function
     end

   end

   def a
   end
   a =
     b()
   end

   // can keep doing generic stuff.
   def <TT> arg2
   end

   // __call__
   def (args)
   end
   // or like this
   def () args
   end
   def () <T> args
   end
   // ambiguous with .() (x y z)
   // vs.            (x, y, z)
   def a(args)
   end

   // Like haskell?
   def x + y
   end
   // or normal
   def + y
     this + y
   end
   // Allow unary construction with arbitrary special characters.
   def +
   end
   def @
   end
   // What if a thing like parenthesis is used?
   def ( x y z
   end
   result = ( x y z
   result = ((x y z)
   result = ((x, y, z)

   // g.(()
   // ambigious with
   def (()
   end
   // Arbitrary names are allowed so spaces should be possible too. This arbitrary-ness will not work well with the parser in text.
   def " "
   end
   // g. ()

   // How to decide where the "this" cutoff is, is it the whole program, is it one-level up or??
   // "this" is just a variable but where is it defined?
   this.variable
end
def Generics T args
end
// Allow <> () wherever, [] too?
def Generics <T> args
end
def Generics <T> args < Inheritance // What does function inheritance mean, just get the context, sure, but what about additional logic in there?
    super <- is it the "this" of the inherited structure, or is the return value for a function?

end
def Generics <T> args < Interface<T> // First argument already filled, so dynamically we want to allow for checking what we can define in the function without certain args.
end
// TODO Generics <T = Default> args, how to know when the first argument is the generic type?

// TODO This needs to be better, how does it fit nicely in the normal syntax of defining a class/function.
// Enums when .OR is used.
Maybe(5).switch
  Just a 1
  Nothing: 2
  [type]:
  [type like Just a if a > 10]:
  [type like Object] Object
     x = 5
     y = 10
  end
  Object(x: 5 y: 10)
  Object(x: 5 y) if y > 10
  Just 5
  Just a = 5: // Automatically bind a
  Just 5..10 =>
end
if maybe == Just a = 5..10 // a =, is a name attached to the type, == defaults to using instance_of if a type? TODO what if type == type?
end
//if Just 5..10 = maybe
//end

do
end.while()

while()

while maybe == Just a = 5..10

end

// Custom getter/setter
def Class
   _property = 5

   def property
      return _property
   end
   def property = value
     _property = value
   end
end

METHOD_NAME =
// as a getter TODO, You want it to precede other implementations, how to do that? So access to the actual implementation.
def "METHOD_NAME"
end
// and setter
def "METHOD_NAME"=
end

// TODO Maybe allow for shortening of <...targs> to just ...args,
def class name <...targs> (...args) &program
end
// TODO: If a named constructor, it's order is ignored. So it's not deemed to be a func call like normal.

def class name <...targs> (...args, &program) //TODO Program with args?
  // TODO: Name is not wrapped in quotes but is assumed to be a a-zA-Z0-9_.repeating
  // It's in front of <>, so it's like that.
  // What if:
  def class name, name2 <...targs> (...args, &program)
  end
  // TODO; Is there any reason to allow more than 1 argument there?
  -> class Name Name2 <2>(args)

  def data name (&program)

  end
  data Name = first | last
  data Name do
   first | last
  end

  def data name
  data "Name"

  def data name ()
  data Name

  // Context switching
  a = local
  do
    e = local
    // a != e
  end
  def func
    b = local  (= local.b = local)

    // b != a
    // b.constructor = func
    // b.definer = a
    // b.constructor.definer = a
  end

  func() // b.caller = a
  def func2
    c = local
    func() // b.caller = c
  end

  def func3 => func2() // b.caller = d
  def func4 = func2() // b.caller = d
  func4 = func2() // b.caller = a
  // The difference between def or not def in front of func4 is whether a new context is created for the one-line func.


  // TODO: Name is a program/type, tied to a specific context. The "name" here is tied to this conte
  // TODO: Name is the constructor's name.
  // TODO: How to differentiate this from a string "". Use ``.
  // TODO: class.methods / needs to be the same as program.methods

  // <...targs> implicit in ...args?
  def `name` (...args)
  end

  def `name` <...targs> (...args) do
    // TODO ~.[parent context]

    // TODO local is a Ray? That would mean first/last etc. are top-level as well?

    static = local.constructor
    this = local // Something different than *, you want *5 to be functions. Or differentiate it from *.5 but probably not
    // ~ is used to enter a programming context window, do I want to use it for this too? Would that cause problems?
    // Makes sense somewhere: ~ is enter existing programming context, and it represents the current context.

    // TODO Inline block =>? vs a var -declaration: a = t => t

    //TODO Allow to access any future instantiation of method. -> This is also how we differentiate it from changing a variable like 5. It's not 5, but 5() that'll be accessed.
    //TODO So we want to basically say method = method<this> ; So partially filling allows non-declared ones. This would lead to problems if someone renames a variable and all instances should be renamed, but dont throw errors because they're instantiated instead. So something different.
    program.methods.for method => method.[].this = this
    // How does this block look if for had arguments: Would like to avoid the ruby ||. for a block
    program.methods.for a b c ; method =>
    program.methods.for a b c do |method| end
    // what if we nest =>, or disallow this, too confusing syntax if it was used.
    program.methods.for a b c => method => a => b => c
    program.methods.for => method do
    end

    // These are the preferred ones right now:
    program.methods.for a b c => method => a
    // You'd want to allow for this without a parameter
    program.methods.for a b c => a
    program.methods.for(a, b, c) method =>
    program.methods.for method do // If for doesn't have parameters allow this.
    end
    program.methods.for method =>

    program~() // Should run the program within this context?
    program(local: this) //TODO: If compiler sees it can be inlined because local: is set to local. Possibly inline it.
    return this;
  end

  // 'program' gets a 'static' variable
  // Every method defined in 'program' gets assigned a 'this' variable
  // Return is an instance (instance = program)
  // TODO How to differentiate between methods and declared variables.
  def A
    property = 5

    def property_getter
    end
    def method // TODO; How to differentiate this from a property
    end
    def clearly_a_method (a)
    end
  end
end

// for nested code, use something like | at the beginning of the line instead of some block, and then always till the newline
//TODO How to pattern match the syntax if it's interleaved like that. Two separate graphs.
// TODO, How does this work for non-text contexts?
def javascript
  |.ts
  |  export namespace Query {
  |    export class Instance {
  0.ray(+1).if(< 5).for i
  |      method = () => {}         //TODO How to use variables.
  end
  |    }
  |  }
end

// Default structure is to create a Node with many rays through it.
// Need better way of connecting in sequence or branching.
def Array <T>
  -o | .
   o-
  ---
  -o
   o- | .

  -o o- --- -o o- (ls l v r rs)
  l.value = ls | .
  l.end = v
  l2.end = v
  v.initial = l
  v.terminal = r

  // Two-way connections should have some single way of assignment

  -o ]o- ]-[ -o[ o-

  o- --- -o (l v l)
  l.value = . | l
  l.end = v
  v.initial = v.terminal = l
  // How to address loops
  [l.end, v.initial | v.terminal].unrolled()

  // Symmetric to both sides
  o- --- -o
  // but
  % -T- -o =(self | .)

  def Graph
    % -T-[ -o[ =(. | ]l)
  end

  // How to do this without looking so alien

  // Symmetric if the two variables are the same?
  o-  : end
  -T- : vertex
   -o : end

  end = Nothing | end

  def Graph
    o<  : end
    >T< : vertex
     >o : end

    end = Nothing | Many end
  end

  def Tree <T> () // End the constructor with () or do or = for assignment, or => for inline function
  end
  // Is there a difference between = / =>, or shouldnt there be?
  def Tree <T> => func(T)
  def Tree <T> = Maybe a | Nothing

  // Very messy this
  def Tree <T> do
    o- | o-  : parent | initial
    -T- : vertex
     -o | < -o : terminal | leaves

    initial = Nothing
    leaves = parent
    (parent = leaves)
  end

  // Block/Program should be instanceof Graph (control-flow graph)? Use program instead of block?
  // How to empty.
  // How to allow disconnected.
  // How to consistency check.
  // How to do one-way connections
  // Where to put the loop things for .unrolled and such
  // How to make Any Array subgraph of Graph, and use the same methods. Different from inheritance, like a "limiting inheritance."

end

// TODO Tagging arbitrary parts of structure.
// For arrays it's simple, we just use what other languages do too.
a, b, c = 1, 2, 3
first, ..middle, last =

def Object
  def field
  end
  def field2
  end
  def field3 = [1, 2, 3]
  def field4 = Just a | Nothing
end

// Doing it with assignment
def method a: Object, b = a.field, c = a.field2
end
//
def method a: Object [ field, field2 [ nested ] ]
def method a: Object { field: Function, field2: reassigned_field { nested } } // TODO Difference between reassignment to a field vs type
  { field, field2 { nested }, field3 [a1, ..a2, a3],
    field4 = Just field4a // What if it's Nothing here, don't bind?
    // Variable binding of a nested method in a type definition.
  } = a
end
// (Tagging of name inside a comparison)
maybe == Just a = 5..10
// TODO What about complicated structures/graphs?


// TODO What about a ray definition, which is two-directional. Which is just defining what !+1 is
def bidirectional
  +1
reverse
  -1
end

bidirectional!
+!(5) = -5
+5! = -5 // What does this call, it should know the function +(5)

def + a
reverse
  -a
end

// TODO What about initial loops?
def Branching
  def test
    // Intermediate variable declarations for blocks. branch1 = ..
    branch1 = branch
      return 1
    branch2 = branch
      return 2 // TODO Allow to operate on intermediate results, while all returns are pending.
    end

    dead_code
  end

  def test2
    (branch1 = branch
      return 1
    branch2 = branch
      // no return
    branch3 = branch
      // no return
    branch4 = branch
      goto branch2 // Need some way of doing gotos, in order to represent loops. Reversing direction of something like this is relevant for what?
    end).

    after_branch_2_and_3
  end

  def test3
    this.i == 00
    i = 0

    branch
      this.i = 11
      i = 1
    branch
      this.i == 22
      i = 2
    branch
      // What is i here?
      // Either: Each branch has a separate i, or it could be any of 0, 1, 2, depending on the order.
      // What about the "this" context. this.i is?
    end
  end
end

def Function
  def compose f2
    (args) => f2(this(args))
  end
end

// TODO How to implement if with branching, or is it a primitive.


// TODO Implement while/do while with gotos.
def while conditional block

end
def Comparison // TODO Not just comparison, operations like += in while as well
  def while block
    check:
    if (this) goto end

    block()
    goto check:

    end:
    return
    //TODO How to call the block
  end
end
def Block
  def while comparison // Implemented on Block, it becomes a do-while loop.
    return do
      exec:
      block(break = goto break) // TODO: How is break implemented: Pass break as a variable
      check:
      if (comparison) goto exec
      break:
    end
  end
  // TODO do end.while() should return another block? That way it can be passed with that control-flow to something else

  def do
    // Build sequential blocks (default call for sequences of statements)
  end
  do = global.do

  // TODO For meta-programming things like line-number and things of blocks being defined. That way a debugger can be made very easily.
end

// TODO; How to implement try/catch with similar passing of variables for control-flow like break.

// Executing a piece of code in between each statement becomes:
// TODO: How to stop this from recursively calling itself: "Any redefinition of 'do' will use its previous implementation of 'do' within it, to prevent recursive stacks"
// TODO Before evaluating the programs, do we first look for a definition of do in anything called from top-level? Prefer as little execution as necessary to get that.
// TODO: Could use a specific keyword for this patch
Block.do = def do block
  clock = some_clock_func()
  ret = super()
  time_elapsed = clock.time_elapsed()
  return ret
end

Block.do = def do

end
end
do
  a
  b
  c
end // is the same as:
do
  do
   a
  end.do
   b
  end.do
   c
  end
end
//TODO This isnt the case with contexts like local, and defining vars
do(local: this) end.do()

do
  break (= goto break)
end.while(a)

// do end Doesn't have break defined, but do end.while(a) does.

// do end.while(a).while(b) = do end.while(a | b)
do {
  do {
    "c"
    b++
    a--
  } while (a)
while (b)

do
  exec:
  block()
  if (comparison2) goto exec
  if (comparison) goto exec
end

// .while on a function

// TODO: Need to allow an if condition bound to a variable like this?
if(a > 5).while
  a += 1
end
0.ray(+1).if(a > 5).for
end

// TODO: Similar to binding a variable, bind comparison as a function
(maybe == Just a = 5..10).while
    maybe = Just 5
end

// top-level while
while maybe == Just a = 5..10
end

// .while on a block
do

end.while()
do

while () // = Calling on .end is the same as this

// In lean the return type given here:
// def posOrNegThree (s : Sign) :
       match s with | Sign.pos => Nat | Sign.neg => Int :=
     match s with
     | Sign.pos => (3 : Nat)
     | Sign.neg => (-3 : Int)
// Is automatically deduced from the body, no need to specify it. TODO But we would still need to be able to define types like that.

// TODO Allow some sort of Sign but not Sign.pos, like Nat, but not Nat.zero, only Nat.succ (Nat.zero) at a minimum Nat<[self] != 0>

// Allow Array<length = 2><T>

def test<T>(array: Array<T>)
// also in-place
def test(array: Array<T>, array2: Array<T>, array2: Array<T2 extends number>)
//TODO Things like generic types extending other types.

Array.length =

end
def Array.length
end
//Same as monkeypatching like this
def Array
  def length
  end
end


// Arbitrary structured names
def structure = Array<length = 2> // some arbitrary structure
def `structure`
  5
  def method
  end
end
// How to "get" the `structure`.
`structure` = 6 // `structure`= is not as unambiguous as a string, it could be connected to arbitrary terminals? Or is it simply a collapsed arbitrary structure connected to the = token.
`structure`.method
//TODO Parameters which are a specific structure
def class `name_var` <T, `T`>(a, `a`, &`program`)
end
// Accept any input, need some variable set to any: `*` but shouldnt interfere with * methods

// If we expect the runtime to take the if block it would be something like:
// TODO: Any block/program which is the return value on a statement gets executed. But how?
// TODO: How is if evaluated here?
def if predicate &program
  def elsif predicate &program
    local.else = else
    local.elsif = elsif

    return local
  end
  def else &program

    return local
  end

  return local

  // block which is the type of If, which allows .elsif on it
end
if a
elsif
elsif
else
end

// TODO &program should have a sequence of blocks, or more generally a graph. How is a graph translated to .ray.txt?
def if predicate &program
  // Would need to have access to the successive blocks from &program
  // TODO What defines what type of successive blocks are here?

  // Conditional goto the best we can do?

  // program.elsif.elsif.else
end



// conditionally add at structure
if predicate
  def this.conditionally
  end
end
// TODO want to conditionally and dynamically have some method. Needs to possible reverse the definition/overwritten method if condition is no longer met

def Array
  if length > 2
    def this.atleast2
    end
  end
end
// Monkeypatching using partial properties
// This is automatically dynamic, as opposed to the if statement
def Array<length > 2>
  def atleast2
  end
end

// How do compilers search for possible implementations of a function?
// What about infinite loops.
// What are function decorators?
// What about graph-like control-flow
// What about monkey-patching, vs overriding the whole variable. Monkey patch could be without args, even if the original function has them.
//      -> What is monkey-patching a function?
//      -> "patch instead of def?"
//      -> access something like super.
// How to differentiate return value of a function, vs returning the Instance as a Function definition.
//      -> Default return is returning "this" -> For normal functions either "this" meaning the class, skipping the local context. Or not, and use normal return semantics.
// Variables accessible at runtime how? What decides we can access it.
// Closures & inline-functions (similarly methods are closures with environment of the class)
// Defining a bidirectional ray on a class/function. Methods and properties are one-way.
// Defining boolean and other structures
// For Type definitions like data Maybe a = Just a | Nothing, what decides that Just exists, what decides that I dont need to evaluate it? Just that it doesn't exist?
// Assigning to a variable in a new block; a = 5; { a = 6 } ; Is it a new variable or assignment to the other one?
//      -> In most languages in a def block you'd be able to access it not change it. You need a thing like "this", but for 'it's already defined in an arbitrary different context'
//      -> But in something like an if block, you'd want it outside the block by default?
//      -> Or explicit local value? Would be overused for functions, so it might depend on where the def is? Might get confusing.
// Functions without args are properties. But for the case of a class, you'd want the () to be called to indicate a new instance, not ref the class: Class.a vs Class().a
//   static.def () the constructor? Or leave it out.
// <> For partial assignment of a function. Partial assignment how does that work with arbitrarily structured. Or does it only work on Array inputs.
// variable do end, like static do end, or def static like monkey-patching to get a block where "something like this" is linked to static. ; def static must be patch static? which are executed in sequence?
// static variables are also accessible as a parent context, not just static.
// which block "returns"/"break"
// Arbitrary structure named variable assignment. (& function parameter)
// instance_of in inherited structures, how does that play into the usual instance_of
// Classes/Functions with the same name, how to resolve if we cant have the unique pointers.
// What does an initial loop mean in .txt form?
// Accessing variables while function in running.
// How to know whether a.b is the .b method, or the result of a parameterless method .b?
// "Ray" within some structure: Graph, which might not have .next to Many><> like an Array.
// Nested contexts accessible when a function is still executing (if those contexts define things which dont end up in the main context window)
// Return value in closure/inline-func/func
// Monkey-patch a new method, and then the library implements that method itself, in the graph variant there's a disambiguation between the two, and a possible choice of which implementation you use. But what is the text variant going to do?
// Allow a wide variety of things in the string of defs, like α/β/.. other languages. Lean allows a ' at the end of variables, to mirror math.
// Like leans open Namespace in, flatten context to 'local' local += Namespace { ...local, ...namespace }
// 1 + 1 = 2 as a type: just structure.
// match groups inside arbitrary method name
// Overloaded methods result in some joined type with .and? on methods. def method(a: A) def method(a: B) => .method = [_, _]
// a: Type = 5 ; If there are multiple meanings of what 5 is; to different type constructors, it should implicitly know which one. "Type classes" in the lean case.
//   -> Is this ever relevant for .ray.txt? Or it'll always be CustomNumberType.5 or 5u/5u16 (it having defined method for numbers). Impl some "rust-like" interface on the number 3. -> Number 3 refs a function which returns that 3, so changes to it must persist somehow. 3 < Interface
// Point<T>{ x: T, y: T } ; Implement interface "+" on any generic type which also has a "+" def Point<T < +> def + b { x: x + b.x, y: y + b.y }  end
// TODO How is Point<T < +> different from Array<length < 3>
// equivalences: Implicit casts (lean: coercions), chained together Pos -> Nat -> Int "if there is a path to Int from Pos" - allow loops. Allow cast to a function
// single line for: remove all trailing '0' from a string; .repeat_while(o => o.pop_last(), o => o.last() == '0') // But better
// try/catch implemented how?
// private/public/protected
// pass continuation variables to functions, so break, continues in another function throw error too. In the throw case it need to work nested, even to funcs called/defined outside the context
// If a namespace loads all variables into the current context, what happens with a name clash? Overwrite? Or monkeypatch - certainly not.
// Array<length = 2> is not assign length to 2? If length is not within the func parameter names. What if it is and it's redefined later
// Strip contrxt of everything but certain variables, and use that context to boot another context, like the default terminal environment
// "run at compile time" ; constexpr ; when can this be inferred?
//Todo define def in the language with monkeypatching included?
//in def def define return to change control flow how?
// def `name` checks it as a type. so that regex like hour(s)? would work
// def static if it's currently drfined as a context should load everything in that to the context, or make it accept a block
// map in the same direction +1 on all
// matching a string of characters looped until some other string comes across, not the last match to that string, and everything in between is captured, the do block after a method, do should not match to other vars




// Types:
// "this function has different return types, depending on the value of its argument" ; match
// "this sorting function returns a permutation of its input"

