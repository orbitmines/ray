class Expression = string: String
  external comment: String

  , (b: Expression)

  {" "}: (type) => //TODO Wrap whole expression in : type
end

//TODO List of methods which shouldnt be called on local, but on this if possible:
// #, * (on global, not local)

//TODO What does local.# do? iterate over all simultaneous threads of the execution?
//TODO local**# => Iterate threads
//TODO How to get the current thread, Does local** have a way of getting that current value have it be a ray, but iterate over all, not just next.
//Coroutines like race say start quest which says function.stop
//TODO Function/Program is a quest => set active means, if parameters arent filled use enumerable superpositions => Every function is of type (): *

//TODO WHat's the difference between Function and Program
//TODO Function and #.
//TODO Chain in # means function chain. So &/|, need to be in parallel by default
//TODO What about other evaluation orders, they're shuffled in the right order in this control-flow. What if I still want them stored out of order?
class Function | Program = Boundary<>
  //TODO as (language: Language, compiler_options: {} = {})
  //TODO Things in history where we store a copy of the cached program, and then execute from cache
  //TODO Only translate subexpressions to certain languages. Superpose languages by superposing different implementations and then something like a corotine to which one finishes first.
  //TODO Then it's run as separate executable vs run according to their control-flow implementation.
  expression: Expression
  //TODO .expand into subexpressions

  //TODO return_type also implements setting return_type=, by saying dynamically #.last... = return_type. Dynamically because the property is also dynamic (func)
  dynamically assert // every .next parameters == intermediate_return_type

  external (parameters: this.parameters): return_type

  <{filled_parameters: Expression}> => //TODO .copy, which is just another history branch

  => (def: (x?): *) => defs.push_back(def)
    //TODO When parameterless => is an override by default

  {" "}({parameters: Expression}): Function
    //TODO Default &=, default override all the locations (just override the var), so when override =, it's also assign

  //TODO Define super() for any =

end

class Function | Program = Boundary
  ∙.x: State
  static State
  end

  in | parameters => x
  out | intermediate_return_type => ∙⊣.x
  return_type => last.out
end