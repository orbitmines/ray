//TODO Something like is_boundary checks whether any of the entries (Many<>) are at a boundary, but that changes behavior of a superposed abstract interpretation when it shouldn't. (It should individually check is_boundary, and superpose the results)

//TODO First Ray extension defined is what gets equipped?

//TODO Graph .rewriting. dpo, spo, cartesion product, tensor product, union, disjoint union etc...

//TODO What is a .expand on a boundary/edge
//TODO Ray whose <T> isn't recursively the same type: i.e. some array like [String, Number]
// X⊣⊙⊢∙⊣⊙⊢
// ⊢∙⊣⊙⊢X
// ⊢∙⊣⊢X
// X⊣⊙
// X⊣⊢∙⊣

class Boundary < Ray
  x: static = this

  end | vertex | ∙ : Ray
  edge | ⊙ : Edge
  continuation | ⊢ : static => ⊙⊢#{!= this}

  boundary
  // ? These arent right
  is_initial => ∙⊢ == this
  is_terminal => ∙⊣ == this

  {path: (((path?, "⊙"?)?, "⊢")?, "∙")?, "⊣"}{.}
    x = this
    path.reverse.for method => x = x[method == "⊣" ? "⊢" : method]
    x
end
class Edge < Ray & (⊣ | ⊢ | ⊢{.} | list): Boundary
  x: static = this
  //TODO .value is defined on the Ray which defines the boundaries on list? Or ignore that.
end
//TODO .every on ray iterates both ways., explicit filter for excluding. (ray -> .next).for
class Ray<T?> (x | value) < AbstractDirectionality
  dynamically for(: T) if T
  //TODO .value is everything on x except the Rays defined at #. And we need distinction between methods on Ray/x

  //TODO is .expand implemented for looped types, which assume .expand unrolls the loop?

  initial | ⊢ | ⊢{.} : Boundary = Boundary(∙: this)
  terminal | ⊣ : Boundary = Boundary(∙: this)

  is_first => ⊢#.some(.boundary)
  is_last => ⊣#.some(.boundary)

  // Allow syntax for traversing the initial side: '⊢∙⊣⊙⊢var'
  {path: (((path?, "∙")?, "⊣")?, "⊙"?)?, "⊢"}{.}
    x = this
    path.reverse.for method => x = x[method]
    x

  //TODO .expand only the boundaries, or everything
  //TODO .paths possible paths to take.

  //after/before/...
  //TODO .push which does vs doesnt override a possible terminal defined there.
  push

  expanded => //TODO Recursively expand

  // TODO this.quantities~{.unit operator unit} is different from this.quantities{.unit operator unit}~, one applies the structure before/after the filter.
  //TODO But you'd kind of want to overlap the types on x/value and the ray's methods. not require a .x. What do you do if x is an Iterable?
  //TODO Or if it's a number which already has equipped structure, prefer this structure, what if I want to overlay both?
  equip_structure | ~ =>

  context | & =>
  relative_context | && => //TODO Perhaps just context, relative context = just the ray.

  //TODO Is different from unique/compact of iterable, rename
  unique => this&{== this}.count == 1 //TODO Difference in filter to say on Iterable for on each iterated node

  //TODO .remove which preserves structure, or sever connectivity, or DPO

  //TODO What to do with T for Iterable ; they shouldnt be the same here
  // The entire context graph except for the current value ; "Complement, where the entire graph is the universal set"
  complement => (this& as T){!= this# as T}

  remove // Remove selection from context

  index (start = first) => start to this -- .length - 1
end

class AbstractDirectionality<T> < Iterable<T>

  // what about 0..10..20 // Goes to 20 through 10, relevant for graph
  // ..10 / 10.. Same as 10-> / <-10
  // Somehow 5..10 when used as a type is 5..10.reduce(|) by default?
  (a: this?) .. (b: !a ? this : (> this)?) =>

  loop | orbit (boundaries: T{})

  previous =>


  static Connected // each Node is reachable from each other Node. (Going both forward and backward)
  static Consistent
  static Acyclic
end
class Iterable<T>
  next

  // Repeat this structure x times: Composing the structure x times
  * (x: Number) //TODO

  fill (value) => for x => x = value //TODO Whenever a value is accessed, lazily add this = on top. (Any for would do this)

  //TODO Sorted/max/min along which dimension & what is the default dimension
  sort (dimension: AbstractDirectionality): static{~every .previous[DIMENSION] <= .[DIMENSION] <= .next[DIMENSION]} =>
  max (dimension: AbstractDirectionality (= .0 if T < AbstractDirectionality)) => //TODO Or something like that.
  //TODO Would to to call a method on the entries, so needs to be a callable
  min () =>

  first
  last

  disjoint (b: Iterable)

// TODO If two arguments are passed, we step with 2 and fill both?
  for ()

  // TODO Structure altering mapping with ~ somehow
  map <T>(map: (x): T) => static{T: T}
  reduce ()
  //TODO Mapping and reducing together?
  reverse: static
  unordered

  pop_front
  pop_back
  push //TODO after/before/back/front

  length
  // Since a graph's structure allows for branching and looping, it can be that length != count.
  count

  empty => count == 0
  nonempty => !empty

  every (predicate: (): boolean)
  some (predicate: (): boolean)
  contains | includes (x: T)

  [] //TODO Ranges, index

  //TODO move operations

  unique | compact =>

  // Each step might be in a different version of the graph, Time vs Space
  // Start a quest to find the path
  to () => //Path to, when on array, all paths from all the points to x, equipped direction for a .min is the length of the path

  + () //TODO Object or expression + { }, or + property:, or block. & + a number to do the same as a[5]
  - () // Remove of move left x
  +- | -+ ()

  dimensionality //How to do this with different rays which can be equipped for different directions., or is it just this selected graph

  // These or not?
  intersection
  xor | symmetric_difference

  as (:== T) => T() = this.reduce(&) //TODO if T is class. Or should this use &?
end

//TODO constructors
   0 -> +1
   -1 <- 0 -> +1
   -1 | -2 <- 0 -> +1 | +2
   0 -> +1 -> +2 // Repeated two steps +1 +2 +1 +2 ..

~ (expression: Expression) // ~ 1, +2, +3, +4, combine with dynamically to dynamically allocate the others

//TODO Path implements ~= ; / ~= ^/.@ meaning files beginning with /.@
