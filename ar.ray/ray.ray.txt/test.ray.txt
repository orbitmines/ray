// Maybe allow one to define syntax dynamically. (Would be awful for language versioning though, if I introduce something which clashes with other syntax)

//def Nothing
//end

def AMethod
  variable = 5

  def method
  end
end

// Options for generics
def Generics (T) (args)
  variable = args.5
end
def Generics T
   def constructor args
      variable = args.5
   end
end

Generics = <T> (args)
end

// TODO What if a library defines Nothing, different from the one here. How to decide what is used, A newly instantiated variable or that?
// Single-line function
def Maybe a = Just a | Nothing
def Maybe(a) = Just a | Nothing
def Maybe(a)
  return Just a | Nothing
end

def Two = Array<length = 2>
// TODO Things like Array<length.max() = 2> should be allowed, or Array<length.max() >= 5> or default the .max() if a comparison happens, how? Array<length > 5>, Also want to allow use of multiple variables like Array<length > var2>
def Two = _, _ // Generic way of in-sequence def
def false = Two[0]
def true = Two[1]
def Bit = Boolean = false | true
def Boolean = Bit = false | true // TODO Allow
def BinaryString = Array<Boolean>

def boolean = false | true do
  // Allow definitions like false | true, as the program on the vertex.value.
  // Additionally define methods vertex.[]
end

def boolean = false | true
def boolean
  return false | true
end
def boolean = false | true do
  // Return of this is ignored. and set to false | true. local.value = false | true
end
def boolean
  value = false | true
  // other methods
  return value
end
def boolean = false = Two.first | true = Two.last // TODO also def false & def true
// TODO false =, is within the local context, not in the current one. So reexport is necessary.
// Difference between false: boolean (false is type boolean), and other types you might give it.
// Like rust enum & lean inductive type, allow parameters ; Is this again definable as structure on a def. => On static.
//   -> Parameter is just an expected variable

// TODO No, it's not methods defined on the class boolean with value = false | true, we want any instantiation of the type boolean
// TODO "On any instantiation" and "on the type" and on "subgraphs of the type: 1 | 2 | 3, but only 1 | 2"

// TODO Def array, ray

def Two = Array<length = 2>
// TODO: Does this assigning to false | true also change Two.first to ref on .value to the Node.
def boolean = false = Two.first | true = Two.last do
  def !
  end
  def & b
  end
  def | b // TODO: Want this top-level defined.
  end
end

def Maybe a = Just a | Nothing
def Maybe2 a = Just a | Nothing
def Maybe2 a = Just a, a | Just a | Nothing | Nothing2
// TODO Difference between the two Just's and Nothing's or not? If defined in same context, same, otherwise not?
// TODO What about enums like rust
def Enum =
  A a b
  | B c

// TODO def `METHOD_NAME`= ; Difference between method names, and possible method names like @#$. Want to allow things like @name, @`a-zA-Z0-9_.repeating`

// TODO What if you override the parameter 'local' but want to override the block's parameter local using program(local: this)
// TODO Disallow use of local in func params? would be weird, let every variable call go to local, also weird. Partially fill it by default? also weird
// TODO What's a good solution here?

// TODO Pattern matched function names? Called instance_of
// TODO Is this used for anything other than numbers? You can at least dynamically get the name.
// TODO This is probably quite useful for meta programming, so instead of defining a loop and calling def in the loop, we
// TODO    have a single instantiation. -> Or the compiler needs to be aware of that there's a dynamic method def, and don't loop through it all.
// TODO                                 -> Probably want that anyway.
def 0-9.repeating
    return Number([method name]) // TODO: How to get method name; this.name? Or is name to often used by the user this.constructor
end
def `(0..9).repeating`."(0..9).repeating" // TODO: What's a nice syntax for this
  // TODO: Or define decimal as a function on number.c
end
// 0..9.repeating = 0..(9.repeating) // TODO Not this for range operator
// x+y x+y.func you want it to be (x+y).func
// TODO So you want to be able to use variables within a function's name.
def NUMBER.repeating // TODO How to differentiate between NUMBER.repeating (arbitrary name) and the function.
end
def NUMBER // TODO differentiate between NUMBER and variable NUMBER; aka is it an overwrite of the variable or the thing itself
end
def Generics // The pattern "generics" TODO What does this mean
end

"0..9.repeating" = 2 // Set all variables of that name to 2.

0..10.for i
end
(0..10).for i
end
0..(9 + 1).for i
end
// what about 0..10..20


// Allow binary operators defined outside the classes?
def x: Number .. y: Number
end
Number.def ..(y)
end
Number.def .. y
end
def Number
  def .. y
  end
end

a.5
a[5]
a<5>
a(5)
// Are all these somehow the same?
a.5 a[5] are
a<5> a(5) are
// Are these two subgroups the same? (I believe I asked this question before in the Ruby writer project back in 2017)
a(5) is saying getting property 5 has some result.
// Complicated structures like a(3, 5) is simply a[arbitrary structure]
// TODO But what if we have static things defined on the function, or fields on the function
// a.property = 1
// a(5)
// you dont want a("property") to be 1.
// TODO
// a[5] is a on the vertex, and 5 being the property going through it. -> name
// a(5) is 5 on the vertex, and a being the property going through it. ->
// a(5) = 5[a] (= 5.a if a is a variable)
// a[5] = 5(a)
def Number
  def plus y
  end
end

x.plus(y) = y[x.plus]
x.rotate(y, z) = (y, z)[x.rotate]

def !
end
!x = !(x) = x[!]

y + 1 = y.+(1) = 1[y.+]
+y = plus(y) = y[plus] = y[+]

x = 1
this.x = 1
this["x"] = 1
"x"(this) = 1 // "Get the variable called x at (arg)" -> So "x" would be "All places where the variable x is defined"
// TODO Would you ever need to access this, or is it just an interesting semantic connection?


// Partially filling in arguments of a function.
def a arg1 arg2
end
const c = a(arg2: b)
c(d) // <-- uses arg1
def a 1 2 3 4 5
  // TODO How to allow variables the names of numbers, while still declaring numbers normally?
  //        -> It's just a different context, so something like global.5 is a number object.
end
a<3: c>(1 2 4 5)
a<3: c, 5: e>(1 2 4)
// TODO: What if another argument is added, then all the functions normally called, do as if they need to be called again.
//          -> Use <> ; Is this a problem, or should we use something special for partially filling a function. That's probably a better option.
a|3: c, 5: e|

// TODO LIke TypeScript, allow an arbitrary getter/setter to return a specific type, which we define without defining method bodies

// Something like a def for def. Which is just .property =
// TODO someway to say: This function is automatically added to every context. Some default object or something.
//      -> Same with =, static, this etc..
// TODO This circularly defines itself, how to support that?
def def name ...args
    [].name = args
end // TODO Maybe dont allow def like this. Complicates things like shifting around the order of func/variable definitions.
// You want something like undefined, if = is called on .undefined, it defines the property. That way we can have:
// No dont define it on undefined, just have it as default behavior
def = args
end
// a.property is now undefined
a.property = args
end
// a.property called undefined.=(args)
// which is the same as doing.
a.def property args
end

// TODO You want if without a .if to always reflect the upper-level if. Not a this.if? Generalized to?
// You want if similarly to be a function TODO Do you?
def if
end
// TODO So how does else work?
if a
else
end

// Different: .name is any of the generated names fitting in the type: 'name'.
// TODO Definitely have this defined outside the language.
// This method is defined, and then called by itself?
// TODO: Need to define that every object and context has this property.
def Context
end
// def Program always has def Context?

def namespace(name, &program)
  caller[name] = local
  // TODO: Unlike method definitions, you want this to be executed directly. How is that indicated?

  def <...targs>
    // TODO Dynamic namespaces, if there exists a dependency on the args execute again for the type namespace vs the untyped one.
  end

  program(local: local)

  return local
end

def def name ()
  // TODO Define def on Context.
  caller[name] = local
  local.name = name

  // TODO: Uses def again before it's defined
  def <...targs>
   // TODO Method to partially fill arguments
  end
  def (...args, &program) // Separate <> and () complete
    //TODO Typecheck args vs args2, targs vs targs2
    //TODO: args might contain a &program block too, typecheck that to &program2
    //TODO -> Typechecking a code block -> Specific kind of control-flow/program. So you could say: Only code blocks which aren't turing complete.
    //        This is actually a really important feature.

    // TODO If already exists monkeypatching.
    caller[name] = <...targs>(...args2, &program2)
      program(args2, &program2)
    end
    // TODO __call__ method

    // TODO: Only when the body and such is given, is caller[name] set?
    // It's not directly executed, but stored as a Definition: return program<...targs>(...args)
  end

  return local
end
// A constructor is this + local.constructor is set to `method`.
def def
  def `method`
     ...
  end
end

def method(arg, arg, &program)
end
// is actually a program which accepts arg, arg, &program as params

// out of order block def
def if(predicate, &program)
def some_other_method(&program)

def a
  return abc if true
  return eee some_other_method
  // TODO Differentiate between eee('some_other_method')
end

// not this
def class name <...targs> (...args, &program)
  static = local.constructor
  this = local

  program(local: this)

  return this
end

def Hypergraph
end
def Graph
  extends Hypergraph<Ray<edges.next.every(.value.length <= 1)>> // This needs to be applied to every entry, not on graph
  // TODO Not Many on edges

  // Somehow extends Hypergraph and also
  // TODO The change of type to the .next change should be reflected in the effect type of: One of the many's should be dropped.
  // This type definition is somehow different? All other type definitions change the overlapping graphs defined on .vertex.
  = Vertex<
    initial = Many< End < Many<End> = vertex > >
    vertex
    terminal = initial
  >
end
def Array
  extends Graph<Ray<next.length <= 1, previous.length <= 1>> // This needs to be applied to every entry, not on graph
  // TODO Not Many on terminal
end

def query(name?, &definition)

end

query Ray

end

def class name <...targs> (...args, &program)
// is actually
def class (name, &program)
// which accepts <...targs> (...args)
def class(name?, &definition) // : Terminating, is a limiting inheritance on Program.
  caller[name] = local if name //TODO Out of order if generalized to out-of-order block definition
  static = local

  def <...targs>
    // TODO copy(targs = targs)
  end
  def (...args, &program)
    this = local

    // TODO Typechecking definition.targs with targs etc.. needs to be defined for 'def' as well.
    definition<...targs>(local: this, ...args, &program)

    return this
  end

  return static
end

def method(arg1, arg2, &program)
end
method(arg1, arg2) <T>(arg3)
end

// TODO There's an ambiguity between method(arg1)<T> defining a block, or calling the <..t> method.
// Resolve this ambiguity by saying if () are used at the start it call the <> method. So:
class(arg1)<T>() // calls <T>, arg1 is a variable reference
class arg1<T>() // defines Block, arg1 is a name
end
class arg1 // TODO Ambiguity whether its a variable reference or a name.
class()

for i
end
// =
for() <>(i)
end

def method(arg1, &program)
end
method arg1 <T>(arg2)
end
class arg1<T>(arg2)
end
// Constructors can have multiple arguments
class arg1, arg2 <T>(arg3)
end

//TODO Defining the = method
//TODO Circularity in caller[name] = local and this one.
def `any`= <...targs>(...args, &program)
  caller.def `local.constructor.name` <...targs>(...args, &program)
  // TODO Does caller.def change the 'caller' in def? Saying that . is a shortcut for def caller def `..` which it is.
end
abc = '' // caller = local
abc.eee = '' // caller = local
// Might want to differentiate between caller of the method and this "called on"
def abc
  eee = '' // In this case it would be "caller = abc"
end

// What about
def `any`= <...targs>
  caller.def `local.constructor.name`
end


def abc <...targs> (...args, &program) // Program B
  // Program A
end
def def name
  def <...targs> (...args, &program) // Program A
  end
end

def AnotherObject
  def <...targs> (...args, &program)
  end
end

instance = AnotherObject()
instance<targs>(args)

end

// Creating a method
def method <...targs> (...args, &program)
// Is actually
def('method')<...targs>(...args, &program)

// Creating a constructor
def class name <...targs> (...args, &program)
// Is actually

def class
  def `method`
    def <...targs>
    end
    def <...targs>(...args, &program)

    end

    return local
  end
end
class()[name]<...targs>(...args, &program)

// So def is
def def name ()
end
// Which is
def def
  def `method`
    ...
  end
end
def()[name]<...targs>(...args, &program)

class AnotherObject
  def `method`
  end
end

AnotherObject()[method]
AnotherObject method <T> (5) do
end

def method
end

AnotherObject method nestedConstructor <T>(5)
AnotherObject method <T>(5) anotherNestedConstructor <5>()
end

myCustomConstructor = AnotherObject method <T>(5)
myCustomConstructor a <5>(method)
end

AnotherObject method
// is short for
AnotherObject().method

def method
def().method

def AnotherObject
  def `method`
    def <...targs>
    end
    def (...args)
      def `method`
        def <...targs>
        end
      end

      return local
    end
  end
end

' Like this we can construct valid syntax as a simple sentence without punctuation and such
Like().this().we().can().construct().valid().syntax().as().a().simple().sentence().without().punctuation().and().such()

def Point
  def x = 0
  def y = 0
end

Point x
(Point x) == 0
Point(1, 2) x  = Point(1, 2)().x

def Constructor

end

(def method). <T> // Defines on the constructor.
def Array.method // Defines on Array (on static)
end
// TODO How to define on an Array instance which isn't def Array def method
// def (Array).method // Defines on Array
//

// TODO What is Array<length > 3><length < 5> --> is it AND, yes it is. Array<3 < length < 5>, Array<length > 3, length < 5>
// TODO Also allow Array<length > 3 | length = 3> What about this syntax: Array<length (> 3 | = 3)>

class Constructor name targs: Program = []
  def <...targs>: Constructor
    return Constructor(name, this.targs & targs)
  end
  def (...args, &program)
    return program(...(this.targs + args)) //TODO This is not it: targs could be conditions on this.
  end
end
def Block
  def (...args)
    // TODO; How is the block called, where in the variable &program is the actual program stored? Or this just another primitive

  end
end

def class name
  def
end

// TODO: "Defining a constructor"
// TODO: Using a name <...targs> (...args) uses .def under the hood for that .name

def Generics (T = Default) args
   // Normal stuff here is like a static {} block
   // This is not true if args is on top like this. Need some way to allow for both.
   //   -> No not necessary, if it doesn't use args it's static.
   //   -> Similarly, .args if used anywhere in the "class", it's stored as the variable .args
   //      -> This way you also dont have these useless constructors which are only this.var = var
   //   -> Similarly, generics like .T are stored in a variable. Can it be changed? Yes?
   //   -> a<5> if a has more parameters, returns a function with one parameter filled in.
   variable = args.5

   // define subclasses
   static.Subclass <T>
   end
   static.def Subclass <T> // <-- generic overrides the context of Generics
   end
   // Allow Generics<T>.Subclass
   // What if we dont know T? Allow Generics.Subclass
   // What if T has a default and we want to match any. Use something like?? Generics<Unknown>.Subclass
   //  -> So we allow to access variables of a function without the function being fully initialized.
   //  -> How to determine what can be accessed? Statically accessible variables, but also when not depended on args.
   //  -> But we also want access to variables if we can access them at runtime. TODO

   // So stuff like this
   for a in b
     args. // uses .args so included
   end
   b.for a do
     args.
   end
   // TODO Not the for(int i) stuff like other languages but stuff like.
   // 0.add(+1) gives you a ray which has a +1 direction selected.
   // Something like a 0.next(x => x + 1), or some other way of doing this easily.
   // 0.fn(+1), 0.ray(+1): "Equip 0 with a +1 ray"
   // .ray(+1) equips .previous() with !+1 which is -1
   // TODO Allow unary functions like +1, for closures which acts as a binary with the same name x+y -> How to do that
   // TODO .if acts as a .filter
   0.ray(+1).if(x => x < 10).for i

   end
   // Which could be shortened to
   0.ray(+1).if(< 10).for i
   end
   // also allow
   0.ray(+1).if(10 >=).for i
   end
   // TODO How to differentiate < 10 from .<10 function, or how to do these arbitrary names properly

   // TODO Some other syntax for .ray ?
   0+1

   // There is the ambiguity of whether this should be saved as static or not.
   test = 6
   // Could give one the ability to reference "Generics" through a keyword "static".
   // so .static is the class.
   // Analyses would yield no dependence on previous instructions (or it will) and then we can take it out of the constructor.
   static.test = 6
   // How to get defined methods on the class if we don't know args.
   // Because you want to allow things like
   args.for a
     // What if I want to call a out of order -> Now it wouldn't work, but for a class you'd want to be able to.
     // Not in this case, but calling out of order, means the order of functions being defined must be done first.\
     // If the variable is already defined, it uses the order.
     // There might not be an order which allows you to call it? Or can we always put the method up first.
     // -> We might have a situation like


     // -> Many defs of a function, take the last one. Have some console warning for the dead code if it isn't used in between.
     a()

     // TODO: How to put this in the other context. Why isnt 'this' reassigned?
     this.def a // TODO How to use the variable here for def. -> Allow, but it overwrites the variable a in the context.
       b()
     end
     this.a =
       b()
     end
     this.a = <T> args
       b()
     end
     this.a = b

     // This .for, and = accept blocks like "end", how does this work exactly in function parameters?
     // Ruby uses &block.
     // Difference between a block accepting with a function parameter, vs an argument of that block.
     // Block is just a callable function, so it's simply the last parameter.
     args.for args a
     end
     args.for(args) a
     end
     args.for -> a
     end
     args.for do a
     end

     // If .for has no other arguments we allow
     args.for a
     end
     args.for a b = 5 // TODO How is this default separated from a variable declaration, might need something like "do"
     end
     // Differentiate a b = 5 from variable declaration, as in b = 5, not a, b = 5

     def for f: Function
     end
     def block arg f: Function
     end

   end

   def a
   end
   a =
     b()
   end

   // can keep doing generic stuff.
   def <TT> arg2
   end

   // __call__
   def (args)
   end
   // or like this
   def () args
   end
   def () <T> args
   end
   // ambiguous with .() (x y z)
   // vs.            (x, y, z)
   def a(args)
   end

   // Like haskell?
   def x + y
   end
   // or normal
   def + y
     this + y
   end
   // Allow unary construction with arbitrary special characters.
   def +
   end
   def @
   end
   // What if a thing like parenthesis is used?
   def ( x y z
   end
   result = ( x y z
   result = ((x y z)
   result = ((x, y, z)

   // g.(()
   // ambigious with
   def (()
   end
   // Arbitrary names are allowed so spaces should be possible too. This arbitrary-ness will not work well with the parser in text.
   def " "
   end
   // g. ()

   // How to decide where the "this" cutoff is, is it the whole program, is it one-level up or??
   // "this" is just a variable but where is it defined?
   this.variable
end
def Generics T args
end
// Allow <> () wherever, [] too?
def Generics <T> args
end
def Generics <T> args < Inheritance // What does function inheritance mean, just get the context, sure, but what about additional logic in there?
    super <- is it the "this" of the inherited structure, or is the return value for a function?

end
def Generics <T> args < Interface<T> // First argument already filled, so dynamically we want to allow for checking what we can define in the function without certain args.
end
// TODO Generics <T = Default> args, how to know when the first argument is the generic type?

// TODO This needs to be better, how does it fit nicely in the normal syntax of defining a class/function.
// Enums when .OR is used.
Maybe(5).switch
  Just a 1
  Nothing: 2
  [type]:
  [type like Just a if a > 10]:
  [type like Object] Object
     x = 5
     y = 10
  end
  Object(x: 5 y: 10)
  Object(x: 5 y) if y > 10
  Just 5
  Just a = 5: // Automatically bind a
  Just 5..10 =>
end
if maybe == Just a = 5..10 // a =, is a name attached to the type, == defaults to using instance_of if a type? TODO what if type == type?
end
//if Just 5..10 = maybe
//end


// Custom getter/setter
def Class
   _property = 5

   def property
      return _property
   end
   def property = value
     _property = value
   end
end

METHOD_NAME =
// as a getter TODO, You want it to precede other implementations, how to do that? So access to the actual implementation.
def "METHOD_NAME"
end
// and setter
def "METHOD_NAME"=
end

// TODO Maybe allow for shortening of <...targs> to just ...args,
def class name <...targs> (...args) &program
end
// TODO: If a named constructor, it's order is ignored. So it's not deemed to be a func call like normal.

def class name <...targs> (...args, &program) //TODO Program with args?

  def data name (&program)

  end
  data Name = first | last
  data Name do
   first | last
  end

  def data name
  data "Name"

  def data name ()
  data Name

  // Context switching
  a = local
  do
    e = local
    // a != e
  end
  def func
    b = local  (= local.b = local)

    // b != a
    // b.constructor = func
    // b.definer = a
    // b.constructor.definer = a
  end

  func() // b.caller = a
  def func2
    c = local
    func() // b.caller = c
  end

  def func3 => func2() // b.caller = d
  def func4 = func2() // b.caller = d
  func4 = func2() // b.caller = a
  // The difference between def or not def in front of func4 is whether a new context is created for the one-line func.


  // TODO: Name is a program/type, tied to a specific context. The "name" here is tied to this conte
  // TODO: Name is the constructor's name.
  // TODO: How to differentiate this from a string "". Use ``.
  // TODO: class.methods / needs to be the same as program.methods

  // <...targs> implicit in ...args?
  def `name` (...args)
  end

  def `name` <...targs> (...args) do
    // TODO ~.[parent context]

    // TODO local is a Ray? That would mean first/last etc. are top-level as well?

    static = local.constructor
    this = local // Something different than *, you want *5 to be functions. Or differentiate it from *.5 but probably not
    // ~ is used to enter a programming context window, do I want to use it for this too? Would that cause problems?
    // Makes sense somewhere: ~ is enter existing programming context, and it represents the current context.

    // TODO Inline block =>? vs a var -declaration: a = t => t

    //TODO Allow to access any future instantiation of method. -> This is also how we differentiate it from changing a variable like 5. It's not 5, but 5() that'll be accessed.
    //TODO So we want to basically say method = method<this> ; So partially filling allows non-declared ones. This would lead to problems if someone renames a variable and all instances should be renamed, but dont throw errors because they're instantiated instead. So something different.
    program.methods.for method => method.[].this = this
    // How does this block look if for had arguments: Would like to avoid the ruby ||. for a block
    program.methods.for a b c ; method =>
    program.methods.for a b c do |method| end
    // what if we nest =>, or disallow this, too confusing syntax if it was used.
    program.methods.for a b c => method => a => b => c
    program.methods.for => method do
    end

    // These are the preferred ones right now:
    program.methods.for a b c => method => a
    // You'd want to allow for this without a parameter
    program.methods.for a b c => a
    program.methods.for(a, b, c) method =>
    program.methods.for method do // If for doesn't have parameters allow this.
    end
    program.methods.for method =>

    program~() // Should run the program within this context?
    program(local: this) //TODO: If compiler sees it can be inlined because local: is set to local. Possibly inline it.
    return this;
  end

  // 'program' gets a 'static' variable
  // Every method defined in 'program' gets assigned a 'this' variable
  // Return is an instance (instance = program)
  // TODO How to differentiate between methods and declared variables.
  def A
    property = 5

    def property_getter
    end
    def method // TODO; How to differentiate this from a property
    end
    def clearly_a_method (a)
    end
  end
end

// for nested code, use something like | at the beginning of the line instead of some block, and then always till the newline
//TODO How to pattern match the syntax if it's interleaved like that. Two separate graphs.
// TODO, How does this work for non-text contexts?
def javascript
  |.ts
  |  export namespace Query {
  |    export class Instance {
  0.ray(+1).if(< 5).for i
  |      method = () => {}         //TODO How to use variables.
  end
  |    }
  |  }
end

// Default structure is to create a Node with many rays through it.
// Need better way of connecting in sequence or branching.
def Array <T>
  -o | .
   o-
  ---
  -o
   o- | .

  -o o- --- -o o- (ls l v r rs)
  l.value = ls | .
  l.end = v
  l2.end = v
  v.initial = l
  v.terminal = r

  // Two-way connections should have some single way of assignment

  -o ]o- ]-[ -o[ o-

  o- --- -o (l v l)
  l.value = . | l
  l.end = v
  v.initial = v.terminal = l
  // How to address loops
  [l.end, v.initial | v.terminal].unrolled()

  // Symmetric to both sides
  o- --- -o
  // but
  % -T- -o =(self | .)

  def Graph
    % -T-[ -o[ =(. | ]l)
  end

  // How to do this without looking so alien

  // Symmetric if the two variables are the same?
  o-  : end
  -T- : vertex
   -o : end

  end = Nothing | end

  def Graph
    o<  : end
    >T< : vertex
     >o : end

    end = Nothing | Many end
  end

  def Tree <T> () // End the constructor with () or do or = for assignment, or => for inline function
  end
  // Is there a difference between = / =>, or shouldnt there be?
  def Tree <T> => func(T)
  def Tree <T> = Maybe a | Nothing

  // Very messy this
  def Tree <T> do
    o- | o-  : parent | initial
    -T- : vertex
     -o | < -o : terminal | leaves

    initial = Nothing
    leaves = parent
    (parent = leaves)
  end

  // Block/Program should be instanceof Graph (control-flow graph)? Use program instead of block?
  // How to empty.
  // How to allow disconnected.
  // How to consistency check.
  // How to do one-way connections
  // Where to put the loop things for .unrolled and such
  // How to make Any Array subgraph of Graph and use the same methods. Different from inheritance, like a "limiting inheritance."; .next returns a different type namely not Many<>

end

// TODO Tagging arbitrary parts of structure.
// For arrays it's simple, we just use what other languages do too.
a, b, c = 1, 2, 3
first, ..middle, last =

def Object
  def field
  end
  def field2
  end
  def field3 = [1, 2, 3]
  def field4 = Just a | Nothing
end

// Doing it with assignment
def method a: Object, b = a.field, c = a.field2
end
//
def method a: Object [ field, field2 [ nested ] ]
def method a: Object { field: Function, field2: reassigned_field { nested } } // TODO Difference between reassignment to a field vs type
  { field, field2 { nested }, field3 [a1, ..a2, a3],
    field4 = Just field4a // What if it's Nothing here, don't bind?
    // Variable binding of a nested method in a type definition.
  } = a
end
// (Tagging of name inside a comparison)
maybe == Just a = 5..10
// TODO What about complicated structures/graphs?


// TODO What about a ray definition, which is two-directional. Which is just defining what !+1 is
def bidirectional
  +1
reverse
  -1
end

bidirectional!
+!(5) = -5
+5! = -5 // What does this call, it should know the function +(5)

def + a
reverse
  -a
end

// TODO What about initial loops?
def Branching
  def test
    // Intermediate variable declarations for blocks. branch1 = ..
    branch1 = branch
      return 1
    branch2 = branch
      return 2 // TODO Allow to operate on intermediate results, while all returns are pending.
    end

    dead_code
  end

  def test2
    (branch1 = branch
      return 1
    branch2 = branch
      // no return
    branch3 = branch
      // no return
    branch4 = branch
      goto branch2 // Need some way of doing gotos, in order to represent loops. Reversing direction of something like this is relevant for what?
    end).

    after_branch_2_and_3
  end

  def test3
    this.i == 00
    i = 0

    branch
      this.i = 11
      i = 1
    branch
      this.i == 22
      i = 2
    branch
      // What is i here?
      // Either: Each branch has a separate i, or it could be any of 0, 1, 2, depending on the order.
      // What about the "this" context. this.i is?
    end
  end
end

def Function
  def compose f2
    (args) => f2(this(args))
  end
end

statement if expression
statement.if(expression)


if expression then a else b
// Ambiguity between the function if(expression, then, a, else, b) and if(expression) then

if(expression).then(a).else(b)
expression ? a : b
expression.?(a).:(b)
def Expression
  def ?
    a
  :
    b
  end
end

def Statement
  // Defined on statement means it can be used like "statement if ..."
  def if expression: Expression
  end
end

def if
  def then
  def elsif

  def else
end

// TODO How to implement if with branching, or is it a primitive.


// TODO Implement while/do while with gotos.

//TODO Is i++ < 10 not also a program? Because that would make Expression/Program .while ambiguous, unless you define Expression as "more top-level" than Program, how would you do that?
true.while

end
(i < 10).while
end
(i++ < 10).while // TODO: Should be accessible as the original expression, and the resulting value.
end
variable.while
end

do
end.while()

while()

while maybe == Just a = 5..10

end

do
  break (= goto break)
end.while(a)

// do end Doesn't have break defined, but do end.while(a) does.

// do end.while(a).while(b) = do end.while(a | b)
do {
  do {
    "c"
    b++
    a--
  } while (a)
while (b)

do
  exec:
  block()
  if (comparison2) goto exec
  if (comparison) goto exec
end

// .while on a function

// TODO: Need to allow an if condition bound to a variable like this?
if(a > 5).while
  a += 1
end
0.ray(+1).if(a > 5).for
end

// TODO: Similar to binding a variable, bind comparison as a function
(maybe == Just a = 5..10).while
    maybe = Just 5
end

// top-level while
while maybe == Just a = 5..10
end

// .while on a block
do

end.while()
do

while () // = Calling on .end is the same as this

while (a)

end.while(b)
do {
  while(a)
} while(b)

do a, b, c
end.while(c) // doesnt automatically get called, and while should return the same program parameters as a,b,c

def Block
  def do
    // Build sequential blocks (default call for sequences of statements)
  end
  do = global.do

  // TODO For meta-programming things like line-number and things of blocks being defined. That way a debugger can be made very easily.
end

// TODO; How to implement try/catch with similar passing of variables for control-flow like break.

// Executing a piece of code in between each statement becomes:
// TODO: How to stop this from recursively calling itself: "Any redefinition of 'do' will use its previous implementation of 'do' within it, to prevent recursive stacks"
// TODO Before evaluating the programs, do we first look for a definition of do in anything called from top-level? Prefer as little execution as necessary to get that.
// TODO: Could use a specific keyword for this patch
Block.do = def do block
  clock = some_clock_func()
  ret = super()
  time_elapsed = clock.time_elapsed()
  return ret
end

Block.do = def do

end
end
do
  a
  b
  c
end // is the same as:
do
  do
   a
  end.do
   b
  end.do
   c
  end
end
//TODO This isnt the case with contexts like local, and defining vars
do(local: this) end.do()

// In lean the return type given here:
// def posOrNegThree (s : Sign) :
       match s with | Sign.pos => Nat | Sign.neg => Int :=
     match s with
     | Sign.pos => (3 : Nat)
     | Sign.neg => (-3 : Int)
// Is automatically deduced from the body, no need to specify it. TODO But we would still need to be able to define types like that.

// TODO Allow some sort of Sign but not Sign.pos, like Nat, but not Nat.zero, only Nat.succ (Nat.zero) at a minimum Nat<[self] != 0>

// Allow Array<length = 2><T>

def test<T>(array: Array<T>)
// also in-place
def test(array: Array<T>, array2: Array<T>, array2: Array<T2 extends number>)
//TODO Things like generic types extending other types.

Array.length =

end
def Array.length
end
//Same as monkeypatching like this
def Array
  def length
  end
end


// Arbitrary structured names
def structure = Array<length = 2> // some arbitrary structure
def `structure`
  5
  def method
  end
end
// How to "get" the `structure`.
`structure` = 6 // `structure`= is not as unambiguous as a string, it could be connected to arbitrary terminals? Or is it simply a collapsed arbitrary structure connected to the = token.
`structure`.method
//TODO Parameters which are a specific structure
def class `name_var` <T, `T`>(a, `a`, &`program`)
end
// Accept any input, need some variable set to any: `*` but shouldnt interfere with * methods

// If we expect the runtime to take the if block it would be something like:
// TODO: Any block/program which is the return value on a statement gets executed. But how?
// TODO: How is if evaluated here?
def if predicate &program
  def elsif predicate &program
    local.else = else
    local.elsif = elsif

    return local
  end
  def else &program

    return local
  end

  return local

  // block which is the type of If, which allows .elsif on it
end
if a
elsif
elsif
else
end

// TODO &program should have a sequence of blocks, or more generally a graph. How is a graph translated to .ray.txt?
def if predicate &program
  // Would need to have access to the successive blocks from &program
  // TODO What defines what type of successive blocks are here?

  // Conditional goto the best we can do?

  // program.elsif.elsif.else
end



// conditionally add at structure
if predicate
  def this.conditionally
  end
end
// TODO want to conditionally and dynamically have some method. Needs to possible reverse the definition/overwritten method if condition is no longer met

def Array
  if length > 2
    def this.atleast2
    end
  end
end
// Monkeypatching using partial properties
// This is automatically dynamic, as opposed to the if statement
def Array<length > 2>
  def atleast2
  end
end

def Object
  list1: Array
  list2: Array
end
// Allow something like this
Object<list1.disjoint(list2)>
// TODO How to define it directly on Object
def Object //TODO What is Object has <T> ; Object<list1.some(>5)> should not set T to that. So change it to {} or something?
  list1: Array
  list2: Array
  assert list1.disjoint(list2)
end
Object<list1.some(>5)>
// TODO How to also do this for enums

// How do compilers search for possible implementations of a function?
// What about infinite loops.
// What are function decorators?
// What about graph-like control-flow
// What about monkey-patching, vs overriding the whole variable. Monkey patch could be without args, even if the original function has them.
//      -> What is monkey-patching a function?
//      -> "patch instead of def?"
//      -> access something like super.
// How to differentiate return value of a function, vs returning the Instance as a Function definition.
//      -> Default return is returning "this" -> For normal functions either "this" meaning the class, skipping the local context. Or not, and use normal return semantics.
// Variables accessible at runtime how? What decides we can access it.
// Closures & inline-functions (similarly methods are closures with environment of the class)
// Defining a bidirectional ray on a class/function. Methods and properties are one-way.
// Defining boolean and other structures
// For Type definitions like data Maybe a = Just a | Nothing, what decides that Just exists, what decides that I dont need to evaluate it? Just that it doesn't exist?
// Assigning to a variable in a new block; a = 5; { a = 6 } ; Is it a new variable or assignment to the other one?
//      -> In most languages in a def block you'd be able to access it not change it. You need a thing like "this", but for 'it's already defined in an arbitrary different context'
//      -> But in something like an if block, you'd want it outside the block by default?
//      -> Or explicit local value? Would be overused for functions, so it might depend on where the def is? Might get confusing.
// Functions without args are properties. But for the case of a class, you'd want the () to be called to indicate a new instance, not ref the class: Class.a vs Class().a
//   static.def () the constructor? Or leave it out.
// <> For partial assignment of a function. Partial assignment how does that work with arbitrarily structured. Or does it only work on Array inputs.
// variable do end, like static do end, or def static like monkey-patching to get a block where "something like this" is linked to static. ; def static must be patch static? which are executed in sequence?
// static variables are also accessible as a parent context, not just static.
// which block "returns"/"break"
// Arbitrary structure named variable assignment. (& function parameter)
// instance_of in inherited structures, how does that play into the usual instance_of
// Classes/Functions with the same name, how to resolve if we cant have the unique pointers.
// What does an initial loop mean in .txt form?
// Accessing variables while function in running.
// How to know whether a.b is the .b method, or the result of a parameterless method .b?
// "Ray" within some structure: Graph, which might not have .next to Many><> like an Array.
// Nested contexts accessible when a function is still executing (if those contexts define things which dont end up in the main context window)
// Return value in closure/inline-func/func
// Monkey-patch a new method, and then the library implements that method itself, in the graph variant there's a disambiguation between the two, and a possible choice of which implementation you use. But what is the text variant going to do?
// Allow a wide variety of things in the string of defs, like α/β/.. other languages. Lean allows a ' at the end of variables, to mirror math.
// Like leans open Namespace in, flatten context to 'local' local += Namespace { ...local, ...namespace }
// 1 + 1 = 2 as a type: just structure.
// match groups inside arbitrary method name
// Overloaded methods result in some joined type with .and? on methods. def method(a: A) def method(a: B) => .method = [_, _]
// a: Type = 5 ; If there are multiple meanings of what 5 is; to different type constructors, it should implicitly know which one. "Type classes" in the lean case.
//   -> Is this ever relevant for .ray.txt? Or it'll always be CustomNumberType.5 or 5u/5u16 (it having defined method for numbers). Impl some "rust-like" interface on the number 3. -> Number 3 refs a function which returns that 3, so changes to it must persist somehow. 3 < Interface
// Point<T>{ x: T, y: T } ; Implement interface "+" on any generic type which also has a "+" def Point<T < +> def + b { x: x + b.x, y: y + b.y }  end
// TODO How is Point<T < +> different from Array<length < 3>
// equivalences: Implicit casts (lean: coercions), chained together Pos -> Nat -> Int "if there is a path to Int from Pos" - allow loops. Allow cast to a function
// single line for: remove all trailing '0' from a string; .repeat_while(o => o.pop_last(), o => o.last() == '0') // But better
// try/catch implemented how?
// private/public/protected ; local/this is private/protected (public setting of a private field shouldnt overwrite the private one? or how does that work in other languages)
// pass continuation variables to functions, so break, continues in another function throw error too. In the throw case it need to work nested, even to funcs called/defined outside the context
// If a namespace loads all variables into the current context, what happens with a name clash? Overwrite? Or monkeypatch - certainly not.
// Array<length = 2> is not assign length to 2? If length is not within the func parameter names. What if it is and it's redefined later
// Strip contrxt of everything but certain variables, and use that context to boot another context, like the default terminal environment
// "run at compile time" ; constexpr ; when can this be inferred?
//Todo define def in the language with monkeypatching included?
//in def def define return to change control flow how?
// def `name` checks it as a type. so that regex like hour(s)? would work
// def static if it's currently drfined as a context should load everything in that to the context, or make it accept a block
// map in the same direction +1 on all
// matching a string of characters looped until some other string comes across, not the last match to that string, and everything in between is captured, the do block after a method, do should not match to other vars
// All statements are always brought in parallel, but only once evaluation is necessary does it get the order and filtered statements which need to be executed.
// Overriding something like def to check all methods being defined what if when using that, dependencies on something like class exist, throw an error? or just define class before calling the method, and then redifining it? or just not pass that to def?
// instance_of fails list of error of what isn't satisfied, this needs to be customizable. Returns something like UnmatchedType<T> with the same functionality as T but not the same restrictions
// Types of blocks are deduced based on what is in the block.
//   -> Certain things like static blocks aren't executed by the block itself, or the compiler moves things out of the block, how to account for that?
// How to grammar: Array<length > 2> and (Array<length>) 2>; Array{length > 2}<T>(args); Array[length > 2]<T>(args); Do you ever need to use array_instance[length > 2] or not? If we'd use []. Yes you could say after the fact you'd want to enforce a different type: Basically change the type signature. When is that useful?
// Like if(> 2), allow map(.property), if(.property > 2)
// Conditional Types are called dependent types in literature.
// Type equivalence is called definitional equality
// TODO Equality of objects like class require an additional field for checking the uniqueness of the object, because one otherwise doesn't have access to that. -> So some form of definitional equality is the default say Array(1, 2, 3) / Array(1, 2, 3), I cant tell the difference between the two without some object ID/memory ID.
// For the theorem prover, you might want to store a specific proof instead of only saving the tactic by which it is solved, needs some effective way of storing and referencing this; probably in a directory outside the current file
//   -> In the background run some (in)equivalence of functions algorithm to check equivalences automatically if possible.
//   -> Define things like Array<length > 2> on a variable to change the type.
// TODO Extends as a method which accesses the caller context? Can then be written on the same line as the definition
// TODO Changing a functions type parameters to allow another type. method<parameter: Type>, is that useful for anything or just 'dangerous'
// Program type of Terminating, what else?
// Define 'return' as a goto?
// def split(ar: Array<length: 5>): // Array<length < ar.length> TODO: Need to allow use of variables from parameters. What if both the property and variable are named the same?
//    -> Things like Array<ar.length === 0 ? length = 0 : length < ar.length> ; want to allow arbitrary code blocks for things like if/elseif/ what else?
// How is something like the proof that after a .push_back(A), .last = A, unless another push_back is used. How do you represent that, and how is it used by the compiler?
// Char is lean is uint32 paired with a proof that it's a valid code point, allow that too.
// def array(n: ): Array<length = n>
// Every entry is > 5 : Array<every(>5), every(<10)> = Array<every(x => 5 < x < 10)>
// allow 5 < x < 10
// Nat refers to 0..Infinity, Nat instanceof Ray. Nat instanceof Array but an instance of Nat is a number "There exists ; is just some" def even(n: ) => Nat.some(half => n == double(half)). ; TODO How does this evaluate on the infinite .some ; Nat<every> is different from Array<length> one is referring to an instance the other to the static type Nat. Or dont use Nat<every>
//   -> You'd want things like Nat{<5}; or types like def method(n: < 5) and def method(n: % 2 == 0) (nested operator still looking for a left value) and def method(n: .even) so you do want to call it on static too. What decides whether it's on instance or static
//   -> 0..Infinity{<5} = 0..Infinity.if(<5) = 0..4 = (0..Infinity(4) = 4) ; A range is an Array with a constructor ()
//   -> Have something like Array.some without parameters return a type | between each entry. def method(a: [1,2,3].some{<=2}) = def method(a: [1,2,3].if(<=2).some) = def method(a: 1 | 2)
//      -> [1,2,3].some = (1 | 2 | 3) has a constructor which accepts any of the entries like the enums. (1 | 2 | 3)(2) = 2
// Type of block/program given to the file that's being executed. ; required to terminate for example ; or specify at the top of the file.
// Terminating program which also has a type signature like () => void
// TODO ...args listens to both Object & Array, arg1, arg2 = args, and { arg1, arg2 } = args what about do arg1 arg2 end = args
// Type loop
// goto labels are also defined out of order.
// TODO What if one thing refers to something as class and another as def?
// goto label in an IDE should bring the label back one space.
// THe moment a "program" hits the "statement" it gets executed, so "return do end" or "a = do end" doesnt execute the block
//    -> So a function like () => abc gets executed, one with parameters does not.
// def on Program which doesnt have any parameters. Program<() => void>, Program<(String, optionalLabel: String) => String>
//   -> More generally you can change the types of methods Program<another_method => String> / Program<method(String) => String>
// Nat{>5} and those conditional typing is also called refinement
// Running arbitrary parts of the program on different machines, have some native way of supporting that. And things like eventual consistency. For adding/subtracting what else?
// Generalized range for arbitrary graphs
// def (...args) unused could be def (...)
// What about implement for any type for which some predicate holds. Say def Function being defined on any type that implements def (...)  --> def Context<(*) => *>
// Tag an arbitrary parameter to the block using &. But it's not required. (Useful when later we have arbitrary structures)
// Variable * for any shouldnt interfere with * 2 things. *2 variable or * _
// Defining a new name Function and assigning it to another type def Function = Context<(*) => *> ; as if saying def Context<(*) => *>
// (*) => * means (...args: *) => *, what if another argument is used (Array) => *, it means (..args: Array) => *, or (arg: Array) => *
//    -> Any method which accepts a single variable of type array, which is passed multiple, is allowed to be passed (a, b, c). So (Array) => * means both (...args) and (arg: Array)
// Generic types can extend like this Function<(Args = *) => Return = *> so that Function<(*) => *> can be used. Args and Return are then defined for monkeypatching, even if not defined as such.?
// A Node has a definition (which is possibly in sequence) => which is the program that generated it. And successive methods called on it for it to become what it did.
// TODO How do tests and asserts fit into theorem proving?
// Variables are pointers to .history().last() ; when a normal Node reference doesn't change. A reference to the last Node is done like that.
// Something implementing `*`= and `*`, goes for 'the most specified option' or does `*`(`*`=) return `*`=.

// Types:
// "this function has different return types, depending on the value of its argument" ; match
// "this sorting function returns a permutation of its input"

