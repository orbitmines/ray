//TODO Translations to GLSL - Can those be inferred from the structure defined on the types? (Like https://iquilezles.org/articles/distfunctions/) Exact vs approximation equivalances how?

//TODO Edges are decorated with length.
//elementary_length <>

Point = Ray

class Path | Curve | Line = Array.Unbounded
  static Straight = //"No curvature" is a bit ambiguous //TODO Makes assumption about local space
end

//TODO Unbounded/vs bounded loop
Loop = Array.Unbounded.loop(boundaries: false)

class Circle
  outline: Loop{every(to centre -- #.min.length).reduce(==)}

  centre: Point
  radius: outline to centre -- #.min.length

  //TODO Things like approximate circles or discrete circles where not every.reduce(==)
  //TODO Circle with surface selected.

  def diameter = radius * 2 //TODO Should make radius require * 2, should automatically implement radius = diameter / 2
  //etc..
end
//TODO Things like volume, for the arbitrary space discrete vs infinite (needs to be evenly spaced out too when not having discrete effects)

Square //TODO Makes assumption about the local space.
Plane // Square with no boundaries.

// Finite vs Infinite
// dimensionality = 2 & dimensionality change at every point is constant.
// every x goes to an x, every y goes to a y
Grid // TODO `x`D Grid, X x X Grid, (Allow Expression syntax to extent a whole statement like Number x/* Number)
//TODO Euclidian space being a grid with infinite divisibility.
//TODO Effective dimension vs actual dimension at each point.

//TODO Use Grid in torus/cylinder definition
Cylinder
Torus


Sphere //TODO How to say 2D Loop
Cube
COne


// In the current group (hierarchy wise) or the entire "under" ignoring hierarchy
->> means everthing to the right (<-ray).all

class Object < Hierarchy
  boundary: Boundary
  border: // object on the boundary (inclusive)

//todo easilty add remove properties like center so dynamically .center if predicate, but compact
  Center<D =
    & .x if ==.instance_of 1D
    & .y if ==.instance_of 2D
    & .z if ==.instance_of 3D
  > = static{(<-D).length == (D->).length}
  //Todo how to not so verbosely do this, rhis syntax doesn't currently work

  //Todo .under etc. needs to go to the boundary of this abstract object

  // dimensionality


class 1D < Ray
  left: static <<- horizontal | x => this ->> right: static
class 2D < 1D
  under: static <<- down: static <- vertical | y -> up: static ->> above: static
class 3D < 2D
  behind: static <<- backward: static <- depth | z -> forward: static ->> in_front: static





