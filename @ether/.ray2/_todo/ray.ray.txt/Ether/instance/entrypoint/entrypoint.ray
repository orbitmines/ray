// Set up the /instance folder.
// By default 'root', uses the same settings as any instance spawned by it.
// The two configurations can be split, by writing to /instance and / separately.
IO /instance %= /
IO /instance/entrypoint/entrypoint.`*` %= None

//TODO Shadows should work so that the central ether server knows which version is used and can in turn shadow it also. If customized, upload the custom changes

//TODO Also allow many simultaneous servers running besides the player.
//TODO Allow players who initially spawned the NPC to configure who has access.

//TODO Get /instance configuration from the player who is spawning the entity.

// Holds history of which entities logged in
localhost npcs: NPC?
localhost player: Player?

return spawn(player) if player

//TODO Generate new instance keypair for this new player

//TODO Pass login (other or new player)/logout/swap_user to Player entrypoint
children.execute def login
  //TODO Login is different than spawning an instance with it. -> Login just means add to registry
end
children.execute def logout
end
children.execute def swap
end


uuid = UUID.v1()

//TODO Default behavior of shadow, is if it's written to by another thing than INSTANCE, A new file is created for INSTANCE instead.
//TODO Shadow should use the versioned file of /, and if a change is commited that should be placed there, it's also applied on the shadowed item.
IO /.ether/@`uuid` %= /instance // TODO Shadow all the files in /instance
spawn(
  name: confidential.read none.write uuid
  IO./: host /@`uuid`
  //TODO You could make a case for saying an entity could spawn with a different OS after virtual machines are supported. With a default Ether instance installed if the OS is not Ether.
  //TODO For now, let root decide whether child instances have access to the host's OS. Defaulting to it having access.
  OS:
  Entity.spawn = login //TODO
)
