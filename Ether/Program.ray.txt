class Expression = string: String
  external comment: String

  , (b: Expression)

  {" "}: (type) => //TODO Wrap whole expression in : type
end

//TODO List of methods which shouldnt be called on local, but on this if possible:
// #, * (on global, not local)

//TODO What does local.# do? iterate over all simultaneous threads of the execution?
//TODO local**# => Iterate threads
//TODO How to get the current thread, Does local** have a way of getting that current value have it be a ray, but iterate over all, not just next.
//Coroutines like race say start quest which says function.stop
//TODO Function/Program is a quest => set active means, if parameters arent filled use enumerable superpositions => Every function is of type (): *

//TODO WHat's the difference between Function and Program
//TODO Function and #.
//TODO Chain in # means function chain. So &/|, need to be in parallel by default
//TODO What about other evaluation orders, they're shuffled in the right order in this control-flow. What if I still want them stored out of order?
class Function | Program = Boundary<>
  //TODO as (language: Language, compiler_options: {} = {})
  //TODO Things in history where we store a copy of the cached program, and then execute from cache
  //TODO Only translate subexpressions to certain languages. Superpose languages by superposing different implementations and then something like a corotine to which one finishes first.
  //TODO Then it's run as separate executable vs run according to their control-flow implementation.
  expression: Expression
  //TODO .expand into subexpressions

  //TODO return_type also implements setting return_type=, by saying dynamically #.last... = return_type. Dynamically because the property is also dynamic (func)
  dynamically assert // every .next parameters == intermediate_return_type

  external (parameters: this.parameters): return_type

  <{filled_parameters: Expression}> => //TODO .copy, which is just another history branch

  => (def: (x?): *) => defs.push_back(def)
    //TODO When parameterless => is an override by default

  {" "}({parameters: Expression}): Function
    //TODO Default &=, default override all the locations (just override the var), so when override =, it's also assign

  //TODO Define super() for any =

  //TODO Conditional edges/gotos
  //TODO .expand on an unknown function makes the length possibly infinite, optionally assume it terminates

  //TODO Coroutine where it's a race, and one is finite which always terminates the others are not, the whole function still always terminates.

  // return_type** => The function which generates the value. Which is a subfunction of the actual function which generated it.
  // TODO: Want to allow to access the whole function which generated the change you see in the sequence of functions called on the variable.
end

class Function | Program = Boundary
  ∙.x: {
    context: *

    //TODO Result is the last line/var of function, so it's the previous step?
    //TODO So 'in' is previous state.
    //TODO But in: should actually be the entire function context.
    result: out
  }

  external (parameters: in): return_type

  if !?⊢
    step (
      override: boolean = true // Setting override to false, spawns a new path of execution which can be stepped independently.
    )
  end

  arguments => ∙⊣first //TODO .state
  //TODO arguments = , When vertex is set to None, should set recursively the boundaries etc. as well. And extend the initial boundaries with Function.

  in | parameters => x
  out | intermediate_return_type => ∙⊣.x
  return_type => last.out



  // With the assumption that each non-expandable step terminates.
  total | decidable | always_terminates | always_halts => expanded.length#.every(!= ∞)
end