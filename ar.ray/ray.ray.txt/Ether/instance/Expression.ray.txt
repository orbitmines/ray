
class Expression = String // Any string is legal syntax
  protected def generate_ast
    delimiter = "/" | "." | \s | \n


  end

  ast = generate_ast
  &= ast

  def eval => *

  end
end

//TODO Default first initialization is, if is None, overwrite, otherwise &=, otherwise = if = is provided.

// Program is control-flow, with associated contexts
// Want to be able to convert program back into a string expression, but it needs to decorate the contexts somehow (which is necessary for Access)
// &caller = {ref to object} or something to stringify the expression would require object refs accessible too.
// Then it would be things like
// A + B + C from different context be
// (
     &caller = OBJECT_ID
     A + B
   ) (
     &caller = OBJECT_ID2
     + C
   ) //TODO In this case + C needs the context of A+B, not the parent local context above A+B
// Quests should be spawned to resolve lazy expressions/programs
// Quests spawn to possibly fill cache of history values (if they're used often etc.. other considerations)

//TODO caller is the method in a class, since caller is a location, it has .parent on it defined on it which is the class.
//TODO caller -> .parent == Some player except for the last one which doesn't have a .parent

// These object references are to a particular version of that object. ; dynamically is ref to most recent version, encoded how? UUID.last?
//TODO OR require eval before committing to expression string with object_id
//TODO Conditional edge

Result = Waiting | Intermediate(function: *, result: *) | Final(result: *)

//TODO What if other things apart from the vertex are changed? Keep track of that. What if other vars are relevant, need to keep track and store those in history too? (Like a random seed), want each thread to be deterministic, but allow option sto say: run again without those set parameters.
class Program = Ray<Vertex>
  //TODO We might have a program pointer which .expands into other programs like function calls, we want to context of "we're handling this .expand" + "we're here in the .expand". So many pointers to program at ##.

  //TODO What if the program mid-execution updates to a new version, how to handle that?: Update all instances of current quests running that function

  //TODO Everything to do with a particular variable is all grouped in a single .expand, so that each successive top-level vertex is a new access into the program context.
end
//TODO UUID-s built up in a history version file are Node: Mac address that we generate for an instance based on the pub-key?, timestamp is the last edited time of that object.
//TODO ; does not change the selected context to + on.
//TODO Newlines () () should apply to each-other. or pending operations should too.