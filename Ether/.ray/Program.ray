global = local

// Compiler
// When using '1 Object', you still allow the compiler to use many objects there for abstract interpretation, it's just that for type checking you expect there to be just one.
// Chaining operators like ==.instance_of / <
//TODO If a variable is any, anything called on it will become a requirement , a function with an assigned type return; a requirement.
// "run at compile time" ; constexpr

// "accepts type X" but only really uses subtype "Y". So either allow subtype Y, or force that entire X type.
//TODO Notion of what is effected; what is changed by some function, and only limit certain changed with a keyword like confidential to pass it to a function with that

// variable rewrites (v, w) -> (w, z), match any in Graph, rewrite rules

  // compose matching domain/codomain

// Inverse is f' ?

// Usages of function

//TODO Shared state means what in the function control-graph

//TODO // Accessing variables while function in running.

// Recursively put code in front of every block
recur = <
  &caller = @me

  clock = Time.NOW()
  &next.push
    time_elapsed = clock.time_elapsed()
  //TODO Or allow access to super() which will be the super() of <> -> Do you ever need to access super() of that function you're accessing?

  recur()
>

<{expression: Expression}> // Before each statement in context
Node +=
  <{expression: Expression}> // Before constructor, or method call, so function returns can reference arbitrary types within the method body?

// Parsing
//TODO Ambiguity between return ME if, meaning ME or returning ME.if, the space prefers Expression if

//TODO Ambiguity if we say boolean, and have a class call bo, with operator ole, on an (another class). we can't just split the tokens.
// -> Resolve this ambiguity by preferring the attached version (since it's longer)





//TODO List of methods which shouldnt be called on local, but on this if possible:
// #, * (on global, not local)

//TODO local**# => Iterate threads
//TODO How to get the current thread, Does local** have a way of getting that current value have it be a ray, but iterate over all, not just next.

//Coroutines like race say start quest which says function.stop

//TODO What about other evaluation orders, they're shuffled in the right order in this control-flow.
//TODO What if I still want them stored out of order? -> Top-level expression is out-of-order.

class Function | Program = Boundary
  //TODO as (language: Language, compiler_options: {} = {})
  //TODO Things in history where we store a copy of the cached program, and then execute from cache
  //TODO Only translate subexpressions to certain languages. Superpose languages by superposing different implementations and then something like a corotine to which one finishes first.
  //TODO Then it's run as separate executable vs run according to their control-flow implementation.
  expression: Expression

  //TODO Should be placeable on any Expression, and should change the call to that, even parameterless.
  <{filled_parameters: Expression}> => //TODO .copy, which is just another history branch

  => (def: (x?): *) => defs.push_back(def)
    //TODO When parameterless => is an override by default, on Expression?

  {" "}({parameters: Expression}): Function
    //TODO Default &=, default override all the locations (just override the var), so when override =, it's also assign

  //TODO Define super() for any =
  //TODO Or refer to other branches which are labelled, so labels cross branches.

  //TODO Conditional edges/gotos
  //TODO .expand on an unknown function makes the length possibly infinite, optionally assume it terminates

  //TODO Coroutine where it's a race, and one is finite which always terminates the others are not, the whole function still always terminates.

  // return_type** => The function which generates the value. Which is a subfunction of the actual function which generated it.
  // TODO: Want to allow to access the whole function which generated the change you see in the sequence of functions called on the variable.
end

left-associative
right-associative //TODO

// Switch the global context to a different version of the language.
//TODO What about existing objects, check versions of all classes, and patch if possible
external = (version: 1 Language.Ray%.Version)
external location

//TODO Certain things like the global <> prefer over calling the locally defined one, how to flag?
//TODO The obvious successors to this would be after, or in between each recursive function call (x levels deep). Benchmarking would use that. (Done by just implementing a function which does that and call that instead, finally and X)
// Execute expression on each successive function call in its context. So if called within (), it only works within that context.
external <{expression: Expression}>: void
// Label the current cursor within a program with a name.
external {label: *}\: Program //TODO Push to program.name

/{path: *}: Program OR (x): //TODO INFER
  //TODO Program which is callable with single parameter (recursively ensure path is available on x)

//TODO coroutines like race here.

// async/await branches/coroutines
branch
race


return (expression: Expression) //TODO Allow out-or-order execution.
  // Ignore the values set by manually setting &caller, and only return to the original function.
  // For instance, history sets &caller to preserve history, but we want to continue the history function, not where it originally called from.
  caller = &caller%.first∙

  caller.next.out = expression
  caller.parent.push
  caller.next = .push //TODO Push so that it's after the instruction.

finally (expression: Expression)
  (&caller -> .collapse).last.push_back(expression) //TODO Do we want it to effect out-of-order, but specifically executed at the start.?
  //TODO This assumes that the returns are push_backable, instead of the returns continuing to the prev func. How to fix?
  //TODO Return: what if we say the .terminal expands into the continuation, but it's still terminal this way. But then the push_back would have to be before the expansion, not after it.

// TODO before_each/after_each recursively: filter, or filter on program to set it for nested expressions yes/no etc.. (expression: Expression)

namespace goto
  (program: Program, predicate: Expression?)
    &caller.push(program, ⊙: // TODO load condition on edge, or rather load it on the function boundary?)
    //TODO: Remove the goto from the program.
  end

  if (predicate: Expression) => this<predicate: predicate>
end

class Context //Subgraph of a function.context
// Span implements Ray, because the whole current thing is selected as the Node. which .expands into the separate components.
//span: a Ray{∙: expression} again, we want a subgraph of a larger graph.
// Define line_number: span.reverse{"\n"}.count on a subgraph of a string.
// Similarly define column as to(.reverse{"\n"}.first).length
// span.line:column
// From line:column, how to recover the original span (automatic reverse)
//TODO Or a field, which only applies to a certain subgraph of a larger graph say "ABCDEF", have .field different for "ABC" and for "DEF"
"ABCDEF"[0..2]
  field:

//TODO Shaders are like parallel iterators; there's an unrollable loop in the Many iterator for threads.
//      -> This existence of a forloop, means the program assumes Many definitions are in turn also programs. -> Of course
class Function | Program < Boundary &+ Hierarchy /* If the  */ &+ expression: Expression
   // Hierarchy is actually somehow a 2nd level of collapse/expand, but in reverse; It's hidden from it, and from their perspective they dont collapse to this function, but continue as as the function. Like a mutual

  //TODO How to select .next to be only for Boundary. Because expression has been given separate name?
  //TODO Use expression to .expand function.

  //TODO Is intermediate state the whole context? Or what do we do with sequence of operations on some variable? How to intuitively make that sequence only about that variable? and things it depends on

  //TODO Context information like line-number in parent expression, etc.. and larger context

  location: a Context & (span: ) & "{}:{}"

  ∙: State
  // Program State
  // - A looped control-flow, has the values of each iteration stored in the state's history.
  //   - Different instantiated branches are also different branches in the state's history.
  static class State < Ray
    ⊢: Program

    //TODO State is a history? Then calling the .x is the version at that history.
    x: {
      context: *
      //TODO Things like &caller are in context

      //TODO Result is the last line/var of function, so it's the previous step?
      //TODO So 'in' is previous state.
      //TODO But in: should actually be the entire function context.
      result: out
    }
  end
  //TODO If context is checked for access permission, it's the program that's checked instead. and its &who
  //TODO Is Context just the Program State? Need to think that through
  class Context
    external local: this

    // Get the currently running function
    none.write external &: Program

    dynamically if &parent
      delegate {: not in this} => &parent.[GET THAT FUNCTIONS STATE/CONTEXT]


  external (args: in.type): return_type

  if !?⊢
    step (
      override: boolean = true // Setting override to false, spawns a new path of execution which can be stepped independently.
    )
  end

  args | arguments => first.out
  result => last.out //TODO This is a variable where ** = this program. Basically a var is bound to the result of the function
  return_type => result.type

  // .variables, .usages, domain, image, codomain, injective, surjective, bijective, homomorphism, isomorphism, endomorphism, automorphism, monomorphism (the static class variable which automatically becomes a instance var)

  // The function which called this function
  // This is empty when asking the &caller of the top-level context; the character.
  parent | caller : Program? => first.x //TODO Instead it's a collapsed initial?
  // The latest known character associated with this chain of function calls (set this variable to change it)
  who | character : Character (parent ? => parent.character : = ∙.x.last) //TODO What if the character is branched?
  dynamically assert character !== None

  //TODO .children TODO collapsed terminal.

  //TODO Superposing different implementations of the same function how? (Superposing languages)

  //TODO Some way to calculate resources used (storage, memory, time, how large the Ray is to construct a program/variable)

  callee => // from parameters one of which is the instance, other's are named; exclusion?

  in | parameters => ∙⊣this .x
  out | local => ∙.x

  //TODO Good name for the original function
  base: Program => //TODO Pointer to history.
  //TODO Base vs the original function filled with parameters, a good name for that

  recur (callee) => base.copy(callee: callee) //TODO + Parameters

  //TODO schedule, spawn entity if necessary, if already an NPC, use that NPC quests.
  //TODO < Quest, implement .stop

  // With the assumption that each non-expandable step terminates.
  static Total | Decidable | Terminating | Halting => static{expanded.length#.every != ∞}
  //TODO Automatically implements total/decidable/terminating/halting, because it's a filter. on static

  {: UUID} => //TODO Load the version and remove the current function graph

  as (== Expression) =>
    //TODO Store program with any state etc.. which would be used to pause certain quests/functions. For instance save/pausing a game.
    //TODO Use the program's expression if no state has changed. -> super()
end
{ Total | Decidable | Terminating | Halting } = Program

// TODO Coroutines
//    - branch; separate thread
// TODO Concurrently accessing variables
//    - sync: Run concurrently, return when all are done, race: First one to finish, the rest is cancelled. rush: same as race, but they're allowed to finish, the ones that didnt finish first., defer: Run after current context finishes (no matter how it exists)
// TODO Await for an event to trigger, and then do things like race, with many awaits, and then continue in the code


// Language templating
⸨⸩{language: Language} (expression: language.Expression)

class Expression < language.Expression
  language: Language = ".ray"

  dynamically
    protected fn = as Program
    delegate (: fn.in.type) => fn

  as (: Language): Expression => //TODO
  as (== Program)
end

// A language, is interpreted liberally here. It is just a mapping from Expression => as (*).
// A collection of ideas, ; as a library; is also considered a language. (Like mathematics)
class Library < Language
class Lang | Language (extension: ".", String)?
  // History .expands into history of the github repository as example, any versions not exposed to this view, so hidden, are not regarded as legal version of the language, but those which are exposed do.

  children: Language // defined in class hierarchy
  name => static.name // Like Rocq/Coq the name changed

  static Targeting (language: Language) => static{Expression{as (language): language.Expression}}

  //TODO Should automatically implement Language.BackwardsCompatible, like Targeting does for targeting
  backwards_compatible => (<-%).all.targeting(this)
  forwards_compatible => (%->).all.targeting(this)

  dynamically equivalence extension | name.ignore_case => this

  //TODO Different Expression functionality for each extension, for instance .uc .uci .upkg

  // The datastructure the language is encoded in.
  static Expression
    as (== Program)
    as (language: Language): language.Expression

end
//TODO Equivalence between Function with parameter = Expression, to Target; as (*)
//TODO How to formally say; if there's sufficient interesting mapping between output, we consider it as a language. 1-1 mappings etc,, (or heavy reliance on the input or something)

//TODO
Program < Language

Language // This namespace will be used for: < Language
  namespace Ray < global & Language(".ray")

%
  //TODO Shadow each language implementation history, so we dont need to have access to the top-level language version

static class Expression < String & global.Ray?
  //TODO Then how to define the assumptions of newline meaning => etc..

  //TODO Expression comes from some file or more generally a context, have that information available here.

  external comment: String

  , (b: Expression)

  //TODO Space counts as --
  // => higher precedence than --
  // Allow space/newline (unless theres a newline between false and true?, depends on the indentation as well) ; Allow false, true .map(!)
  -- (b: Expression)
  //'-- . if this ~= ^"::ffff"'. If branch doesnt precede the --, so it's only for that line.
  //'--' shoudld be allowed to start as a this. like ' -- .embed_ipv4 if this ~= ^"::ffff"'
  //Allow multiline '--'
  //Allow returning out of a -- statement.

  // Multiline multiple edits allow (Like in Unicode)
  // Like '--', but applies some expression and returns the variable it was applied to.
  ~~ (b: Expression)

  {" "}: (type) => //TODO Wrap whole expression in : type
  as (== Program)


Program
  ==
    // Used within this context, they have the same behavior
    //
    extensional1