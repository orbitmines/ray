//TODO Move to a geometry file?

SI_Unit m "meter"

Unit "h" | "hour" "s"?
Unit "minute" "s"?
SI_Unit s "second"

Unit ~ hour -> *60 minutes -> *60 seconds



class Quantity<Base = Number> = quantities: (Base, unit: Unit = Unit.None)[]{length > 0}
  //TODO Implement number

  // Ensure that every part of a quantity like '1d 10h 10ms' is part of an equivalence class.
  dynamically assert quantities.every _, unit => unit == quantities.0.unit
  // Require quantities are in order from largest -> smallest
  dynamically assert quantities.unit as quantities.0.unit[] -- .sorted(>)

  // Allow for syntax `1d 10h 10m 30s`
  def `quantity: Quantity` = quantities ,= quantity

  // Allow for syntax `10000000s ~~ normalizer = days hours minutes seconds`
  def as(:== Normalizer) = Unit.Normalizers.modulus(this)
end

class Unit = name
  static namespace Normalizers
    def modulus order: Quantity => Quantity.Normalizer = (x) => {
      result: Quantity?
      order.quantities.unit.for unit
        quantity = x as unit (-- .floor if !is_last)

        result ? result quantity : result = quantity

        x -= quantity
      end

      result
    }
  end

  static.@.push this

  // Allow for syntax `name`
  // Allow for 'var: Decimal.Positive, ns = 10 ns' syntax.
  caller[name] = this if name

  def reexport
    caller[name] = this
  end

  static None = Unit(global.None)

  static ~ ray: Tree
    //TODO
  end

  def `unit: Unit`
    //TODO String units like 3h 20s
  end

  // Allow for syntax `year as ns`
  def as :== Quantity = 1, this
  def as other: ==.instance_of Unit = this as Quantity as other

  //TODO How to prefer Martian as string for disambiguation
  //If not define globally ignore the string names for that.

  protected unit = this
  protected define_globally = caller == global
  // Allows syntax 1`name` (1m)
  if define_globally
    global.def `digits: Decimal.Positive.String, name: unit.name` => Quantity = digits, unit
  // Allows syntax 1.0`name` (1.0m)
  +def Decimal.Positive
    if define_globally
      def `fraction: Decimal.Positive.String, name: unit.name` => Quantity = integer, ".", fraction, unit

    //TODO Should overwrite Number.def`node: not String` since it's more specific
    // Allows syntax 1 `name` (1 m)
    // Allows syntax 1.`name` (1.m)
    def `unit (define_globally ? | unit.name)` => Quantity = this, unit
  end
  // Allows syntax 1.0 `name` (1.0 m)
  // Allows syntax 1.0.`name` (1.0.m)
  +def Decimal.Real
    def `unit (define_globally ? | unit.name)` => Quantity = this, unit
  end

  def convert convert: (From < Number) => To < Number, ToUnit: Unit
    FromUnit = static

    global.+def Quantity<From>{.unit == this}
      def as :== ToUnit => Quantity<To>{unit == ToUnit} = convert(this)
    end

    //TODO This shouldn't be necessary the 'as' before should already do this.
    //TODO Automatically implement reverses of offset, multiple, magnitude, If reversible. Decimal.Positive => Decimal.Positive for instance is only reversible if the dynamically asserts holds of being divisble.
    //global.+def Quantity<To>{.unit == ToUnit}
    //  def as :== FromUnit => Quantity<From>{unit == FromUnit} = convert.reverse(this)
    //end
  end

  def offset offset: Number, ToUnit: Unit
    convert x: Number = x + offset, ToUnit
  end

  def multiple multiple: Number, ToUnit: Unit
    convert x: Number = x * multiple, ToUnit
  end

  def magnitude exponent: Number, ToUnit: Unit, Base: Decimal
    //TODO Support non-integer magnitude exponents for reals.

    //TODO These should automatically implement for Decimal, and Decimal.Real
    convert x: Decimal.Positive => Decimal.Positive, ToUnit
      dynamically assert
        // Positive exponents we can always shift within Decimal.Positive
        exponent >= 0
        // Otherwise check if we can divide by that exponent
        | x % 10^-exponent == 0 // TODO Should only implement method if this assert passes

      x << exponent //TODO This is a decimal (`Base`) shift, when working with binary values you want to access them as binary if you want that shift.
    end
    convert x: Decimal.Real.Positive => Decimal.Real.Positive, ToUnit
      if exponent == 0
        x
      elsif exponent > 0
        x.integer, x.fraction.0 ?? 0, ".", x.fraction[1..]
      else
        x.integer[..-1], ".", x.integer[-1] ?? 0, x.fraction
      end
    end
  end
end
 

def SI_Unit
  def `symbol: *` name: *
    private SI = {
      -30: q`symbol` | "quecto`name`" "s"?
      -27: r`symbol` | "ronto`name`" "s"?
      -24: y`symbol` | "yocto`name`" "s"?
      -21: z`symbol` | "zepto`name`" "s"?
      -18: a`symbol` | "atto`name`" "s"?
      -15: f`symbol` | "femto`name`" "s"?
      -12: p`symbol` | "pico`name`" "s"?
      -9: n`symbol` | "nano`name`" "s"?
      -6: Âµ`symbol` | "micro`name`" "s"?
      -3: m`symbol` | "milli`name`" "s"?
      -2: c`symbol` | "centi`name`" "s"?
      -1: d`symbol` | "deci`name`" "s"?
      0: `symbol` | name "s"?
      1: da`symbol` | "deka`name`" "s"?
      2: h`symbol` | "hecto`name`" "s"?
      3: k`symbol` | "kilo`name`" "s"?
      6: M`symbol` | "mega`name`" "s"?
      9: G`symbol` | "giga`name`" "s"?
      12: T`symbol` | "tera`name`" "s"?
      15: P`symbol` | "peta`name`" "s"?
      18: E`symbol` | "exa`name`" "s"?
      21: Z`symbol` | "zetta`name`" "s"?
      24: Y`symbol` | "yotta`name`" "s"?
      27: R`symbol` | "ronna`name`" "s"?
      30: Q`symbol` | "quetta`name`" "s"?
    }
      .map(magnitude, name => Unit(name: magnitude: magnitude))
      .reduce(|)


    SI@.for FromUnit = FromUnit.magnitude SI.magnitude - FromUnit.magnitude, SI

  end
end