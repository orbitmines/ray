//TODO If OS allows custom UUID1 generation, overwrite with external
// A Universally Unique IDentifier (UUID) (https://datatracker.ietf.org/doc/html/rfc4122)
class UUID = Hexadecimal{length == 32} ~~ [7 | +4 | +4 | +4].push_after("-")
  def version = this[12] //TODO Should automatically implement version =

  // Dynamically associate a UUID to a version's class
  dynamically
    < v1 if version == 1
    < v3 if version == 3
    < v4 if version == 4
    < v5 if version == 5

  static class v1 < UUID
    = (
        time_low: Hexadecimal{length == 8},
        time_mid: Hexadecimal{length == 4},
        (
          version: Hexadecimal{length == 1},
          time_high: Hexadecimal{length == 3}
        ) = time_high_and_version: Hexadecimal{length == 4}
      ) | (
        // The timestamp is a 60-bit value (or Hexadecimal{length == 15}) (https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.4)
        (time_high, time_mid, time_low) = time: Binary{length == 60} = (
          // For UUID version 1, this is represented by Coordinated Universal Time (UTC) as a count of 100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar).
          timestamp = Time.NOW(epoch: "1582-10-15 00:00:00") as ns / 100 -- .floor
          // Make sure each call yields a unique value.
          //TODO ; Say I want a unique value, I dont care how you get it.
          timestamp = timestamp@global + 1 if timestamp <= timestamp@global
          timestamp@global = timestamp //TODO What to do if it's larger than a 60-bit integer
        ), //TODO Compiler should be able to reverse time, if the other 3 are provided.
        version
      ), //TODO How to say this is not the one used for converting from string, like a 'secondary' implementation -> Since now there's ambiguity
      (
        (
          variant: ~= ^[1,1] ? Binary{length == 3} : Binary{length == 2} = [1,0],
          clock_seq_high: Binary{length == 8 - variant.length}
        ) = clock_seq_high_and_reserved: Hexadecimal{length == 2},
        clock_seq_low: Hexadecimal{length == 2},
      ) | (
        variant,
        (clock_seq_high, clock_seq_low) = clock_seq: Binary{length == 16 - variant.length} = Binary{length == 16 - variant.length}.random
      ),
      node: Hexadecimal{length == 12} = INSTANCE.mac_address

    static Variant = RESERVED_NCS | RFC_4122 | RESERVED_MICROSOFT | RESERVED_FUTURE
    +def variant
      def as :== Variant = match
        ^0 => Variant.RESERVED_NCS
        1,0 => Variant.RFC_4122
        1,1,0 => Variant.RESERVED_MICROSOFT
        1,1,1 => Variant.RESERVED_FUTURE
    end

    dynamically assert version == 1
  end
  static class v3 < UUID = namespace: UUID, name: String //TODO
    dynamically assert version == 3
  end
  static class v4 < UUID = secure Hexadecimal{length == 32}.random ~~ version = 4 //TODO Compiler should know it only needs to generate length == 31 here
    dynamically assert version == 4
  end
  static class v5 < UUID = namespace: UUID, name: String //TODO
    dynamically assert version == 5
  end

  static Namespace
    DNS: UUID = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
    URL: UUID = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
    OID: UUID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8"
    X500: UUID = "6ba7b814-9dad-11d1-80b4-00c04fd430c8"
  end
end