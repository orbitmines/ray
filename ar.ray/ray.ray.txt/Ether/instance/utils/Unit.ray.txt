//TODO Move to a geometry file?
SI Distance "m"

class Unit
end

dynamically Bases.for Base

   // Units scaled by an order of Magnitude
   // TODO This could be rewritten into a compiler optimization when we have a Multiple in a specific base.

  `Base`.Positive.static class Magnitude<exponent: Positive> = Positive
    def as :== Positive = integer << exponent //TODO This is a decimal (`Base`) shift, when working with binary values you want to access them as binary if you want that shift.
  end
  `Base`.static class Magnitude<exponent: Positive> = `Base`
     def as :== `Base` = sign, integer as Positive.Magnitude<exponent>
  end
   //TODO Support non-integer magnitude exponents for reals.
  `Base`.Real.Positive.static class Magnitude<exponent: `Base`> = Positive
    def as :== Positive
      if exponent == 0
        this
      elsif exponent > 0
        integer, fraction.0 ?? 0, ".", fraction[1..]
      else
        integer[..-1], ".", integer[-1] ?? 0, fraction
      end
    end
  end
  `Base`.Real.static class Magnitude<exponent: `Base`> = Real
    def as :== Real = sign, real as Positive.Magnitude<exponent>
  end
end

def SI
  def `Class: *` symbol, Base = Decimal
    private magnitudes = {
      q`symbol` = -30 // quecto-
      r`symbol` = -27 // ronto-
      y`symbol` = -24 // yocto-
      z`symbol` = -21 // zepto-
      a`symbol` = -18 // atto-
      f`symbol` = -15 // femto-
      p`symbol` = -12 // pico-
      n`symbol` = -9  // nano-
      Âµ`symbol` = -6  // micro-
      m`symbol` = -3  // milli-
      c`symbol` = -2  // centi-
      d`symbol` = -1  // deci-
      `symbol` = 0    // -
      da`symbol` = 1  // deka-
      h`symbol` = 2   // hecto-
      k`symbol` = 3   // kilo-
      M`symbol` = 6   // mega-
      G`symbol` = 9   // giga-
      T`symbol` = 12  // tera-
      P`symbol` = 15  // peta-
      E`symbol` = 18  // exa-
      Z`symbol` = 21  // zetta-
      Y`symbol` = 24  // yotta-
      R`symbol` = 27  // ronna-
      Q`symbol` = 30  // quetta-
    }
    private SI = magnitudes.keys.reduce(|)

    // Allow syntax ns/ns.Positive/ns.Real/ns.Real.Positive as a type.
    global.def `si: SI` => `Class`{.si == si}

    // Allows syntax 1`symbol` (1m)
    global.def `digits: Base.Positive.String, si: SI` => `Class`.Positive = digits, si
    // Allows syntax 1.0`symbol` (1.0m)
    +def `Base`.Positive
      def `fraction: Base.Positive.String, si: SI` => `Class`.Real.Positive = integer, ".", fraction, si

      //TODO Should overwrite Number.def`node: not String` since it's more specific
      // Allows syntax 1 `symbol` (1 m)
      def `si: SI` => `Class`.Positive = this, si
    end
    // Allows syntax 1.0 `symbol` (1.0 m)
    +def `Base`.Real
      def `si: SI` => `Class`.Real.Positive = this, si
    end

    `Class` = `Base`.`Class` = caller.static class `Class` = `Base`.Magnitude<exponent = magnitudes[si]>, si = SI
      static class Positive = `Base`.Positive.Magnitude<exponent = magnitudes[si]>, si = SI
      static class Real = `Base`.Real.Magnitude<exponent = magnitudes[si]>, si = SI
        static class Positive = `Base`.Real.Positive.Magnitude<exponent = magnitudes[si]>, si = SI
      end
    end
  end
end