class
  {name: *} (def: (Args: *): *)
    local.name = name
    &definer[name] = local

    static = local

    (args: Args)
      (protected if name == "*") .static = static
      protected this = local

      def(local: this, ...args)
      return this

    //TODO Call constructor for static
    local
  end

  local
end

class * | Node
  local = .

  external =
  external {*} | [{name: *}]
  external #

  | | or (x: type) => #, (| x)
  & | and (x: type) => #, (& x)

  |= (x: type) => # = | x
  &= (x: type) => # = & x

  // Monkey-patch
  += | patch (def: (): *) => def(local: this)

  // Even though 'this' is already a type, we allow the binding of a less restrictive type. That way it can be reassigned to.
  type: * = *
  : (type) => this ~~ .type = type
  // Allow 'var?: type' syntax, because certain types would have to be wrapped in parentheses otherwise.
  ?: (type) => : type?
  dynamically assert this ==.instance_of type
end

//TODO WHat's the difference between Function and Program
//TODO Function and #.
//TODO Chain in # means function chain. So &/|, need to be in parallel by default
class Function
  parameters: *
  intermediate_return_type: *
  return_type: #.last.intermediate_return_type
  dynamically assert // every .next parameters == intermediate_return_type

  external (parameters: this.parameters): return_type

  => (def: (x?): *) => defs.push_back(def)

end

class Option = Some(value: T) | None
{ Some, None } *= Option
Some +=
  {property: *}
    ret = value[property]
    return ret ==.instance_of Some(*) ? ret : Some(ret)
end
None +=
  {" "}({parameters: Expression}): Function
    < Function

    local

end