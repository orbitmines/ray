class
  {name: *} (def: (Args: *): *)
    local.name = name
    &definer[name] = local

    static = local

    (args: Args)
      (protected if name == "*") .static = static
      protected this = local

      def(local: this, ...args) //TODO Call-by-ref here would be the default, so that if a parameter is changed, the successive patches get that same variable.
      return this

    // Monkey-patch a constructor
    += | patch = (patch: (): *) => def &= patch

    //TODO Call constructor for static
    local
  end

  local
end

class * | Node
  external local

  external = | assign (x): x //TODO Might have to set # equal to x
  external {*} | [{property: *}] //TODO How to say infer the property.
  external # | all : static
  external * | methods : { {key: *}: value: Program? }
  external ** | program : Program
  external {"{", filter: Expression, "}"} | (filter (filter: Expression)) : static?

  | | or (x: type) => #, (| x)
  & | and (x: type) => #, (& x)

  |= (x: type) => # = | x
  &= (x: type) => # = & x

  // Monkey-patch an instance
  += | patch (patch: (): *) => patch(local: this)

  // Even though 'this' is already a type, we allow the binding of a less restrictive type. That way it can be reassigned to.
  type: * = *
  : (type) => this ~~ .type = type
  // Allow 'var?: type' syntax, because certain types would have to be wrapped in parentheses otherwise.
  ?: (type) => : type?
  dynamically assert this ==.instance_of type

  as (:== boolean) => true
end

class Option<T> = T | None
{ None } *= Option
None +=
  {" "}({parameters: Expression}): Function
    < Function

    local

  as (:== boolean) => false
end