
// static parts of the constructor are filtered out using the same rewriting strategies used for compiler optimizations.

//TODO Local context doesnt override this/static how?, It's still a node.
class
  //TODO class{==.instance_of Nameable}, instance_of class

  {name: *} (def: (Args: *): *) //TODO Allow out-of-order
    // Allow Class.name |= "Class2" to add aliases
    dynamically &definer[local.name] = local if local.name
    local.name = name

    static = local

    (args: Args)
      (protected if name == "*") .static = static
      protected this = local //TODO Allow this<World>

      def(local: this, ...args) //TODO Call-by-ref here would be the default, so that if a parameter is changed, the successive patches get that same variable.
      return this

    // Monkey-patch a constructor
    += | patch = (patch: (): *) => def &= patch

    //TODO Call constructor for static
    local
  end

  local
end



class * | Node
  //TODO Generalize: Pattern left is matched to pattern right: first, ..middle, last; first, middle: [], last, [first ..after]
  //{
  //  field: WithAdditionalType,
  //  field2 { nested },
  //  { nested2 } = field3,
  //  field4: Some field4a,
  //  field5 [first, ..middle, last]
  //  first2, ..after = field6
  //  //[first2, ..after] = field6
  //}: ParentType = Object

  // {pattern} = () => doesnt do the *= operation because of the ()
  external = | assign (x): x //TODO Might have to set # equal to x
  //TODO .not is {!=.instance_of}
  //TODO .not in  not Network.Hosts*.keys.reduce(|) //TODO What's the proper syntax for this, very verbose
  // * operator allows you to access whether a default is loaded, and whether the current value is that default value, don't store (optionally) if that''s the case.
  // If # is used in something like as:== string, it should overwrite default behavior of doing a map on that function. Like the as string in IPv6
  //TODO If # is a Ray, we have a 'selected'. #.
  external # | all : Iterable<static> //TODO Is a # just an .expand? or are both ever used simultaneously?
  // +/&+ are both components but normal + overrides.
  external ## | components : Iterable<static##.reduce(|)> //TODO Does this type work?
  //TODO Exclude vs include things like local and other defined properties on Node,
  external * | methods : { {key: *}: value: Program? }
  external ** | program : Program
  // Force the lazy program stored in **, to evaluate.
  external {"{", filter: Expression, "}"} | (filter (filter: Expression)) : static?

  // TODO Places in code where this variable gets referenced and updated.

  | | or (x: type) => #, (| x)
  & | and (x: type) => #, (& x)

  // Monkey-patch an instance
  += | patch (patch: (): *) => patch(local: this)

  //TODO sUBTRACT/ADD TYPES
  +
  -

  &+
  &- //TODO Removes all with that type.
  |+
  |- //

  ⊢/./!⊢ // Allow if x ⊢11

  // All
  {operator: *{"{.}=" not in this && . ~= (Symbol & ¬"=")[]}= (x)
    this = this[operator](x)

  //TODO Allow superpose of Ray + Ray, without interfering with eachother???
  //But you want += to override (Difference is + vs &+/&- |+/|-) ; ++ is also used for superposing Many rays into a single object. which dont interfere.
  A &+ B == A & B // except for override by B
  //Can also be nested #
  A &+ (B & C)
  Ray & Ray &+ Ray = Ray & (Ray &+ Ray)
  // Program similarly, many programs selected, but each program has many pointers to execution threads.
  //TODO All these < Ray become &+ Ray.

  //TODO How to access additional type information like A.disjoint(B)
  // Even though 'this' is already a type, we allow the binding of a less restrictive type. That way it can be reassigned to.
  type: * = *
  : | ∊ | ∈ (type) => this ~~ .type = type
  ∉ (type) => this: not type
  ∍ | ∋ (member) => member ∈ this -- this //TODO This higher precedence than : so it is executed on the type when x ∈ String ∋ x^2
  ∌ (member) => member ∉ this -- this
  // Allow 'var?: type' syntax, because certain types would have to be wrapped in parentheses otherwise.
  ?: (type) => : type?
  dynamically assert this ==.instance_of type

                                    // Stops when hitting None
                                    -> | →

                                    // Some(5).match
                                    //   Some a: 5
                                    //   Some a: 5..10
                                    match => //TODO Use .if, vs " "if for expression

  //Map defined on Node, so that a superposed variable works with .map and maps them all
  // What else

  //TODO What about map in place of certain Ray, allowing you to flat map in a structure.
  //TODO What if I want to .map on String (&?)+ Ray, Then Ray would take preference for .map? Or is ray only mapping the specific ones??
  //TODO Or now it would map Both direction & itself, which might also be preferred in some cases.
  map

  ++ | copy

  .= //TODO .= next ; x = x.next

  // instance_of and == are the same?
  namespace === // Don't ignore location
  namespace ==
    // In variables have a way to get partial equality.
    <up_to?> () =>
      in?: -> as (*)
    instance_of // A.zip(B).every(a, b => a instanceof b) && Structure is equal: A ==.isomorphic B)
    isomorphic // (Equal in structure, ignores values)
  namespace !=
  ≧ | ≥ | >= = ==
  ≦ | ≤ | <= =
  namespace >
  namespace >=
  //TODO ~= is subgraph
  namespace ~= (expression: Expression{: initial: "^" | "⊢" ?, ?, terminal: "$" | "⊣" ?})
  !~=

  ?? | else

  as (:== boolean) => true
end

class Option<T> = T | None
{ None } *= Option
None +=
  {" "}({parameters: Expression}): Function
    < Function

    local

 //TODO Ray. arguments = , When vertex is set to None, should set recursively the boundaries etc. as well. And extend the initial boundaries with Function.

  as (:== boolean) => false
end

//TODO .canonical as the thing which resolves equivalent forms of the same Instance for example.

unique
  //TODO either same object or assert
  //TODO unique{} accepts an expression which it maps to before checking uniqueness
  dynamically assert #.

//TODO ? is unknown so it superposes by default.
//TODO ? is location depended, it sets the value to the type it's
//TODO Default assignment is ? if not an Option which is None, does that ever cause issues when you expect a singular value?
? =>

delegate in | out => object
delegate in Number => object

// Require that one of the superposed values is of the given type
a | an (type) => ∃Node ==.instance_of type