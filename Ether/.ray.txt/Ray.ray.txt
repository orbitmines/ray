//TODO What is a .expand on a boundary/edge
//TODO Ray whose <T> isn't recursively the same type: i.e. some array like [String, Number]
// X⊣⊙⊢∙⊣⊙⊢
// ⊢∙⊣⊙⊢X
// ⊢∙⊣⊢X
// X⊣⊙
// X⊣⊢∙⊣

class Boundary < Ray
  x: static = this

  end | vertex | ∙ : Ray
  edge | ⊙ : Edge
  continuation | ⊢ : static => ⊙⊢#{!= this}

  ?⊢ : is_initial => ∙⊢ == this
  ⊣? : is_terminal => ∙⊣ == this

  {path: (((path?, "⊙"?)?, "⊢")?, "∙")?, "⊣"}{.}
    x = this
    path.reverse.for method => x = x[method == "⊣" ? "⊢" : method]
    x
end
class Edge < Ray & (⊣ | ⊢ | ⊢{.} | list): Boundary
  x: static = this
  //TODO .value is defined on the Ray which defines the boundaries on list? Or ignore that.
end
//TODO .every on ray iterates both ways., explicit filter for excluding. (ray -> .next).for
class Ray<T?> (x | value) < AbstractDirectionality
  dynamically for(: T) if T
  //TODO .value is everything on x except the Rays defined at #. And we need distinction between methods on Ray/x

  //TODO is .expand implemented for looped types, which assume .expand unrolls the loop?

  initial | ⊢ | ⊢{.} : Boundary = Boundary(∙: this)
  terminal | ⊣ : Boundary = Boundary(∙: this)

  // Allow syntax for traversing the initial side: '⊢∙⊣⊙⊢var'
  {path: (((path?, "∙")?, "⊣")?, "⊙"?)?, "⊢"}{.}
    x = this
    path.reverse.for method => x = x[method]
    x

  //TODO .expand only the boundaries, or everything
  //TODO .paths possible paths to take.
end

class AbstractDirectionality<T> < Iterable<T>
end
class Iterable<T>
  as (:== T) => T() = this.reduce(|) //TODO if T is class.
end