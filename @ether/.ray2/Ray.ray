//TODO Something like is_boundary checks whether any of the entries (Many<>) are at a boundary, but that changes behavior of a superposed abstract interpretation when it shouldn't. (It should individually check is_boundary, and superpose the results)

//TODO First Ray extension defined is what gets equipped?

//TODO Graph .rewriting. dpo, spo, cartesion product, tensor product, union, disjoint union etc...

// Support generators. OR Automatically convert into a generator if something will be returned.
//  (Intermediate result basically)
yield & var

//TODO What is a .expand on a boundary/edge
//TODO Ray whose <T> isn't recursively the same type: i.e. some array like [String, Number]
// X⊣⊙⊢∙⊣⊙⊢
// ⊢∙⊣⊙⊢X
// ⊢∙⊣⊢X
// X⊣⊙
// X⊣⊢∙⊣



class Ordered<T = static> //Todo set T to caller's constructor
  <= (b: T) = this == b || this < b =>
  < (b: T)
  >= (b: T) = this == b || this > b
  > (b: T)

  ..{right: .} | {left: .}.. | .. (right?) = () =>

    //≧ | ≥ | >= = ==
    //≦ | ≤ | <= =
    //namespace >
    //namespace >=
end
Ordered &+ Ray
  <= (b: T) reduce()
  // gte: (self, value) => self.reduce_right((acc, current, cancel) =>
  //          acc.if(cancel, current.equals(value))
  //        , undefined),
  //        gt: (self, value) => self.reduce_right((acc, current, cancel) =>
  //          acc.if(cancel, acc.equals(undefined) /* TODO: More generally, a: "is this the first check" */.if(false, current.equals(value)))
  //        , undefined),
  //        lte: (self, value) => self.reduce((acc, current, cancel) =>
  //          acc.if(cancel, current.equals(value))
  //        , undefined),
  //        lt: (self, value) => self.reduce((acc, current, cancel) =>
  //          acc.if(cancel, acc.equals(undefined).if(false, current.equals(value)))
  //       , undefined)

//TODO Setting .value on Many boundary in the case of Edge.

//TODO Edge.list has Boundary more than once, self-loop
def Boundary<T>
  value: Boundary<T>? //TODO T could be on value, Or you want a specific type on Boundary
  end: Ray<T>
end
def Ray<T = Ray<T>> value: T? < AbstractDirectionality<Ray<T>>
  //TODO .value could be 'this' but stripped (is that necessary) of Ray functionality. So anything that extends Ray has its content moved and deferred to .value
  initial: Boundary<T> = Boundary<T>(end: this)
  terminal: Boundary<T> = Boundary<T>(end: this)

  static Unbounded //TODO
  end
end

private class Structure<T = Ray, HyperContinuations: boolean, HyperEdges: boolean = false> = Unbounded{count < Infinity}
  //TODO What's the value encoded on Edge?, and what's the value encoded on the boundaries? (Or do we always use edge)
  static Edge =

  //TODO What is .unrolled?? on type

  //TODO .[index] shouldnt overwrite the '1' without a .1 (needs a special rule)

  static Vertex = Ray<T>{
    initial = (HyperContinuations ? Many : 1) Boundary{ //TODO These =, need to be ==.instance_of?
      end = (HyperEdges ? Many : 1) Vertex,  //TODO (1 if !HyperEdges) or (!HyperEdges ? 1) Vertex allow this syntax
      value = (HyperEdges ? Many : 1) Boundary{
        end = (HyperEdges ? Many : 1) Vertex,
        value = (HyperEdges ? Many : 1) Vertex.initial
      }?
    },
    terminal = initial // By default a structure is symmetric
  } //TODO .unrolled

  static NonEmpty => static{count > 0}
  static Unbounded{every(==.instanceof Vertex)} < AbstractDirectionality<Vertex>
    //TODO These set Vertex to a different value
    def acyclic //TODO Disallow loops, want these things: Graph.acyclic = Graph{acyclic}, if graph.acyclic,
    def connected
    def consistent
  end
end
def Hypergraph<T = Ray> < Structure<T><HyperContinuations = true, HyperEdges = true>

end
def Graph<T = Ray> < Structure<T><HyperContinuations = true>
end
def Array<T = Ray> < Structure<T><HyperContinuations = false> = .acyclic.connected.consistent

end
def Tree<T = Ray> < Structure<T><HyperContinuations = true, HyperEdges = false> = .acyclic.connected.consistent
  // Tree has a single 'parent' on each vertex.
  static +def Vertex = super{initial: 1 Boundary{
    end: 1 Vertex,
    value: Boundary{
      end: 1 Vertex,
      value: Vertex.initial
    }?
  }} //TODO The Vertex.initial here should refer to the new value, not the old.
end
class Set < Structure
  normalizer = .unordered.unique
end

Loop = Array.Unbounded.orbit


class Iterable<T = *>
  for callback: (Args: *[]?) => *
    // Allow no Args, which is just iterating without using the variable
    //TODO: callback.parameter s = Array & Object, named at Object, .length etc. at Array; 'parameters' interprets as an array.
    //TODO + continue
    //TODO + return = caller.return
  end

  def $ = this !~= ^* //Then add any match at the beginning.

  def any => this.reduce(|) = this.unordered.first

  def compact = this{!= None}
end

class Boundary < Ray
  x: static = this

  end | vertex | ∙ : Ray
  edge | ⊙ : Edge
  continuation | ⊢ : static => ⊙⊢#{!= this}

  boundary
  // ? These arent right
  is_initial => ∙⊢ == this
  is_terminal => ∙⊣ == this

  {path: (((path?, "⊙"?)?, "⊢")?, "∙")?, "⊣"}{.}
    x = this
    path.reverse.for method => x = x[method == "⊣" ? "⊢" : method]
    x
end
class Edge < Ray & (⊣ | ⊢ | ⊢{.} | list): Boundary
  x: static = this
  //TODO .value is defined on the Ray which defines the boundaries on list? Or ignore that.
end
//TODO .every on ray iterates both ways., explicit filter for excluding. (ray -> .next).for
class Ray<T?> (x | value) < AbstractDirectionality
  dynamically for(: T) if T //TODO Should be T = static
  //TODO .value is everything on x except the Rays defined at #. And we need distinction between methods on Ray/x

  //TODO is .expand implemented for looped types, which assume .expand unrolls the loop?

  initial | ⊢ | ⊢{.} : Boundary = Boundary(∙: this)
  terminal | ⊣ : Boundary = Boundary(∙: this)

  is_first => ⊢#.some(.boundary)
  is_last => ⊣#.some(.boundary)

  // Allow syntax for traversing the initial side: '⊢∙⊣⊙⊢var'
  {path: (((path?, "∙")?, "⊣")?, "⊙"?)?, "⊢"}{.}
    x = this
    path.reverse.for method => x = x[method]
    x

  //TODO .expand only the boundaries, or everything
  //TODO .paths possible paths to take.

  //after/before/...
  //TODO .push which does vs doesnt override a possible terminal defined there.
  push

  expanded => //TODO Recursively expand

  // TODO this.quantities~{.unit operator unit} is different from this.quantities{.unit operator unit}~, one applies the structure before/after the filter.
  //TODO But you'd kind of want to overlap the types on x/value and the ray's methods. not require a .x. What do you do if x is an Iterable?
  //TODO Or if it's a number which already has equipped structure, prefer this structure, what if I want to overlay both?
  equip_structure | ~ =>

  context | & =>
  relative_context | && => //TODO Perhaps just context, relative context = just the ray.

  //TODO Is different from unique/compact of iterable, rename
  unique => this&{== this}.count == 1 //TODO Difference in filter to say on Iterable for on each iterated node

  //TODO .remove which preserves structure, or sever connectivity, or DPO

  //TODO What to do with T for Iterable ; they shouldnt be the same here
  // The entire context graph except for the current value ; "Complement, where the entire graph is the universal set"
  complement => (this& as T){!= this# as T}

  remove // Remove selection from context

  //TODO Returns superposition instead of an Array[]
  //TODO .next/.previous should be different delimiters, what is left/right hand
  //TODO keep_delimiter = false
  split {predicate: /* Should split, returns Ray @ the delimiter, with prev/next the two sides. */}(delimiter): //TODO split is a map, and respect equipped structure and keeps it.

  //group_by

  index (start = first) => start to this -- .length - 1

  v (count: Number) => this{##.count == count}
end

class AbstractDirectionality<T> < Iterable<T>

  // what about 0..10..20 // Goes to 20 through 10, relevant for graph
  // ..10 / 10.. Same as 10-> / <-10
  // Somehow 5..10 when used as a type is 5..10.reduce(|) by default?
  (a: this?) .. (b: !a ? this : (> this)?) =>

  loop | orbit (boundaries: T{})

  previous =>

  undirected | bidirectional =>

  static Connected // each Node is reachable from each other Node. (Going both forward and backward)
  static Consistent
  static Acyclic
end
class Iterable<T>
  next

  // Repeat this structure x times: Composing the structure x times
  * (x: Number) //TODO

  all => T(#: this)
  fill (value) => all = value //TODO Whenever a value is accessed, lazily add this = on top. (Any for would do this)

  //TODO Sorted/max/min along which dimension & what is the default dimension
  sort (dimension: AbstractDirectionality): static{~every .previous[DIMENSION] <= .[DIMENSION] <= .next[DIMENSION]} =>
  max (dimension: AbstractDirectionality (= .0 if T < AbstractDirectionality)) => reduce(acc, current => acc > current ? acc : current)
  //TODO Or something like that.
  //TODO Would to to call a method on the entries, so needs to be a callable
  min () => reduce(acc, current => acc < current ? acc : current)

  first => reverse.last
  last

  disjoint (b: Iterable)

// TODO If two arguments are passed, we step with 2 and fill both?
  //TODO Yield ray methods in context of for so you can to is_last for example?
  for ()

  //TODO Should allow for ~{}{} chained, without need to redo the ~. maps to &&
  ~ | filter {predicate: (x: T + iterator: Ray): boolean} => //TODO How to say filter applies here

  // TODO Structure altering mapping with ~ somehow
  //TODO Name for &+ iterator right?
  // Any variable accessed from this map, is mapped lazily (what about variables which are also used externally, then the mapping wouldnt work - you'd have to iterate over all to map)
  // Being part of .map, does a .copy on the variables in it when it sets their location to inside the map's structure (which is the iterable structure).
  map <T>{predicate: (x: T + iterator: Ray): boolean}(map: (x): T) => static{T: T}
  reduce | fold | foldl ()
  reduce_right | fold_right | foldr => reverse.reduce
  //TODO Reduce in Rays should go both ways?
  //TODO Cancel reduce.

  reduce (operator: (in T){T*[.] ==.instance_of (b: T): T}) => this.reduce (acc, current) => acc ? acc[operator](current) : current

  //TODO Mapping and reducing together?
  reverse: static
  unordered => choose Iterable{.every(this.contains(.)) && .count == count}

  pop_front => first.remove
  pop_back => last.remove
  push //TODO after/before/back/front
  //  push_before: (self, ...x: any[]) =>
  //          self.reverse().push_after(...x),
  //        push_back: (self, ...x: any[]) =>
  //          self.last().push(...x),
  //        push_front: (self, ...x: any[]) =>
  //          new self(...x).push_back(self),

  length
  // Since a graph's structure allows for branching and looping, it can be that length != count.
  count => length == ∞ ? ∞ : reduce(acc = 0 => acc + 1)

  empty => count == 0
  nonempty => !empty

  every (predicate: (x: T): boolean) map(predicate)~{== false}.empty
  some (predicate: (x: T): boolean) ~{predicate}.nonempty
  // Include equivalence graph, is there maybe a different syntax for which equivalence graphg to use.
  class contains //map == + .=== + .!= + .!==
  contains | includes <operator: (x: T): (b: T): boolean = ==>(x: T) some(operator(.)(x))

  partition (predicate: (): boolean)

  + (at: Integer) this[at]
  - (at: Integer) this[-at]
  ± | +- | -+ (at: Integer) this[at] | this[-at]

  [] //TODO Ranges, index

  // .flatten = .reduce(push_back) What did ruby do for different levels? flatten(1) or something
  flatten

  //TODO move operations

  unique
  compact => this~{!= None}

  //Boundaries check if == None and != Ray

  // Each step might be in a different version of the graph, Time vs Space
  // Start a quest to find the path
  to () => //Path to, when on array, all paths from all the points to x, equipped direction for a .min is the length of the path

  + () //TODO Object or expression + { }, or + property:, or block. & + a number to do the same as a[5]
  - () // Remove of move left x
  +- | -+ ()

  dimensionality //How to do this with different rays which can be equipped for different directions., or is it just this selected graph

  // These or not?
  intersection
  xor | symmetric_difference

  //TODO Sequential composition
  // If T is (previous: T): T allow. Which is the case for 1, +2, +3, +4
  // If T extends [] and not Ray, doesn't compose (grouped structures)
  , = (b: T | T[])

  // Allow Binary₃₂ = Binary₈[]₄
  // Uses count instead of length, since Ray/Graph²²² makes for sense as the size of the graph rather than each path length.
  ^ (count: Number) => this{.count == .count ? .count * count : count} //Allow this sort of chaining, overriding the previous count ==

  // Allow x: String[] = "String", Object, "String", Object
  as (: Iterable<R: ?>) => this~{==.instance_of R}

  //TODO .move?
end

class Hierarchy
  parent | previous : static? <- hierarchy -> children | next : static?

// On = of a ray, we keep the structure from both sides &=?

//TODO Equip Continuous; accepting Reals in [property], but not effecting .next

// Path is a function
//TODO Path implements ~= ; / ~= ^/.@ meaning files beginning with /.@
