// Maybe allow one to define syntax dynamically. (Would be awful for language versioning though, if I introduce something which clashes with other syntax)

//def Nothing
//end

def AMethod
  variable = 5

  def method
  end
end

// Options for generics
def Generics (T) (args)
  variable = args.5
end
def Generics T
   def constructor args
      variable = args.5
   end
end

// TODO What if a library defines Nothing, different from the one here. How to decide what is used, A newly instantiated variable or that?
// Single-line function
def Maybe a = Just a | Nothing
def Maybe(a) = Just a | Nothing
def Maybe(a)
  return Just a | Nothing
end

// TODO Pattern matched function names? Called instance_of
// TODO Is this used for anything other than numbers? You can at least dynamically get the name.
// TODO This is probably quite useful for meta programming, so instead of defining a loop and calling def in the loop, we
// TODO    have a single instantiation. -> Or the compiler needs to be aware of that there's a dynamic method def, and don't loop through it all.
// TODO                                 -> Probably want that anyway.
def 0-9.repeating
    return Number([method name]) // TODO: How to get method name; this.name? Or is name to often used by the user this.constructor
end
def "(0..9).repeating"."(0..9).repeating" // TODO: What's a nice syntax for this
  // TODO: Or define decimal as a function on number.c
end
// 0..9.repeating = 0..(9.repeating)
// x+y x+y.func you want it to be (x+y).func
// TODO So you want to be able to use variables within a function's name.
def NUMBER.repeating // TODO How to differentiate between NUMBER.repeating (arbitrary name) and the function.
end
def NUMBER // TODO differentiate between NUMBER and variable NUMBER; aka is it an overwrite of the variable or the thing itself
end
def Generics // The pattern "generics" TODO What does this mean
end

// Allow binary operators defined outside the classes?
def x: Number .. y: Number
end
Number.def ..(y)
end
Number.def .. y
end
def Number
  def .. y
  end
end

a.5
a[5]
a<5>
a(5)
// Are all these somehow the same?
a.5 a[5] are
a<5> a(5) are
// Are these two subgroups the same? (I believe I asked this question before in the Ruby writer project back in 2017)
a(5) is saying getting property 5 has some result.
// Complicated structures like a(3, 5) is simply a[arbitrary structure]
// TODO But what if we have static things defined on the function, or fields on the function
// a.property = 1
// a(5)
// you dont want a("property") to be 1.
// TODO
// a[5] is a on the vertex, and 5 being the property going through it. -> name
// a(5) is 5 on the vertex, and a being the property going through it. ->
// a(5) = 5[a] (= 5.a if a is a variable)
// a[5] = 5(a)
def Number
  def plus y
  end
end

x.plus(y) = y[x.plus]
x.rotate(y, z) = (y, z)[x.rotate]

def !
end
!x = !(x) = x[!]

y + 1 = y.+(1) = 1[y.+]
+y = plus(y) = y[plus] = y[+]

x = 1
this.x = 1
this["x"] = 1
"x"(this) = 1 // "Get the variable called x at (arg)" -> So "x" would be "All places where the variable x is defined"
// TODO Would you ever need to access this, or is it just an interesting semantic connection?


// Partially filling in arguments of a function.
def a arg1 arg2
end
const c = a(arg2: b)
c(d) // <-- uses arg1
def a 1 2 3 4 5
  // TODO How to allow variables the names of numbers, while still declaring numbers normally?
  //        -> It's just a different context, so something like global.5 is a number object.
end
a(3: c)(1 2 4 5)
a(3: c, 5: e)(1 2 4)
// TODO: What if another argument is added, then all the functions normally called, do as if they need to be called again.
//          -> Is this a problem, or should we use something special for partially filling a function. That's probably a better option.
a|3: c, 5: e|


// Something like a def for def. Which is just .property =
// TODO someway to say: This function is automatically added to every context. Some default object or something.
//      -> Same with =, static, this etc..
// TODO This circularly defines itself, how to support that?
def def name ...args
    [].name = args
end // TODO Maybe dont allow def like this. Complicates things like shifting around the order of func/variable definitions.
// You want something like undefined, if = is called on .undefined, it defines the property. That way we can have:
// No dont define it on undefined, just have it as default behavior
def = args
end
// a.property is now undefined
a.property = args
end
// a.property called undefined.=(args)
// which is the same as doing.
a.def property args
end

// TODO You want if without a .if to always reflect the upper-level if. Not a this.if? Generalized to?
// You want if similarly to be a function TODO Do you?
def if
end
// TODO So how does else work?
if a
else
end

def Generics (T = Default) args
   // Normal stuff here is like a static {} block
   // This is not true if args is on top like this. Need some way to allow for both.
   //   -> No not necessary, if it doesn't use args it's static.
   //   -> Similarly, .args if used anywhere in the "class", it's stored as the variable .args
   //      -> This way you also dont have these useless constructors which are only this.var = var
   //   -> Similarly, generics like .T are stored in a variable. Can it be changed? Yes?
   //   -> a<5> if a has more parameters, returns a function with one parameter filled in.
   variable = args.5

   // define subclasses
   static.Subclass <T>
   end
   static.def Subclass <T> // <-- generic overrides the context of Generics
   end
   // Allow Generics<T>.Subclass
   // What if we dont know T? Allow Generics.Subclass
   // What if T has a default and we want to match any. Use something like?? Generics<Unknown>.Subclass
   //  -> So we allow to access variables of a function without the function being fully initialized.
   //  -> How to determine what can be accessed? Statically accessible variables, but also when not depended on args.
   //  -> But we also want access to variables if we can access them at runtime. TODO

   // So stuff like this
   for a in b
     args. // uses .args so included
   end
   b.for a
     args.
   end
   // TODO Not the for(int i) stuff like other languages but stuff like.
   // 0.add(+1) gives you a ray which has a +1 direction selected.
   // Something like a 0.next(x => x + 1), or some other way of doing this easily.
   // 0.fn(+1), 0.ray(+1): "Equip 0 with a +1 ray"
   // .ray(+1) equips .previous() with !+1 which is -1
   // TODO Allow unary functions like +1, for closures which acts as a binary with the same name x+y -> How to do that
   // TODO .if acts as a .filter
   0.ray(+1).if(x => x < 10).for i

   end
   // Which could be shortened to
   0.ray(+1).if(< 10).for i
   end
   // also allow
   0.ray(+1).if(10 >=).for i
   end
   // TODO How to differentiate < 10 from .<10 function, or how to do these arbitrary names properly


   // There is the ambiguity of whether this should be saved as static or not.
   test = 6
   // Could give one the ability to reference "Generics" through a keyword "static".
   // so .static is the class.
   // Analyses would yield no dependence on previous instructions (or it will) and then we can take it out of the constructor.
   static.test = 6
   // How to get defined methods on the class if we don't know args.
   // Because you want to allow things like
   args.for a
     // What if I want to call a out of order -> Now it wouldn't work, but for a class you'd want to be able to.
     // Not in this case, but calling out of order, means the order of functions being defined must be done first.\
     // If the variable is already defined, it uses the order.
     // There might not be an order which allows you to call it? Or can we always put the method up first.
     // -> We might have a situation like


     // -> Many defs of a function, take the last one. Have some console warning for the dead code if it isn't used in between.
     a()

     // TODO: How to put this in the other context. Why isnt 'this' reassigned?
     this.def a // TODO How to use the variable here for def. -> Allow, but it overwrites the variable a in the context.
       b()
     end
     this.a =
       b()
     end
     this.a = <T> args
       b()
     end
     this.a = b

     // This .for, and = accept blocks like "end", how does this work exactly in function parameters?
     // Ruby uses &block.
     // Difference between a block accepting with a function parameter, vs an argument of that block.
     // Block is just a callable function, so it's simply the last parameter.
     args.for args a
     end
     args.for(args) a
     end
     args.for -> a
     end
     args.for do a
     end

     // If .for has no other arguments we allow
     args.for a
     end
     args.for a b = 5 // TODO How is this default separated from a variable declaration, might need something like "do"
     end
     // Differentiate a b = 5 from variable declaration, as in b = 5, not a, b = 5

     def for f: Function
     end
     def block arg f: Function
     end

   end

   def a
   end
   a =
     b()
   end

   // can keep doing generic stuff.
   def <TT> arg2
   end

   // __call__
   def (args)
   end
   // or like this
   def () args
   end
   def () <T> args
   end
   // ambiguous with .() (x y z)
   // vs.            (x, y, z)
   def a(args)
   end

   // Like haskell?
   def x + y
   end
   // or normal
   def + y
     this + y
   end
   // Allow unary construction with arbitrary special characters.
   def +
   end
   def @
   end
   // What if a thing like parenthesis is used?
   def ( x y z
   end
   result = ( x y z
   result = ((x y z)
   result = ((x, y, z)

   // g.(()
   // ambigious with
   def (()
   end
   // Arbitrary names are allowed so spaces should be possible too. This arbitrary-ness will not work well with the parser in text.
   def " "
   end
   // g. ()

   // How to decide where the "this" cutoff is, is it the whole program, is it one-level up or??
   // "this" is just a variable but where is it defined?
   this.variable
end
def Generics T args
end
// Allow <> () wherever, [] too?
def Generics <T> args
end
def Generics <T> args < Inheritance // What does function inheritance mean, just get the context, sure, but what about additional logic in there?
    super <- is it the "this" of the inherited structure, or is the return value for a function?

end
def Generics <T> args < Interface<T> // First argument already filled, so dynamically we want to allow for checking what we can define in the function without certain args.
end
// TODO Generics <T = Default> args, how to know when the first argument is the generic type?

// TODO This needs to be better, how does it fit nicely in the normal syntax of defining a class/function.
// Enums when .OR is used.
Maybe(5).switch
  Just a 1
  Nothing: 2
  [type]:
  [type like Just a if a > 10]:
  [type like Object] Object
     x = 5
     y = 10
  end
  Object(x: 5 y: 10)
  Object(x: 5 y) if y > 10
  Just 5
  Just a = 5: // Automatically bind a
  Just 5..10 =>
end
if maybe == Just a = 5..10 // a =, is a name attached to the type, == defaults to using instance_of if a type? TODO what if type == type?
end
//if Just 5..10 = maybe
//end

do
end.while()

while()

while maybe == Just a = 5..10

end

// What about infinite loops.
// What are function decorators?
// What about graph-like control-flow
// What about monkey-patching, vs overriding the whole variable. Monkey patch could be without args, even if the original function has them.
//      -> What is monkey-patching a function?
//      -> "patch instead of def?"
// How to differentiate return value of a function, vs returning the Instance as a Function definition.
//      -> Default return is returning "this" -> For normal functions either "this" meaning the class, skipping the local context. Or not, and use normal return semantics.
// Variables accessible at runtime how? What decides we can access it.
// Closures & inline-functions (similarly methods are closures with environment of the class)
// Defining a bidirectional ray on a class/function. Methods and properties are one-way.
// Defining boolean and other structures
// For Type definitions like data Maybe a = Just a | Nothing, what decides that Just exists, what decides that I dont need to evaluate it? Just that it doesn't exist?
// Assigning to a variable in a new block; a = 5; { a = 6 } ; Is it a new variable or assignment to the other one?
//      -> In most languages in a def block you'd be able to access it not change it. You need a thing like "this", but for 'it's already defined in an arbitrary different context'
//      -> But in something like an if block, you'd want it outside the block by default?
//      -> Or explicit local value? Would be overused for functions, so it might depend on where the def is? Might get confusing.
// <> For partial assignment of a function. Partial assignment how does that work with arbitrarily structured. Or does it only work on Array inputs.
// variable do end, like static do end, or def static like monkey-patching to get a block where "something like this" is linked to static.
// static variables are also accessible as a parent context, not just static.
// which block "returns"/"break"
// Arbitrary structure named variable assignment. (& function parameter)
// instance_of in inherited structures, how does that play into the usual instance_of