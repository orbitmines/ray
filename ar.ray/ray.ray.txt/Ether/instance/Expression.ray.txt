
class Expression = String // Any string is legal syntax
  protected def generate_ast
    delimiter = "/" | "." | \s | \n


  end

  ast = generate_ast
  &= ast

  def eval => *

  end
end

//TODO Default first initialization is, if is None, overwrite, otherwise &=, otherwise = if = is provided.

// Program is control-flow, with associated contexts
// Want to be able to convert program back into a string expression, but it needs to decorate the contexts somehow (which is necessary for Access)
// &caller = {ref to object} or something to stringify the expression would require object refs accessible too.
// Then it would be things like
// A + B + C from different context be
// (
     &caller = OBJECT_ID
     A + B
   ) (
     &caller = OBJECT_ID2
     + C
   ) //TODO In this case + C needs the context of A+B, not the parent local context above A+B
// Quests should be spawned to resolve lazy expressions/programs
// Quests spawn to possibly fill cache of history values (if they're used often etc.. other considerations)

//TODO caller is the method in a class, since caller is a location, it has .parent on it defined on it which is the class.
//TODO caller -> .parent == Some player except for the last one which doesn't have a .parent

// The program is similar to history and should probably be the same thing.
//   -> History needs to be aware of caller as well (and the version at that particular time).
// These object references are to a particular version of that object. (Don't want to get the recent version here unless dynamically variable?, probably still not)
//TODO OR require eval before committing to expression string with object_id
//TODO Conditional edge
// History = Program
Result = Waiting | Intermediate(function: *, result: *) | Final(result: *)
//TODO Get the program to arrive at a particular var: var.func**, how to get intermediate results after executing. (Calling gets you a program which you can move forward with intermediate access to variables)

//TODO What if other things apart from the vertex are changed? Keep track of that. What if other vars are relevant, need to keep track and store those in history too? (Like a random seed), want each thread to be deterministic, but allow option sto say: run again without those set parameters.
class Program = Ray<Vertex>
  //TODO We might have a program pointer which .expands into other programs like function calls, we want to context of "we're handling this .expand" + "we're here in the .expand". So many pointers to program at ##.

  //TODO This is for a program instance, Program object vs program instance pointer. (Both are of type program?), you can spawn new instances of the same program with the same program state etc..
  context: * //TODO Variables accessible in program, context.parent etc.. is checked when accessing variable.

  //TODO What if the program mid-execution updates to a new version, how to handle that?

  static Vertex = {}
  static Edge = {
  }
  //TODO Vertex only used for cached evaluation results,
  //TODO : AND importantly intermediate results, -> So function continuations should define what to do with intermediate results.
  //TODO Where are the intermediate variables of the function execution stored?

  //TODO Edge encodes another program applying things like &caller = OBJECT_ID2, + C
  //TODO The initial of the edge program is the VERTEX result before the edge definition.
  //TODO What is a terminal/initial program mean?
  //       -> The starting vertex, terminal is the terminal vertex. (Like a finally this, effecting the return)
  //TODO Everything to do with a particular variable is all grouped in a single .expand, so that each successive top-level vertex is a new access into the program context.
end
//TODO UUID-s built up in a history version file are Node: Mac address that we generate for an instance based on the pub-key?, timestamp is the last edited time of that object.
//TODO ; does not change the selected context to + on.
//TODO Newlines () () should apply to each-other. or pending operations should too.