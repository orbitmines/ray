namespace Network

              // ETHER
  DEFAULT_PORT = 37839

  class IP
    static NUMBER_OF_SEGMENTS => Decimal.Positive
    static SEGMENT_LENGTH => Decimal.Positive
    static NUMBER_OF_BITS = NUMBER_OF_SEGMENTS * SEGMENT_LENGTH

    static +def Segment
      static Binary = Binary.Positive{length == SEGMENT_LENGTH}
    end

    static String = static as String

    def segments => Segment[]{length == NUMBER_OF_SEGMENTS}

    def binary_form => Binary.Positive = segments as Segment.Binary[]

    // CIDR notation
    def / prefix_length: Number{0 <= . <= NUMBER_OF_BITS} => static
      return this if prefix_length == NUMBER_OF_BITS

      binary_form = this.binary_form
      binary_form[prefix_length..] = 0 | 1

      binary_form as Segment[]
    end

    - = .. // Allow '-' as a range operator.
    //TODO Range operator.

    static class v4 = segments.join(".") < IP
      static NUMBER_OF_SEGMENTS = 4
      static SEGMENT_LENGTH = 8

      static Segment = Decimal.Positive{< 2^8}
    end

    static class v6 = (left: Segment[]).join(":")?, zero_compression: defined_segments.empty ? "::" : "::"?, (right: Segment[]).join(":")? < IP
      def defined_segments = left, right
      dynamically assert defined_segments.length (zero_compression ? < NUMBER_OF_SEGMENTS : == NUMBER_OF_SEGMENTS)

      static NUMBER_OF_SEGMENTS = 8
      static SEGMENT_LENGTH = 16

      static Segment = Hexadecimal.Positive{length <= 4}

      def segments = left, 0[]{length == NUMBER_OF_SEGMENTS - defined_segments.length}(), right
    end
  end
  IPv4 = IP.v4
  IPv6 = IP.v6

  Port = Decimal.Positive{< 2^16}

  class Socket
    static class Address = (ip: IPv4) | ("[",(ip: IPv6),"]"), (":", port: Port = DEFAULT_PORT)?
      protocol //TODO
    end
  end

end

+= Network

// Allow string CIDR notation
[IPv4, IPv6].for IP
  def String{==.instance_of (ip: IP.String) + "/" + (prefix_length: Decimal.Positive{<= IP.NUMBER_OF_BITS}.String)}
    def as :== IP = ip as IP / prefix_length
  end
end

+def Node
  static class Remote
    //TODO All object access go over network, and backup it in a local copy, what if that local copy is already defined somewhere?
    //Remote .location might not know about our copy, so how do we do remote_variable @ local
    //TODO Settings location to an instance, should say: anywhere in this instance, I don't know where. So if it's @ some_specific_location in local, it should still go to this method?
    //TODO What if the value is stored at a location, but we're looking for something which is at an unknown instance? But with particular structure?

    // If we want the local reference to a particular value, we don't consult remote.
    def @ instance: global.instance = instance[location]
  end
end
