// Location
- Locations differ slightly from traditional file systems:
  - There can be many items (files) defined at a single location.
  - Any location is both a directory and a file; it defines both values and a (hierarchical) structure.
- Alternate values to mirrors than what's currently there:
 - Randomizer: mirror to collapse to a particular value not the probability.
- = is defined on the variable, since the variable is location aware.

// Networking
- Managed items by another instance (mirrors)


// Equality/Equivalence
- == usually ignores location, what if we dont want it to. Do we use ===? OR something more intuitive?

// Quests
We could have equivalence graphs which are infinitely generating, how would we deal with a simple check then?
- Quests: Loading partially (in/out-of-order) + reading from disk

// Writing compiler optimizations
// dead code after return if there's no goto to a label there.

// Transactions & dynamically

// Language features
- -- / space false, true .map(!)
- ~~
Like '--', the operator '~~', wraps around an entire
array = [1, 2, 3]
array ~~ .[1] = 'B' // returns [1, 'B', C]

   (0 -> +1){< 10}.for i
   0{< 10}.for i // Since numbers are by default equipped with the numberline, and 0 is not real, but the Decimal.Positive.


confidential.read none.write mac_address: Binary.Positive{length == 48} =
  secure Binary.Positive{length == 47}.random ~~ .[6].push_after(1)

