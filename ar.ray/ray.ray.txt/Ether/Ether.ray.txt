global.player: Player? = external
global.instance: Instance = external
global.Ether: Instance = external

+def Node < Entity
end

class Item
  // The known locations this item is referenced. This could be properties of an object, or a location in a World.
  location: Ray = inventory

  // Every item has an inventory defined on it: '<-' is parent directories, '->' are child directories. Loops allowed.
  inventory: Ray = Ray(this)
  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    speculative if<assume: false> current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end

  visibility => Entity = "local"
end
class Entity < Item

end

class World
end

def Instance
end

def Player
  // The known instances currently running this player.
  instance: Instance

  +def location
    // When filled, this indicates that the provided instance is rendering this location.
    primary: instance?
    dynamically assert @{.primary == primary}.count == 1 if primary // Only one primary location per instance.
  end
end

// "local" means only on the local instance. (Not even local child instances)
+def String{== "local"}
  def as :== Entity = Entity{== global.instance}
end
// "private" means any instance running this player. Note that any backup server, like the central Ether server, has
// that property. Backup servers are configured using //TODO
+def String{== "private"}
  def as :== Entity = Entity{== global.player || == global.instance}
end
