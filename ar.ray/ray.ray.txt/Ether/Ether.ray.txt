global.player?: Player = external
global.desktop: Desktop = external
global.Ether: Server = external // TODO ether.orbitmines.com

// Everything is an Item, and possibly an Entity.

def Visibility = InheritFromInventory | Entity

//TODO You can have anything with really long values, which don't need to be loaded directly, but can be loaded partially.
//TODO This partial loading should also support encodings which can be decoded partially too.
//TODO Or partial downloads of arbitrary parts of a file. (Allow access the parts out-of-order if present)
def Item
  // TODO history could include When it's used, how it's made, how it's discovered, how it's constructed.

  // Items require Quests ; In order to find items you need quests.
  obtained_by: Quest

  //
  issued_by: World
  certificate: Certificate

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  visibility: Visibility = Visibility.InheritFromInventory // = Entity{==.instanceof Player}
  // TODO A program of possibly entities that are allowed to see this. Things like private servers which are allowed to see it. (Or the local server) - Can also include things like 'within renderdistance'.
  // TODO, Want to add things like : has been at this location in this world before for instance.
        //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item): So has this type of item, then it's visible.


  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
  def as :== Map
    // TODO Perspective switch to a 'high-level overview'
  end

  def as :== World = this ==.instanceof World ? this : TODO
    //TODO: How does 'World' differ from structure the item is made of.
    //TODO: World might not necessarily be accessible (Say the hidden dynamics of some function of some language)
    // TODO Internal structure of an item.
  end
end

+def String{== "public"}
  def as :== Visibility = Entity{true}
end

// TODO You want to say, have a world in your inventory, which is your desktop. Which contains items. Those items are not directly in your inventory? But they can be put there.
def World < Item
  // Known servers which this world runs on (TODO Others might be discovered later, so .servers might be non-halting)
  hosts: Entity

  // Internal dynamics -> Want a primitive in .ray to be a dynamic space.

  // Split into two groups: Spaces with arbitrary propagation vs limitations:
        How do you make spatial propagation hard/limit it in a distributed sense when usually one can just skip ahead programmatically?
        -> Similarly how we make item copying expensive/impossible. Scarcity of the items.

  spawn_location: Location

  // TODO, An entity should be a graph within the graph, both of those shouldn't interfere with each other. (As in effecting .next)

  entities: Entity
  //TODO Might want to tie a quest to a location too.
  quests: Quest //TODO Shouldn't conflict with fields of other things.
  //TODO: .quests{active | completed} TODO: Requires .filter etc. to be defined on Quest, which it should by default? Because Many<>

  // TODO World generation vs world rendering, in certain cases world rendering would be similar to world generation.

  //TODO What about behavior dictated by the world/server: These things are automatically shown, these things not.
end

// Spatial Propagation
// - Separate graphs for moving pieces?
// - One way of doing 'air you can move through' Split the graph one is moving into, and knit it back together on the opposite end of the structure that's moving.
   // Does disallow overlapping structures within the same space.
// - Or something more inspired by physics, based on the structure that's there in the graph, allow/disallow.
    // More spatial structure around matter
    // If something like an arm is attached, the further from the attachment the faster it has to move
// - World only has update events, you want those to be massively parallel, so what can influence what? -> What would actual execution on a GPU look like, how much does having it in a graph impact performance?
//

// TODO How does a location work if it's a dynamic space?
def Location < Item //TODO = Ray of World OR: You want Location to be more abstractly, a subregion: subgraph - which could be a specific location, of a World. It could also be a description of surroundings, which is not yet certain where exactly in the world that is.
  world: World //TODO Could be many: it's in one of these worlds.

  //TODO Location too has a visibility, to whom am I broadcasting that I'm here.
end

def Quest < Item
  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  // - Effectiveness rating -> In the case of effecting other items.

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate?: Certificate
  end
  def active = !completed
end

def Map
end

// TODO Items arranged in a particular way make another item. Something like = Hypergraph<Item> or it's a primitive item.
+def Hypergraph<Item> //TODO Hypergraph here? -> Item as Hypergraph<Item> implemented.
  def as :== Item
  end
end

def Inventory < Item
  path: Item[]
  // TODO: Visibility should inherit from top-level parent Directory/Inventory if not set.
  def () => Item{visibility: Entity}
    item = sub() //TODO Support sub(), indicating that the method still needs to be implemented.
    item.visibility = path.map(.visibility){!= Visibility.InheritFromInventory}.last
    //TODO: Might have settings of certain servers to backup the player information to.
    item
  end
  access: Entity //TODO Configure access for each item/dir.
  def `dir: Item` => Inventory = Inventory(path = (path, dir))
end

class Entity < Item
  inventory: Inventory
  def quests => Quest = inventory{==.instanceof Quest}

  def delegate type
    def `field: *`
      this.def `field` => type = inventory[field]()
      this.def `field`= value: type = inventory[field] = value //TODO Should automatically implement &=, |= as well.
    end
  end

  delegate name Name
  delegate desktop Desktop

  def world = location.world
  //TODO What if you only want to broadcast a particular part of your location, say the world it's in or?
  delegate location Location // TODO This again is Many<> so it's a superposition of locations, and visibility because Location = Item
  +def location //TODO Allow this syntax.
    primary?: boolean //TODO Whether this is the location we're actually currently rendering on screen.
  end


  // A world might live on many entities/servers
  //TODO A player, or any entity can (co-)host worlds
  //TODO : From the perspective of this entity,
  hosting: World //TODO These worlds should come from an Item in the server's inventory = is just (inventory as World){visibility = ??}

  //TODO Specific parameter types can be enforced using Entity instanceof SomeOtherEntityWithConstraints
  def `world: World` => Entity{name?: Name, location?: Location}
    return this +.overwrite { // TODO Support +.overwrite as opposed to adding the results of the two to each-other. Type-checking should recognize the +.overwrite is defining at least the thing before the +.
      inventory = this.inventory[world],
      name = this.name{issued_by == world}
      location = this.location{.world == world}
    }
  end
end

def NPC < Entity
  //TODO Defines dynamics in a World
end

def Player < Entity
  //TODO: You want to be able to host a server as an item to a world, with some visibility.

end
def Organization < Entity
end

//TODO Some server, which holds the 'first discovered by X' status, and issues certificates for that./
def Server < NPC
  //TODO Server might be behind some nameserver, delegating to many other servers.
end
def Desktop < NPC, World

end

def Name = String.Finite < Item
def Certificate
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end

//TODO; Require domain names registers on @"orbitmines.com" to be verified
// TODO; Allow circular using.
//TODO Uploadable public packages to .@name, default to using player names for this. register other organization names for this too.
// using .@"ether.orbitmines.com".UI, <TODO Version>
//TODO: If working in some folder, automatically change versioning numbers to the new ones, if the file is changed.
//TODO Should work with the versioning system somehow? another parameter here the version, which the IDE supports for automatically getting
def using at?: Entity = global.Ether, path: (inventory: Inventory) => Inventory
  environment = caller

  def eval inventory: Inventory
    item: Item = path(inventory)()
    //TODO eval item
    //TODO Only allow certain things to be imported/changed by certain imports.
  end

  //TODO; If defined in player.inventory, define super() to call the original functionality.

  //TODO; Check if version exists on desktop if configured for remote, if it does use it.

  eval at.inventory if at // Load
  eval desktop.inventory // Load default settings
  eval player.inventory // Load player overwrites
end