// Call by value vs reference?

//TODO How to support [None, None] if .next is None is those. ~ yields a structure equipped on None, so it's not just None. So it needs to be exactly None, not with structure.

// unless if !

var === var is share a location in common, since there are both new variants of the variable with new superposed locations



                                // When editing inside a double ((, force ((+TAB to turn into a (( (double << might be used for subexpressions.


//TODO Allow [RANDOM JUNK, TYPE, RANDOM JUNK, TYPE] to be castable to TYPE[]


// Support generators. OR Automatically convert into a generator if something will be returned.
//  (Intermediate result basically)
yield & var



//TODO What about syntax which is more contextual


// TODO .push_back on None makes a new array with 1 entry

//TODO .copy implemented, as not being bound to the .history .last version. But a new branched version.

//TODO Reverse .keys and .values
//TODO Things like .map on variable*, needs to be thought through, what is actually on *
// * is Iterable<(key, value)>


//TODO Needs like an example of 2D/3D world with yaw/pitch on location, stored as arcs in a continuous space then discretized by some things like elementary lengths and other things.
//TODO What if that's derived from the space, if space is non-euclidean it's different than a simple coordinate system

//TODO Default of an object is only loaded if accessed, so we can have circularly defined defaults.

// Synced object to other locations; which format (normalizer) do they use.

ambniguity of types like String[], String[], defined in dependent type on the first/lkast arg, B = [] if A == ., & A = [] if B == . ; this is circularity, unless they both share the same condition, that should break circularity.


//TODO If there even then are some that cannot be rolled back, it's just not accessible in dynamically.
//TODO Or if dynamically the speculative if branch change, if resources are dedicated to that if branch.
    sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last
    //TODO Could also automatically rollback previous changes of &=
    dynamically sub.location &= location.copy().push_back<edge: .value = property>(sub).last
    // equivalent to
    dynamically sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last

//TODO Allow {(): boolean}

// KV pair with everything delegated to value, so you can do ==. (separate class like TransparentKV)


// Superposed values hold their origin.
//   -> The result should be refinable, "now I know it's true, so what's the result".
// refined to 'true', any effects caused should be reset back. -> Need some way to register for nonrollbackable events; a new value has arrived, -> a new version
//TODO With a label?
// Carry program pointer of which value/state effected it, how to access this variable if it's not defined?


// Ambiguity: If all methods on an instance are on the static class, what happens to () and other things which are already defined on Class? How to access them? (Single default method defined on class, which wraps the actual object fully)

//TODO Infinite loops like location.parent, circular, map to None if detected.


//TODO Require other structure than the typical x.method(y), but higher-arity for instance; Also a structure where x&y aren't filled, instead of just a (x) => x.call(ALREADY_FILLED_VALUE)

// .reduce(|) TODO How does it work to pass a binary operator to a reduce which has accumulator and current as the two arguments
//   -> If default is not set for accumulator, the initial value is the first in the array.
//   TODO But how would you?: For .reduce, require a default value for accumulator, how to indicate that?

//TODO You want something like ray[500..999] = 500-length array, instead of setting all those values to the 500-length array. How to differentiate

//TODO If big instanceof iterables are used, like worlds: World = entities{==.instanceof World}, store it separately, don't always filter through all those entities

// 0..9.reduce(|) = (Decimal.Digit) 0.value.context.reduce(|) ; .superpose an array, namely the digit defining 0. -> Then could also have the digit values link back to the superposed object or not?

// <=; node > itself or node < itself, we're in a loop (or repeated value which we're forced to see as the same, or we're not comparing using the difference we have access to - this 'number'line)

//TODO Yield ray methods in context of for so you can to is_last for example?

//TODO Variable call by reference/value per class, and also manually possible?


// TODO - Ambiguities
- // But we want == boolean, as in, is exactly the boolean type. false != false | true, but you also want false | true, to superpose the func.
  // -> Components somehow useful, false &+ true vs false & true

// How to save non-class parameterless functions get executed immediately when called without ()., even optional parameters -> what if it returns a callable functions how to disambiguate
// If a method doesn't exist on the variable, but it is castable to something which does define that method, say boolean and &/|. Converting it to that value and calling that method should be possible.
//   |-> Ambiguity if there are multiple casts to which that method may be applied.

method () **: Terminating



// TODO - Examples + Allowances

// Allow maybe == Some a: 5..10
(maybe == Just a: 5..10).while
   maybe = Just 5
end

// Allow newlines after a |, so we can do things like
func
  | line1
    line1-2

  | line2
    line2-1

  |

/path is string form too

// Allow multiple changes which make it adhere to the type, as long as nothing is accessed in between
//TODO If multiple edits makes it type compliant allow as if a single transaction
// Allow 'def Ray<T = Ray>', Meaning, T is unknown, but it is a Ray.


location //TODO Allow this syntax. => Should be dynamically there.
  primary: Location



// Allow +=  equiv to '= .+ b', so allow '= .method.method2'
// Allow  Ray<T = Ray<T>>


// TODO - Features
// Evaluating infinities

  // TODO .unrolled() -> Allows loops by defaul


