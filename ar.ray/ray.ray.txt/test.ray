// Call by value vs reference?

//TODO How to support [None, None] if .next is None is those. ~ yields a structure equipped on None, so it's not just None. So it needs to be exactly None, not with structure.

//TODO For grammar matching make a "resolve ambiguity" func ; match to both cases of the ambiguity..

// unless if !

var === var is share a location in common, since there are both new variants of the variable with new superposed locations

? as sorry, as it just fills the type

// Type with additional structure like
blocks: Program ~ (\s, \s)[]
//TODO is not
blocks: Program(\s, \s)[]

 // When editing inside a double ((, force ((+TAB to turn into a (( (double << might be used for subexpressions.

choose Number
choose 1 Number

cursor: Program
// To indicate to the runtime & compiler, that it can arbitrarily pick (and map) a single value among a collection and then manipulate it. Note that this 'arbitrary picking', the runtime can have access to the running function, its context and possibly some model it has on function execution which determines what it picks; It doesn't have to be '''purely random'''.
while cursor{next} != None
  // OR choose (X) is of type (x: *): boolean so
  cursor = cursor.map{next}{choose 1}
    if .expand !== .
      .expand
    else
      // Program logic
      . (.next if .next) //TODO Only .next if has a .next HOW?


//Depending on the context, it might even prompt the Player if its context is deemed necessary for that.
var = 2
[1, dynamically var, dynamically var].map{choose 1}(*10) // [10, 2, 2] | [1, 20, 20]
{choose 1/2} // 50%


A (B, C)
A (choose, choose 1)

//TODO If None !";"⊣ should return true.

//TODO Allow [RANDOM JUNK, TYPE, RANDOM JUNK, TYPE] to be castable to TYPE[]

//TODO Optimize to go back and forward with abstract objects vs rendered screen, optimize for what the client wants. (more accessible fvs speed vs compute use)
// --> Client gives preferences, Networked.
//What about optimizations problems, how does one code that in?
// Any Ordered
// https://pyddm.readthedocs.io/en/stable/ ; efficient exploration
// "finding the tradeoffs"
optimize x: Number
//TODO Different coded priorities, or optimize priorities too? how
optimize y: Number
optimize space_used
optimize time_elapsed
maximize/minimize
dynamically assert x + y <= 10

+ Ray? should still implement .next for Ray, but just return None.

// Support generators. OR Automatically convert into a generator if something will be returned.
//  (Intermediate result basically)
yield & var

[1, 2][] vs (1, 2)[] = [[1, 2], [1, 2]] vs [1, 2, 1, 2]


//TODO What about the model it's constructing (effectiveness) vs (how long it took to make) so
// minimize effort, maximize effectiveness
// minimize spatial_complexity & time_complexity

//TODO Want to say: Can start out with an implementation which works but is slow, and optimize it over time. Dynamically that means ; how often sometimes is used etc..

//TODO HOw to encode different prefernces: Saying this particular implementation of the optimizer prefers THIS.
if x > 100
  prefer minimize y
 to define that?

allow capability1
allow capability2
allow capability3


//TODO What about syntax which is more contextual

// Allow .for {from, to, name}, and [a, b]

class Example
  next = () =>

x = Example() &+ Ray()
x.next // Does (Example & Ray).next
x: Ray
x.next // Does Ray.next
x: Example
x.next // Does Example.next

// Editor, can be rewritten into preferred level of description, like there exists instead of #.some

// Every < X[] implements .Unbounded on static.

// TODO .push_back on None makes a new array with 1 entry

//
return A, B if // returns A
return A, B -- if
A, B if // adds B after A if

//TODO .copy implemented, as not being bound to the .history .last version. But a new branched version.


=
//TODO Reverse .keys and .values
//TODO Things like .map on variable*, needs to be thought through, what is actually on *
// * is Iterable<(key, value)>


//TODO Needs like an example of 2D/3D world with yaw/pitch on location, stored as arcs in a continuous space then discretized by some things like elementary lengths and other things.
//TODO What if that's derived from the space, if space is non-euclidean it's different than a simple coordinate system

//TODO Default of an object is only loaded if accessed, so we can have circularly defined defaults.

// Synced object to other locations; which format (normalizer) do they use.

ambniguity of types like String[], String[], defined in dependent type on the first/lkast arg, B = [] if A == ., & A = [] if B == . ; this is circularity, unless they both share the same condition, that should break circularity.


//TODO This will be difficult to implement, but it's very powerful:
//TODO Requires all functions like &= to be rollbackable (through history probably) or -= in this case if possible. -> Compiler uses history if necessary for these features.
//TODO The -= needs to check possibly changed locations here. but starting with that location
//TODO If there even then are some that cannot be rolled back, it's just not accessible in dynamically.
//TODO So if any variable (implemented with observers again) changes so sub or location, we run/rollback.
//TODO Or if dynamically the speculative if branch change, if resources are dedicated to that if branch.
    sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last
    //TODO Could also automatically rollback previous changes of &=
    dynamically sub.location &= location.copy().push_back<edge: .value = property>(sub).last
    // equivalent to
    dynamically sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last

//TODO How to filter from programs just Program{== (): boolean}, or do we do {(): boolean}


//TODO instance_of which respects .expand and looks into it, vs one that doesn't. Not just instance_of, all of them


//TODO Only monkeypatch within some context, like equiv graph for only a specific context.


// KV pair with everything delegated to value, so you can do ==. (separate class like TransparentKV)


// Superposed values hold their origin.
//   -> The result should be refinable, "now I know it's true, so what's the result".
// refined to 'true', any effects caused should be reset back. -> Need some way to register for nonrollbackable events; a new value has arrived, -> a new version
//TODO With a label?
// Carry program pointer of which value/state effected it, how to access this variable if it's not defined?


// Ambiguity: If all methods on an instance are on the static class, what happens to () and other things which are already defined on Class? How to access them? (Single default method defined on class, which wraps the actual object fully)

//TODO Infinite loops like location.parent, circular, map to None if detected.


//TODO Require other structure than the typical x.method(y), but higher-arity for instance; Also a structure where x&y aren't filled, instead of just a (x) => x.call(ALREADY_FILLED_VALUE)

// .reduce(|) TODO How does it work to pass a binary operator to a reduce which has accumulator and current as the two arguments
//   -> If default is not set for accumulator, the initial value is the first in the array.
//   TODO But how would you?: For .reduce, require a default value for accumulator, how to indicate that?

//TODO You want something like ray[500..999] = 500-length array, instead of setting all those values to the 500-length array. How to differentiate

//TODO If big instanceof iterables are used, like worlds: World = entities{==.instanceof World}, store it separately, don't always filter through all those entities

// 0..9.reduce(|) = (Decimal.Digit) 0.value.context.reduce(|) ; .superpose an array, namely the digit defining 0. -> Then could also have the digit values link back to the superposed object or not?

// <=; node > itself or node < itself, we're in a loop (or repeated value which we're forced to see as the same, or we're not comparing using the difference we have access to - this 'number'line)

//TODO Yield ray methods in context of for so you can to is_last for example?

//TODO Variable call by reference/value per class, and also manually possible?


// TODO - Ambiguities
// Evaluating |/&, how
- // But we want == boolean, as in, is exactly the boolean type. false != false | true, but you also want false | true, to superpose the func.
  // -> Components somehow useful, false &+ true vs false & true

//TODO Bidirectional function like ray but only single step: l <= (x) => r, ambiguity with <=

// args.for(args) a could mean args.for(args).a, instead of defining a block. Or something like args.for a b = 5, with the default '= 5'
// statement if expression != statement.if.expression, similarly if expression then a else b
// what if I do something like () => boolean, which returns a boolean, the return type is not false | true, as in 'a boolean', but it's 'the type boolean'.
// Referencing a parameterless constructor, can be both the Object() or Object, since it could be interpreted as a property.
// Somehow the constructor another method thing so that everything can be passed on to static, but then that would have the same problem.
// The boolean definition false, true = needs to be on static. Which is done because the .false/.true values never change based on the type definition.
// If a method doesn't exist on the variable, but it is castable to something which does define that method, say boolean and &/|. Converting it to that value and calling that method should be possible.
//   |-> Version control: if that method is then implemented by a library, a user should be notified the functionality changed (probably unexpectedly)
//   |-> Ambiguity if there are multiple casts to which that method may be applied.
// classes without parameters are now called their constructors instead of requiring a ().
// ~= ^1,1 ambiguity with ^3 as a number or other numbers, it should prefer ^ starts_with because of ~=. There's no ambiguity if we use ^[1,1] -> It's not a numbe.r



method () **: Terminating



// TODO - Examples + Allowances

(if Keyboard. ↑ | w .pulsed) <- selection. y ?? hierarchy (
      Keyboard.ctrl && Keyboard.shift => // Skip group & Expand selection
      Keyboard.ctrl => // Skip groups
      Keyboard.shift => // Expand selection
    ) -> (if Keyboard. ↓ | s .pulsed)

// Allow maybe == Some a: 5..10
(maybe == Just a: 5..10).while
   maybe = Just 5
end

// Allow newlines after a |, so we can do things like
func
  | line1
    line1-2

  | line2
    line2-1

  |

/path is string form too

//TODO Newline counts as a => when appropriate so

// Allow multiple changes which make it adhere to the type, as long as nothing is accessed in between
//Allow type def conditionally like this
 variant: ~= ^1,1 ? Binary.Positive{length == 3} : Binary.Positive{length == 2}
//TODO If multiple edits makes it type compliant allow as if a single transaction
// Allow [7 | 11 | 15 | 19]  -> [~ 7 | +4 | +4 | +4] & ~ 1, +2, +3, +4
// Allow 'def Ray<T = Ray>', Meaning, T is unknown, but it is a Ray.


// Certain variables like 'throw' need to be accessible even in nested function which aren't defined with that variable in scope. How to type-check and generalize this concept? Is it with some keyword for a variable?
// Allow 'var = () = inline', 'var = () = { multiline }', 'var = () .. end' - Need to only capture the defined variables accessible from that context.
// defined inline inheritance: def Point<T < { + (b: ) }> Point{+ (b: Number)}
// Point(x=1) x=1 shouldn't be overridden by x=0 in the constructor
// 'def as :== Binary.Positive = segments as Segment.Binary[]' should be automatically assigning length too because segments have length defined
// When N <- . -> N is evaluated in a class with properties, it equips 'parent: Node <- .hierarchy -> children: Node' as .next/.previous (soi  when it's only a type definition)
// Allow 'unit (define_globally ? | unit.name)' without a :

// (Base, unit: Unit = Unit.None)[], Should implement x[0].unit, because it binds the variable to it.
// Should also implement x.unit as |
// If there's a superposition of possible values, but only one fits, we dont superpose the other non-fitting ones, but just use the one that fits.
// TODO Assert should be the same as dynamically assert in that it effects the type of a variable up to that statement.

location //TODO Allow this syntax. => Should be dynamically there.
  primary: Location


// Allow named parameters to access nested fields: def method(parameter.field: Object), and it's then set as 'field'
// Allow the . after operator in shortcut of defining x => x & x. : this.#`String.NonEmpty` -> & .#`String.NonEmpty`
// Allow ' + .name: "quecto`name`", "s"?' as a + { name: "" }

// Allow +=  equiv to '= .+ b', so allow '= .method.method2'
// Allow  Ray<T = Ray<T>>



// TODO - Notes on Version Control
// Accessing a variable of a function (either by partially filling it), but it got renamed in a new version. Alert the user.
// A monkey-patched function added, is suddenly also used by the library. Notify the user it's now overriding functionality that wasnt, there before.
// For .ray.txt editor we can inject labels before functions and hide them with some IDE plugins for non-Ether editors. So still support version control in-line

// TODO - Notes on Type Checking
// If blocks like if array.length > 2 ... end, change the type of array within that block. // '{==.instance_of IP}' Automatically casts to IP.
// Functions should relax their arguments to 'actually used this from the type'. (So type refinements)

// TODO - Notes on Theorem proving
// Expand tactic to inline proof. (different lvl of description - allow switch back it not altered ; or equivalence and change the view)
// Tests is the same as theorem proving, -> Combine both approaches, is a specific case
// example; As an example usage: Use theorem-prover to automatically generate all the possible boolean implementations. How?

// TODO - Editor
// Can be rewritten as: if higher abstraction level. for all recognized mappings.
// goto label in an IDE should bring the label back one space. ; if then a type defined instead add it back.
// If an automatic isomorphism is found, and the user is trying to implement it, notify the user it's not necessary.
// Function in the editor where you select, press a key, then allow the perform operation on that selection like select capped text, .tolowercase it. done.
//   -> Similarly, in natural language describe the thing you want to do to that selection. Same with object.[describe] for where the cursor is.
// Eye-tracking should switch primary/secondary location, if the windows are side to side, if overlayed, the top one takes priority.
// version control selectors at functions in classes in the editor
// Use v[SUBSCRIPT] or ^[SUPERSCRIPT], and allow to undo to prefer non-script notation
//TODO Extend UTF-8 with custom symbols, as a new String type. When copy pasted uses a different format to indicate it's custom symbols.
// Associate @players.choose, with a comment/dynamic page above it which is quest information on why you can make thise choice, also how do you indicate, you just want to store the results preiodically and use later.

// TODO - Features
// Evaluating infinities
// Automatic isomorphism

==.instance_of is also an equiv graph of values

  // TODO .unrolled() -> Allows loops by defaul


x⁸

def bidirectional
  +1
reverse
  -1
end

bidirectional!
+!(5) = -5

-1 <- x -> +1, how else
// inverse-1 notation used to go to the reverse direction of a method



// instantiations of a type using something like WaveFunctionCollapse
