//TODO selected
//TODO selected on another instance (primary)
//TODO the variant of selected on X, for my Y (mirror)
//TODO Quests: When is the mirror synced to the client, when to download, how many levels deep etc..
//TODO Location = IO /path
  //TODO How to access all instances/references of a particular type (whether on disk, or in memory)
  //TODO Location is in memory, and on disk, how to sync them
//TODO Locally set to a different value than what the managed inventory says?> ever used?
  --> That's like setting a alias .name for a world, for your usage only. Store that name separately, if I want it to persist.
  --> Like a commit always appended to the most recent version. (my own branch)
//location might be non-halting, not yet discovered locations which run this world/X.
// Change access permissions of your mirror.

  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    if current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else assume
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end

// Remote execution
//TODO Default to program<&who = CHARACTER>() if passed by the character.
//TODO   What about read access to the libraries and new variables it makes; Need some way to say, it's running locally, and it doesn't need to be this character; that's the default privacy policy? So different than protected?
//TODO The default REMOVE HISTORY AFTER X DAYS (30?) allows the character to do it, if it has been logged previously, so the execution script can be run as their character.
// Run code as an unauthorized character -> by creating a new character and eval'ing code then


//TODO .instance selected instance again

  : static => #[0].x

class Instance < Location & (IP | Socket.Address)
  status: Status = Status.Network.O
end

class Status < Status.Network
  static class Network //Online Offline
  static class Hosted // Hosted or broadcast
  static class Broadcast
  static class Proxy // Allow other's to proxy through you, do things like @private.managed Proxy, only particular ones

  //TODO = Broadcast! Or some general way to remove a &/|.

  = //TODO Only override the specific class it came from
end
//TODO Invisible, is just offline read
Invisible =>
  return Online if &who.CURRENT_INSTANCE == ME.CURRENT_INSTANCE //TODO How to differentiate between the &who who set this variable vs, the one who gets it. -> how to say load the expression, not the value.
  Offline
//TODO Idle, DoNotDisturb, Busy etc.. for NPCs with more data, and players in general, extended status. status & extended

//TODO Have a sharded character, if the ether central server doesnt allow storage beyond X, allow remote storage to be configured.

class Character < Entity & Accessor & World & Nameable
  PREFIX = "@"

  instance: Instance => location{==.instance_of Instance}

  // If blocks for which world to load it in, based on location, then .avatar with {location == ?}.avatar or default {?} to load all properties with unknowns
  avatar: Avatar if this !=.instance_of Avatar

  status => instance.status#.max

  {" "}{string: String} //TODO Access permission filter

  // == Challenges with timed message to be decoded
end

class Avatar < Character
  // consistent is the field that referenced this, must reference back. with {?}, {avatar == this}
  character: consistent Character