// Defined by context:
//  external = { do, goto, *, Node { `*`, `*`= } } // TODO: External should nestedly check local.definer
//  `arbitrary structure`=
//  def def(): Constructor - def defines 'return'
//  local
//  caller (= local) TODO Or is it nil
//  TODO Should be the constructor that calls into the program:
//  constructor (= local) = { name = "<text file name or nil>", definer (= local) } TODO Or is is nil?
//  definer (= local) TODO Or is it nil
//  return

def * = external // TODO any type Might not need to be externally defined. self-referential hypergraph-like structure
// TODO: Type of program is the same signature as Program and <T> extends Program -> Rename Program to Function? Program more general than function: it can be anywhere in some state.
def do<T < Program>(program: T) => T = external
class goto
  def (location: Program, predicate?: Expression) = external //TODO, Hijacks control-flow (Maybe if predicate is provided), which needs to be an option for functions, yielding control to a parameterless "program" -> or one where the parameters are already filled instead of goto the way of doing it.

  def if predicate: Expression = this<predicate: predicate>
end
def [args: Array] => args

def < constructor: (*) => *
  caller.super = constructor<local: caller>
  caller.super[constructor.name] = constructor<local: caller> if constructor.name
  // TODO: How does type extension work?
end

def +def
  //TODO Define super in nested 'defs'
end

global = local

//TODO def
//TODO Array
//TODO 0..9.reduce(|) / "0".."9".reduce(|)
//TODO Decimal -> Binary / Binary -> Decimal & Decimal.String -> Binary
//TODO .map, .map on single value, effecting all .OR?; No that's the same as calling on the static def, the method meant for the instance. (Allow both variants)
//TODO "as string" should also accept "as Digit[]"

//

def void end

def namespace
  def `name = *`(definition: () => *)
    definer[name] = local
    name

    definition(local: local)

    return local
  end
end

def class
  def `name = *`(definition: (Args = *) => *)
    definer[name] = definition
    definition.name = name

    def (...args: Args)
      static = definition
      this = local

      definition(local: this, ...args)

      return this
    end

    return definition
  end
end

class Node
  def `*`=(value) = external //TODO These dont need to be external
  def `*` = external

  def [] = Array<this>
  def ? = Some(this) // TODO Perhaps None if None, or void or ?
end

def Iterable
  for callback: (Args = *) => *
    //TODO + continue
    //TODO + return = caller.return
  end
end
def AbstractDirectionality < Iterable
end

class if expression: Expression, yes?: () => *
  def (else?: () => *)
    goto exec if expression // 'if' can be used here, since goto defines a special if-block. It's not self-referential here.

    return else?(return: caller.return)
   exec:
    return yes?(return: caller.return)
  end

  // "then" is defined, so we can have an inline block like: "if expression then yes else no"
  def then yes: () => *
    this.yes = yes
    return this
  end

  def elsif expression: Expression, elsif: () => *
    def (else?: () => *) = this.else
      if expression
        return elsif(return: caller.return)
      else
        return else?(return: caller.return)
      end
    end

    def elsif = this.elsif<this: local>
    def else = this.else<this: local>

    return local
  end

  def else(else) = this<else: else>

  return this
end

class try program: () => *
  def <Args>(catch?: (args: Args) => *)
    error?: Option<Args>

    program(throw: (args: Args) => error = args; goto capture)
    return
   capture:
    catch(error) // TODO: Type-checker should know that it must be set in order to get here.
  end

  def catch(catch) = this<catch: catch>
end
// Asserts & dynamic asserts, are simply part of the type definition.
def dynamically
  def assert(expression: Expression) = external
end
def assert(expression: Expression) = throw '' if expression // TODO


def while expression: Expression, program: () => void
  return do
   check:
    goto done if expression

    program(break: () => goto done, return: caller.return)
    goto check
   done:
    return
  end
end

class Expression
  def while program = global.while(this, program)
end

// A function is a Node for which "(*) => *" is defined.
def Function<(Args = *) => Return = *> = Node<(Args) => Return>

  // do end.while() is a do-while loop. TODO Could also only define it on "() => void"
  def while expression: Expression
    return do ...args
     exec:
      this(break: () => goto done, ...args)

      goto exec if expression
    end
  end
end

def Option<T> = Some(T) | None
{ Some, None } = Option

def Two = Array<length == 2>
class boolean = false = Two.first~ | true = Two.last~ do
  // TODO Verify that these are correct work for all cases.

  not =
    def !
    or this !& this
    or this !| this
    or this x| true
    or this x!| false
    end

  and =
    def & b: boolean
    or !(this !& b)
    or !(!this | !b)
    end

  or =
    def | b: boolean
    or !(this !| b)
    or !(!this & !b)
    end

  nand =
    def !& b: boolean
    or !(this & b)

    // An implementation using goto"s so that a conditional goto is the only (necessary) primitive.
    or
      goto 2nd_check if a
      goto 1
     2nd_check:
      goto 0 if b
   1: return true
   0: return false
    end

  nor =
    def !| b: boolean
    or !(this | b)
    end

  xor =
    def x| b: boolean
    or !(this x!| b)
    or (this & !b) | (!this & b)
    end

  xnor =
    def x!| b: boolean
    or !(this x| b)
    end
end
{ false, true } = boolean


def Integer = sign = "-"?, integer = Positive
  static def Positive = Array{length == n}().last~
end

private def Digit = ("0".."9", ("a" | "A")..("f" | "F")).reduce(|)
  def value
    // TODO: First wait on a definite way of defining the graphs.
    "0" = |,_,_,_,_,_,_,_,_
    "1" = -,|,-,-,-,-,-,-,-
    ("a" | "A") =
    // TODO Define the graph of a number, without having access to a number to construct it.
  end
end

{
  Binary: Digit = "0" | "1"
  Ternary: Digit = "0".."2".reduce(|)
  Quaternary: Digit = "0".."3".reduce(|)
  Quinary: Digit = "0".."4".reduce(|)
  Senary: Digit = "0".."5".reduce(|)
  Septenary: Digit = "0".."6".reduce(|)
  Octal: Digit = "0".."7".reduce(|)
  Nonary: Digit = "0".."8".reduce(|)
  Decimal: Digit = "0".."9".reduce(|)
  Undecimal: Digit = ("0".."9", "A").reduce(|)
  Duodecimal: Digit = ("0".."9", "A".."B").reduce(|)
  Tridecimal: Digit = ("0".."9", "A".."C").reduce(|)
  Tetradecimal: Digit = ("0".."9", "A".."D").reduce(|)
  Pentadecimal: Digit = ("0".."9", "A".."E").reduce(|)
  Hexadecimal: Digit = ("0".."9", "A".."F").reduce(|)
}.for Base, digit
  class `Base` = sign = "-"?, integer = Positive
    static def Digit = digit
    // TODO: The static Decimal, should be read as a Type which is an array, but it implements an AbstractDirectionality too: the default +1/-1 numberline: that way you can do Decimal.if(<10); Or Decimal.Positive which has base case 0 selected.

    // TODO Some for of this.toString which would be sign.toString, integer.toString which would use 'String'. But then for static, on the types.

    static class Positive = Array<digit.value>
      static def String = Array<digit as string>
      // TODO Map to and from string, using some mapping (which is defined both ways, once: 0 = '0' ..)

      def `fraction = Positive.String` => Real.Positive = sign, integer, ".", fraction
    end

    static class Real = sign = "-"?, Real.Positive // TODO: should be possible to define out of order, and access integer/fraction methods ; It should be seen as a partial "extends"
      static class Positive = integer = `Base`.Positive, ".", fraction = `Base`.Positive
      end
    end
  end
end

def `digits = Decimal.Positive.String` => Decimal.Positive => (digits as Digit[]).map(.value)
def 0`"x" | "X"``digits = Hexadecimal.Positive.String` => Hexadecimal.Positive = (digits as Digit[]).map(.value)

def u`length = Decimal.Positive.String` = Binary.Positive{.length == length}
  // TODO Number arithmetic
end
def i`length = Decimal.Positive.String` = Binary.Positive{.length == length} // TODO, Use Binary vs Binary.Positive
  // TODO Number arithmetic
end

def number
  //TODO A number.positive

  // TODO Generic number interface which others should extend, things like >/< should come from another interface which is "NumberLine"
  // TODO Infinity is a looped integer. -infinity a .reverse"d loop. .reverse needs to be preserved for them to be differentiated?
  // TODO: external defines that number > number is done by some other operator, not looking through successors/predecessors.
end

def string = char[]
  // TODO How do other languages implement String?
end
class char = u32
  dynamically assert this < 0x110000 & !(0xD800 <= this <= 0xDFFF)
end

def Range
  // TODO Range should be bounds which are Rays (already have the graph equipped)
  // TODO Infinity, is just the terminal reference (which doesn"t exist on the line) How to differentiate initial/terminal infinity.

  // TODO Implemented as things like .if() ?
end