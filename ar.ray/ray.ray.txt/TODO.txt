// Location
- Locations differ slightly from traditional file systems:
  - There can be many items (files) defined at a single location.
  - Any location is both a directory and a file; it defines both values and a (hierarchical) structure.
- Alternate values to mirrors than what's currently there:
 - Randomizer: mirror to collapse to a particular value not the probability.
- = is defined on the variable, since the variable is location aware.

// Networking
- All networking is abstracted away
- Importing external libraries/packages
- Quests: Loading partially (in/out-of-order) + reading from disk
- Managed items by another instance (mirrors)
- Domainnames + protocols, IPv4/6 reserved, UUIDs (Version = any hexadecimal) preserved
- {: String}orbitmines.com reserved
- Editing context for another character (local or remote) String @ character
    or executing remotely
    @character/package //TODO Is local mirror of remote object
      String +=
    vs:
    @character @ @ether/package
      String +=
- Use another protocol like HTTP @https://orbitmines.com

// Equality/Equivalence
- == usually ignores location, what if we dont want it to. Do we use ===? OR something more intuitive?

// Writing compiler optimizations
// dead code after return if there's no goto to a label there.

// Transactions & dynamically

// Language features
- -- / space false, true .map(!)
- ~~
Like '--', the operator '~~', wraps around an entire
array = [1, 2, 3]
array ~~ .[1] = 'B' // returns [1, 'B', C]

   (0 -> +1){< 10}.for i
   0{< 10}.for i // Since numbers are by default equipped with the numberline, and 0 is not real, but the Decimal.Positive.


confidential.read none.write mac_address: Binary.Positive{length == 48} =
  secure Binary.Positive{length == 47}.random ~~ .[6].push_after(1)

