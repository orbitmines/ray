

class Item
  // Every item has an inventory defined on it: '<-' is parent directories, '->' are child directories. Loops allowed.
  inventory: Ray = Ray(this)
  //TODO fields shoultn necessarily count as child directories, since we might have a structure on some location (arbitrary), but it's children are not the same as its fields. Take directories for example.
  // TODO They do, but the default .files/.directories in fs is a field, not the top-level properties.
  //TODO But even then, there might be overlap in the two, what to do in that case? (Say the item defines something at .directories)

  //TODO We would also want to know how version control works, and how something lioke git is supported, since those visibility and sharing them is relevant
  //TODO Also, when visible, when is it synced to the instance.

  /./TODO Setting the visibility etc. of a filesystem, should go to some specific db.
  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    speculative if<assume: false> current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end
  //TODO What if speculative graphs are returned to something, and it changes the result of a function, that should in turn
  //TODO (this can escalate quickly) change the effects of functions caused by it recursively, and roll them back potentially.

  def visibility: Entity = inventory.previous?.value.visibility ?? "local" ;//TODO global.player.is_private_default_visibility = "private"
end

Saving program pointer id what youd do to save a game

.index on ray (Should compile to smarter things than just retreversing the graph to find the index, if a simple enumerating forloop does the job)
Want to also hafve things like .index from some other location x


local @= location to change the location the code gets executed

Create environments which don't have access to public/private methods

Operations like get from temote, but only one level deep (like the current level of directories) and them maybe in the background load more

Difference in acyclic to the same value, vs acyclic in there's an actual circular path

Two merged branches with a decided order (so non-parallel) is creating a new branch with values of .expand on the old changes = in their respective branches

you want a .expand across version control histories. So my local keystroke history collapses to a single 'commited' history which the same on .expand but then for that particular repository so we need .expand(location) or something
|-> would be across branches, since local keystroke history is just a branch on top of the current branch, then a commit would all those changes since tha last commit and switch that branch to it.

Commit changes is rewriting the deltas from keystrokes to whole strings. So need rewrite logic defined for that somewhere


location is moving pointer, you also want something like tutorial to define a future history of locations with timed steps and clndinional programattic steps like has entered this area
control flow of location so any function is a location so tutorial is a defined function
qhat of changes mid version define what to do with those, relocate to x
interleaved functions like movement of a npc tied with your own location


indentation newline after// prevent it from being repeated

Variable reference is to a particular place in the history?
//TODO Version control
//TODO Additional fields like timestamp are in some global order (some repository which keeps track of that)
//TODO Want things like only commit to history if it's a significant change, like the NW instead of joystick position
//TODO %/.history, for inventory, should turn the whole inventory nested, back in time.
//TODO Individual history per field, but a branch takes nestedly the history with it?
//TODO Needs to be at least git functionality
//TODO Changed signatures/types/functionality
//TODO Transaction system also makes use of this?
//TODO Every change is a commit, but a group of changes can be bundled into another commit (to mimic git)
//TODO  |-> That bundling is just an index to certain changes for a git, and parent/child commits are the next place that index is specified.
//TODO Branches/tags are indexed commits, branch is a moving index to some latest change.
//TODO .index maps to an object which as a type returns any properties with any subgraph/part of the object. (or another index)
//TODO Global timeline means what? (Option when reverting locally to revert everything around it to that too)
//      |-> Up to some parent?
//      |-> reverse of .expand (.collapse but then just a higher-level of description)
//      |-> This also includes setting already made changes into a new group which then becomes the 'git commit'
//TODO Needs a history conversion to something like git to support it, both ways.
//TODO Is .history an acyclic Tree.Vertex?
//TODO What if I set a variable with a history and I want to retain that history (and not the history of the variable it's set to)
   //TODO Or retain both?
   //TODO The .=(value) in history (encoded on the edge) carries with it the information of where it came from, with that history attached.
//TODO; Is syncing just another object with a different location, probably yes. So .save syncs an object. (What if they hasve similar histories, use that to check which changes need to be applied) - What if they don't overlap at all, you still want then to use = on all the fields.
//  |-> Many sync locations ; mirrors. Managed inventories are mirrors. .save = .push
//TODO Is syncing just setting that 'old object = new object', and then figuring out how the histories overlap (which is default behavior for =.)
//TODO The timestamp is just Ordered. Can only merge two repositories (and reorder the events) if ordered is the same type = or an equivalence exists between the two types.
//TODO -> That's just an overlapping graph, which is filled by looking up in the history graph. .previous. < this < .next. ; require two simultaneous events to be on two branches, which are then immediately merged. ; what if there';s a merge conflict between these two. There won't be because it's two different repositories.
//TODO -> What if I have a repository with a global order, and one which is a child repository, and I want to merge them, then there's a possible merge conflicts with two simultaneous events. -> Or are all the fields just .OR/.AND'ed.
//TODO What happens to the two merged branches. If no conflicts, keeping them parallel in the history is fine.
//TODO   |-> And what happens when there's a conflict.
//TODO Uncommitted files, and staged changes, like those added with git add, are simply visibility set to local/private.
//TODO    |-> Remove files from repository by changing visibility.
//TODO  -> Doesnt work with the following: v -- But what if: "local"/"private" & not -active-branch-
//TODO We have a "local" branch with changes keystrokes and all. Then the action of committing is, setting to another "local" branch the collective changes (or all individual keystrokes).
//TODO -> Then pushing is just remote = local commited branch.
//TODO Allow changes to history, you'd use that for 'another "local" branch the collective changes', not the one with keystroke information.
//TODO History is aware of other places the same inventory is kept. -> So the .location of the inventory.
//TODO  |-> It's different than location in some way, since we don't continuously update is necessarily.
//TODO Cherry-pick is a chain of commits apply to current branch
//TODO Managed inventory is mirror, but what if it's distributed like a 'remote repository', where both can write. You'd want it to be to the same object with different locations.
//TODO   |-> Same object with different locations, vs different but synced objects
//TODO   |-> If any locations are remote, behind the scenes, we implement it as a local repository and sync with different location
//TODO     |-> Location needs to be aware of which instance it's pointing to?
//TODO     |-> Functions might be remote functions like http API calls -> Abstract network away
//TODO   |-> Local might not know the value of access, only that it itself is included? ; How to support that?
//TODO   |-> Every object has one with location for local instance memory, and remote locations.
//TODO Keep track of where which remote is, or include that in some update. Only send required updates.
//TODO Last updated, things like that?
//TODO Define mirrors which aren't defined on the other locations, so only define it for locally (visibility = "local"?)

//TODO So caller could be at a location with a different instance too.
//TODO Different values for fields based on who is looking at them. So access 'caller ==.instance_of global.player' for instance.
//TODO  -> Dynamic variable? -> No. change it to a parameterless method

//TODO Or is it visibility for anyone with the encryption key? How's that defined.
//TODO Can have many encryption keys to access the history of the chat.
repository defines encryption? (Not necessarily individual items?), No not necessarily. Can be child values doing their own thing.
//TODO Can have visibility to the encrypted value, but not the actual value, how's that difference known
//Different visibility for different entity (callers) //TODO Different value for different entities.

//TODO Access is public, but only certain types of operations are allowed, like only +1, and only one per account, and only an account itself can set it, how to verify that?.
//      -> This would be distributed db for likes.
// TODO: Say a public copy a that 'likes' record is hosted by the player, copied by the Ether server, and then another player
// TODO Is allowed to have a 'private' commit to that record. So only the player can access it, but it acts as if it was on top of that. So commit.visibility is possible.
// TODO -> What is it was a blockchain, that wouldn't work because the previous commit hash or the next one wouldn't have the information.
// TODO   -> How to handle that? Always appended after the current history? But what if there's anotherr later overwrite of that value you'd want to overwrite your change. How to differentiate between wanting that change vs not, or in the +1 like case it doesnt matter, when does it matter?
//TODO    Y9ou could have something like a distributed chat, and you'd want something like if it was received late, insetad of putting it back inserted at that place in the commit chain, put it last and notify the channel with 'was sent 3 hours ago' then a context window from the perspective of that chat, where it is inserted in between. (And in message history insert it there as a, 'was received later but wass inserted at this time'
//TODO -> SO YOU WANT TO ALLOW DIFFERENT STATES IN REPOSITORIES, BUT STILL ALLOW THEM TO WORK TOGETER. (mY LOCAL HISTORY IS DIFFERE4NT THAN YOURS, BUT STILL NBEEW UPDATES ARE PUSHED TO BOTH.),M SAY FOR WHEN I KNOW I SENT MY MESSAGE BEFORE/AFTER SOME OTHER MESSAGE, BUT YOURS WAS SENT AROUND THE SAME TIME. WE MIGHT NOT AGREE ON THE ORDER.
//TODO Encryption is just some equivalent (with key) but differently structured value.
//TODO What are some other things that follow that pattern?: It's Setting a variable like visibility to something that can cast down to Entity like the string "private".

//TODO Private commits can be done, even if the access is not set to you.

//TODO What if history is too expensive to keep, for instance all the +1 likes per item. How does it work for the distributed case?
//TODO BVut then what do you do with location information? It's stored on player, not at the location? Or you have a history of stareting locations, with changes applied to them, Instead of a player variable at every change. So location would have to compute the player history. So you have to have access to a specific version of the world in this case.
//TODO Location history is an overlapping graph.
//TODO How to store distributed approximations of some value, like a blooming filter for likes. How do I indicate I don't mind an approximate value.

//TODO Cached .length for instance, so its history is deduced from going to different history values (since it's a function), but it can have cached history. (HOw to differentiate between the two)

//TODO Instead of having different variables for the different locations, commits might be private, different visibility (so branches might be private) and if there's a clash like both remote and me create the same branch, a merge needs to happen.
//TODO -> Want to support both.

//TODO Just like conflictin histories in chats still working, you have unordered arrays, which allow any order and should still work together.

//TODO Broadcast which partial information you have on your node. (This is what sharding does)

//TODO A quest which is like peer.share_information unless already has that information, where peer. is 'generating', or peers change dynamically and we want to dynamically share it with peers if we have that information

// What if I have a history on aq top-level parent and I want
   to inject it an another top-level parent object.
   Just all changes in a single step (.expand?)
   (Basically +'ing repositories) -> Each change might have additional timing information, so we
   could shuffle that order around.
// What if I want a subdirectory to be it's top-level directory.
   WHat happens to the history of its top-level parent?
   (Like how the git history vs a top-level directory works now)
   Then the whole history subgraph is in a single .expand and
   applied as a single step on the top-level directory.
   Still a particular branch is selected in the top-level directory
   about the sub-directory. So it has a history of selecting a branch
   then selecting another branch. (And being tied to the latest value
   of that branch). So instead of every change being tracked, only the
   branch changes are tracked.
   What would be the use-case for the top-level not deciding on a
   branch and .OR'ing possibilities

// Or define it as, the top-level parent has an order
   any substructure is just a subgraph of that
   graph. That's probably better.
   {.location == ''}, inventory might not be filled. It might just be
   somewhere in a world at location without inventory.
// what if the object directory is mentioned elsewhere
   as a reference. The the location would be set, but that doesn't
   count as inventory?. What if it does?

// You want to be able to start a new top-level repository with or without the subgraph of all the previous changes
   to that directory.
// Branch is a pointer to an edge on where to continue it, the current value being on .value.
   Because we can have different branches started from that same vertex. Which could
   continue on their own. The current branch keeps being at that vertex ( not continuing in those
   new branches).
// Variables are not top-level, but the context is. (So the context has a global order
   of variable changes within it) What about variable changes outside it? Those should
   also be recorded in its order? (so we can undo it) -> It just references other commits
   in external 'repositories'.
// Visibility, might only want parts of a history to be visibile to certain entities.
   Like: A branch and it's sucessive updates. ("private branch")
// You want the option to merge many in-sequence commits into a single one. Like we have
   history on every keystroke of a string, but we just want to set it to the information of the new string.

// But what if the world still wants a global order.
   Then parent inventory is set to the world. So changes are tracked there, not locally.

// Big one: what if the change, changes the location? Like graph spatial rewrite.
   -> History on Edges?

   Then: What if access to a location's history is lost.
// TODO Something like .push_back is set on the array, but the change effects an Edge?
// TODO Is basically two levels of description: One is push_back which is equivalent to .last.terminal.value =. which is equivalent to a change at .last to .terminal.value =.

// What about making a new repository out of a child directory which has it's oiwn history. Could do "from this point" it's a new repository. Or we could take the subgraph order from the parent. and then continue with that.

// .% tracks across many values?
   because a parent tracks its children
   How to differentiate location between children
   for things like the subgraph of the top-level history
   graph.

// Merge conflicts.
// want certain merge conflicts to be resolvable through some other means. Say both writing to a counter, you'd stack the +1 changes.
   (this would be taking the common ancesstor, then applying all changes from both branches in any order)
   (This isn't really pratical thouogh because of large numbers, so instead you would do what?)
   (In this case you';d have to be able to differentiate between two different +1 on the same number. How are those events differentiated, time, caused by etc..)
   (caused by is stored on player, so need somne way to get Player.All{} check it there)

A +def with a different visibility, monkey patch dependent

Quest: Resolve merge conflict like a uuid granted to teo different players concurrently, resolve by reallocating one of them, could use information on whether their uuid is used anywhere, how to differentiate between places where it's used etc..
We allow even unique entries to be duplicated, and require to resolve them asynchronously

Require things like "I've communicated with these replica servers before making this calculating -> when strong consistency is required." -What if they're not online, like offline players storage etc.. (For certain things like calculating player statistics which are kept local only, it would be "make sure your instance checks in with out server before X time", and we'll consider your changes) - So these are quests to complete for the replica servers

Want distinguishabiluty between .inventory on the current system vs where it came from (location) so . inventory{instance==global.instance}

Constrained in the type of operations performed might for certain operations not require the latest value if only +1 is done, and we're at 10 we don't need to know the latest value only that the decimal infinitely generates and isn't a modular number.
What if there's a change in the types of allowed operations. What if the types of allowed operations are different for different entities. What if I have access to change it differently, but I only use that on very rare occasions (might something still assume it's not necessary to check it; yes, because it might not know about my access or when it is used).
The type of operation allowed needs to be some function pointer to some implementation, so a changed function wouldn't work.

Allow constant is set that variable's access to noone has write access. (after the first change)? How to indicate that
Constant is just that the history ref doesn't move, I could use .push_back for instance and the result is a new variable which isn't a constant


"only these operations allowed is a refined type" - But we need a refined type which is dependent on the entity - different functionalities for different entities

Locally I can ignore the requirements of specific "only these operations allowed" requirements. Which could be put on some variable to say 'no monkeypatching allowed'. If I do, that variable loses some properties (locally), but anything communicated outside would revert back or ignore those changes. What if thise changes caused the object to be unrecoverably different, no that's not the case because the object has history too, before and after the different allowed accesses was done.

//TODO How to single nothing may get added to @. in the refined type

//TODO Want to switch locations of the variable. But is .location part of the history of a local variable, yes? But those changes might/might not be published (depending on which)
// How to say: I want to keep track of any changes I get access to; locally.
// variable @ location -- @.for
// variable @ "ip.adress, ipv6 address, domain name, localhost" or https://, allow saying in that subnet? still a location, just more vague
//TODO Ipaddresses are variables/domain names with a possibly locally changed value: IP tables.
//TODO instance is a location?
//TODO What if we're in a function what is variable at another instance in that function?
say I do 'remote = variable @ "ip"'
remote.location = local instance but it's pointing to remote? No its location is remote then. We ignore the fact that we need to store it in memory.
class DomainName{
  length <= 2^8 -1 // Length of a domain name includes the "."
} = "."
end
//TODO But it cannot necessarily set it: This needs to be explicitly given permission, but in essence anything it has gets written to that.
//TODO Remote has full access, by default to `variable @ remote`? So you can have String @ remote @ itself = ..

//TODO So you can do things like 'String @ remote -- = object'
//TODO Or allow +def `String @ remote`
So you can do things like 'variable @ servers -- = value' where servers is Many servers.
//TODO Then a quest would be fulfilling this asynchronously as servers get online.
//TODO How to indicate that it needs to (A) do it to new servers added to 'servers', and to do it (B) async as a quest


//TODO How to locally store the unencrypted in cache, so you don't have to constantly decrypt. When do you want to not do that and force decryption on every access?
//TODO So we have an encrypted object which casts down to some type? If the key is provided, where is the key stored?
def Encrypted<Encrypted = *, T> = Encoded<T>
//TODO This is, an encrypted value which gets decrypted, we want it the other way around as well?

  // TODO This method is provided by the encrypted data (or not, if it's unknown) And it's not a ref to a local method, it's a general reference to a method implemented on the host. What if it's not supported (i.e. imported by this instance), then disallow, or say you need to include a package (unsafe potentially)
  //TODO So methods need a way to say it's from this package (location). Which by default is the Ether. location, so those are supported by default. And if it references an unsupported method, it needs to be installed on the local side.
  //TODO How is it checked that for instance a method on Player, is already supported by me, so you don't have to sent it over.
  //TODO => Can do some quick checks like are the method signatures equal etc.. If there's a change, I want to support that change.
  def decode key: * = (global.player ?? global.instance).crypt[location] => T //TODO location might inherit the key from a parent group
  //TODO The result can be an encrypted value again, so it would have to be decrypted nestedly.

  //TODO This .crypt value would not be accessible/visible to imported code (in the form of the decrypt func)
   //How to differentiate between the many things on the same location
   //TODO Or fill the items on the location automatically with the decrypt key/
end
def Encoded<Encoded = *, T> = Encoded
  def decode() => T //TODO Use (), to indicate you want () to be called on it. Not a parameterless property.
  def as :== T => T = decode()
end

// TODO Should we include this?
// Every mapping acts as an encoding function?
+def Node<T>{def as :== T => T} //TODO Want to allow this syntax of a type.
  def as :== Encoded<T> => Encoded<T>(
    def decode() => T = this
  )
end
//TODO It needs to be a quest that you have the encoded value, but not the decode function, find it is the quest.
//TODO Rename Encrypted to Encoded, with a function, and Encrypted is a constructor which takes encryption schemes.

//TODO How does version control with with things like A-B- testing of functions and things like that, need to thinka bout that too.


//TODO Caller as .location

//TODO Encrypted chats between players, World = groups of players,
//TODO Have an option to have any file encrypted as part of "visibility = 'private'", but make clear that if access to the devices is lost
//TODO so is the file.
//TODO Chat which is an array to which pushes might happen out of order. have some way of saying that locally that out-of-order isn't
//TODO a problem, or simply reorder as a merge.
//TODO Optionally: Lock the encryption key with the password, or key dongle. (Want this to remain optional, but you also want people to be able to login if they don't have access to their own pc; so everything is 'private' by default, Make that default an option.)
//TODO You'd have libraries or 'apps' like Discord be able to say 'a discord server/channel' instead of this sort of channel.
//TODO Slowpoke would be access checking whether you have sent in the previous x time. : But about this you want the entity to know about it so visibility.visibility = "public"

class Entity < Item
  location: Ray = inventory //TODO Maybe inventory = location, and with a filter on .inventory = boolean
end

class World
end



// "local" means only on the local instance. (Not even local child instances)
+def String{== "local"}
  def as :== Entity = Entity{== global.instance}
end
// "private" means any instance running this player. Note that any backup server, like the central Ether server, has
// that property. Backup servers are configured using //TODO
+def String{== "private"}
  def as :== Entity = Entity{== global.player || == global.instance}
end

+def String = "public" // Allow this
+def String{== "public"}
  def as :== Entity = Entity{true}
end



// TODO .desktop inventory.fs defined by external.
// TODO ether.orbitmines.com

//TODO Allow storage to set visibility = private, if there's an equivalence. (Generally allow this)

//TODO All networking is abstracted away behind players/instances/inventories.

//TODO A separate ether world which gives out unique user ids.

// Everything is an Item, and possibly an Entity.

def Visibility = InheritFromInventory | Entity

//TODO You can have anything with really long values, which don't need to be loaded directly, but can be loaded partially.
//     -> Networking code for doing this partially.
//TODO This partial loading should also support encodings which can be decoded partially too.
//     -> If it cannot be decoded partially, it should have the value stored on another level of description how?
//TODO Or partial downloads of arbitrary parts of a file. (Allow access the parts out-of-order if present)
class Item
  // TODO history couldn iclude When it's used, how it's made, how it's discovered, how it's constructed.

  //TODO ANY ITEM MIGHT be managed by another instance

  // Items require Quests ; In order to find items you need quests.
  obtained_by: Quest

  // TODO Is issued_by here some top-level world
  issued_by: World = global.desktop
  certificate: Certificate

  //TODO Can't really implement visibility s public/private/protected, since you have 'The memory object Player', and 'The actual player to expose it too', or are they the same thing? They should probably be the same thing.
  // Read-access
  //TODO Want a dynamic default, until it is set.

  //TODO Read-access with a specific encryption key
  //TODO Locally set to a different value than what the managed inventory says?> ever used?
  // TODO what if that location is say referenced in two places, one authorized by me which says private, and another unauthorized which says public, it shouldn't switch mine to public.


  // Write-access (defines allowable values one can write to each field)
  access: Query<static> //TODO access is Visibility for each field.

  // TODO A program of possibly entities that are allowed to see this. Things like private instances which are allowed to see it. (Or the local instance) - Can also include things like 'within renderdistance'.
  // TODO, Want to add things like : has been at this location in this world before for instance.
        //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item): So has this type of item, then it's visible.

  //TODO If every item is an inventory, then this is not used, but where it came from, is.
  //TODO This inventory = Location *in* an Inventory/
  inventory: Inventory?
  //TODO If every item is an inventory, we want to know whether that inventory can persistently store information.
  //TODO If a single item is in multiple inventories, how is persistence done? Is it stored in one, refs, in another, stored in both, want to allow for all of these options, how to deduplicate if it's known it's in two inventories: merger, or what?

  //TODO We have copy as well, but we could also copy by ref, or have both set refs to a single one.
  //  -> All object setting/getting becomes moving between inventories.
  def move inventory: Inventory
  //TODO Transaction
  end

  dynamically if inventory
    // TODO On change, if has access, save. Otherwise, save local copy.
    def save
      // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
      //TODO Write to inventories
    end
    def delete

    end
  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
  def as :== Map
    // TODO Perspective switch to a 'high-level overview'
  end

  def as :== World = this ==.instanceof World ? this : TODO
    //TODO: How does 'World' differ from structure the item is made of.
    //TODO: World might not necessarily be accessible (Say the hidden dynamics of some function of some language)
    // TODO Internal structure of an item.
  end
end

+def Node < Item //TODO There's a circularity here, but it should be supported.

  //TODO obtained_by
end


// TODO You want to say, have a world in your inventory, which is your desktop. Which contains items. Those items are not directly in your inventory? But they can be put there.
class World < Entity
  //TODO What are quests and location of a world?

  // TODO What if I define my own alias for this world, it doesn't get stored in the global World config, but I want it in my own
  //   -> Allow overriding of default config: inventories by the user.
  // A instance can still host a world where parent != that instance.
  //TODO .parent would be .indexed_by, and another .parent would be, how did you get to this world? (So a path)
  def parent => World? = this.name.issued_by != this ? this.name.issued_by : None

  // TODO Instancelist maintained by the world, but others could be running it too.
  // Known instances which this world runs on (TODO Others might be discovered later, so .hosts might be non-halting)
  hosts: Instance = Instance{hosting == this}

  // TODO World generation vs world rendering, in certain cases world rendering would be similar to world generation.

  //TODO What about behavior dictated by the world/instance: These things are automatically shown, these things not.
    //TODO Might want to tie a quest to a location too.

  // Internal dynamics -> Want a primitive in .ray to be a dynamic space.

  // Split into two groups: Spaces with arbitrary propagation vs limitations:
        How do you make spatial propagation hard/limit it in a distributed sense when usually one can just skip ahead programmatically?
        -> Similarly how we make item copying expensive/impossible. Scarcity of the items.

  //TODO Spawn-location defaults to something like .first. (If accessible) What if it's not, then demand it's provided.

  spawn_location: Location

  // TODO, An entity should be a graph within the graph, both of those shouldn't interfere with each other. (As in effecting .next)

  // All information on what's in a world could be partial client-side. It might not have all the information of the world.
  def entities = worlds & players & npcs
  //TODO These are basically indexes of things moving through this world.
  players: Player
  npcs: NPC
  //TODO You should have a way of saying, this is my location (so also pitch etc.) based on that what information is available about which entities (could be partial)

  // Child worlds, where this world is acting as a parent category
  def #`world: this != global.Ether ? String.NonEmpty : String.NonEmpty & not global.Ether.name.ignore_case` => World?

  if this == global.Ether
    def #`global.Ether.name.ignore_case` => World = global.Ether
  end

  def worlds = (this.#`String.NonEmpty` -> .#`String.NonEmpty`).compact.reduce(&) //TODO Should overlay Both cases of "Ether".ignore_case and not.
  //TODO: Should know that, because of using reduce(&), that intermediate results are possible for .last (Don't need to compute all children to get some values out of this). That should also work for '(this.#`String.NonEmpty` -> & .#`String.NonEmpty`).compact.last'
  //TODO worlds{parent == None} should know that  it doesn't need to go into the children.

  // Players can be registered under a certain world, similar to how certain games/apps have UserName#Tag, where the
  // #Tag is the world.
  def @`player: String.NonEmpty` => Player?
end



// Spatial Propagation
// - Separate graphs for moving pieces?
// - One way of doing 'air you can move through' Split the graph one is moving into, and knit it back together on the opposite end of the structure that's moving.
   // Does disallow overlapping structures within the same space.
// - Or something more inspired by physics, based on the structure that's there in the graph, allow/disallow.
    // More spatial structure around matter
    // If something like an arm is attached, the further from the attachment the faster it has to move
// - World only has update events, you want those to be massively parallel, so what can influence what? -> What would actual execution on a GPU look like, how much does having it in a graph impact performance?
//

//TODO You might have some way to navigate the structure of a world, but that doesn't mean it's just accessible. In a way
//TODO in which you can, for instance, just loop over all the nodes. You might have to explore some other way.
//TODO So a world defines how you can interact with it.
//       -> It defines how you can move through it, at those Nodes, additional worlds are defined.
//       -> Comparing is just movement is matching some other world I can move in (
//       -> I might not necessarily host all these worlds top-level (visibility) or on some indexed #property. (Indexed just means I've saved that location in my inventory somewhere)
//       -> But when I'm there, I might find those worlds and then gain access to them (if only temporarily)
//       -> So parent worlds, are just the path defined to get there.
//       -> The host, is merely the top-level instance on which we're exploring. (But that might change at each step)
//          -> Hosting, just means I got this step of information from this instance. (Each step might be deferred to another host)
//          -> So each node of information has with it: it came from here.
//          -> In the case of providing information from disk from instance to client: The instance nodes are decorated with host locations of the disk for instance or memory, and the player is from the instance.
//          -> What if I wanted to know the history of where it came from? So from disk to instance (to memory) to instance ... , until it came to me. -> So the instance can choose whether to provide that information.
//       -> A location also needs information like : A path to get here. (Which is just additional structure, but those in turn can be vague locations)
//          -> Path information crosses multiple hypergraphs.
//       -> World has something like dependent/optional inheritance on Abstract Directionality.
//       -> Interface with which you walk through a world is itself a graph. Say a 2d-visual-field.
//       -> Highly parallel rewritable structure in world.
//       -> Location should also specify what interface is used like yaw/pitch/screen size etc..
// TODO How does a location work if it's a dynamic space?
// TODO Abstractly, we never know (without looking) if another location also matches this description.

//TODO Say I have an abstract Map on which is a path which is the Location. It's a Location, with structure defined on it with points which abstractly represent those points in the path.
//      -> Say I have 4 abstract point, each point in a list, the points are described abstractly. Abstractly means arbitrary structure after a .expand (So .expand doesn't necessarily just fill in the ray, it could be structure like: 500 steps from here there's this thing which is approximately like this. Where approximately is a type.

def Location //TODO = Ray of World OR: You want Location to be more abstractly, a subregion: subgraph - which could be a specific location, of a World. It could also be a description of surroundings, which is not yet certain where exactly in the world that is.
  world: World? //TODO Could be many: it's in one of these worlds.
  //TODO world could be a substructure too. we want the top-level world?
  //world is .context, top-level .context means ? .world
  /
  /TODO How do you store, 400-500 steps after this, but we don't know what's in between. ray{.[400..500] ==.some Structure} // ray{.[1km..10km] ==..Structure} -- radius, not back and forth. ray[1 km] = wall
  //TODO How many steps is 1m?
  //TODO Edges are decorated with length.
  //TODO Then depending on the discreetness per 1m, we have values like 0.00001m, which could highlight a superposition of position nodes.
  //TODO Want to also have things like .by_road.[1 km] which is another overlay on the main graph with effective gravity relative to free-roam
  //TODO    What if that is the same graph, but filtered which direction you can go.

  //TODO By default the elementary_length is not defined so any Distance is further away than a step. Want to also have some definition of: .next to the first thing that matches. (which would match with things distance is used for)
  //TODO After calling .elementary_length(1nm) on Ray decorate all rays and graphs connected to that with functionality that supports distances.
  //      -> Unless otherwise specified by the edge, defaults to that per step.
  //TODO So things like length > 1m should partially be defined as well.

  //TODO Location too has a visibility, to whom am I broadcasting that I'm here.
end

def Quest
  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  //   - Difficulty also has time information in certain cases; how long does it take.
  // - Effectiveness rating -> In the case of effecting other items.

  // Quest selection by NPCs
  // - Difficulty rating vs reward.

  // Creating quests for one-self, or others.

  //TODO Quests are also, places to spend resources on infinitely generating/speculative execution places
  //     -> If the result would be found, would that result into efficiency, or what else?

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate: Certificate?
  end
  def active = !completed
end

def Map
end

// TODO Items arranged in a particular way make another item. Something like = Hypergraph<Item> or it's a primitive item.
+def Hypergraph<Item> //TODO Hypergraph here? -> Item as Hypergraph<Item> implemented.
  def as :== Item
  end
end


//TODO Since the inventory is possibly managed by another Entity (instance), that means that it has access, and it can give others access.

// Managed inventories have some visibility/access, and thisw is one value for the manager (world), and another for the player, how to make that differentiation?
//TODO: How to indicate it is managed by the world, and synced to the player.
// Managed inventories at this location for a particular Entity.
def `entity: Entity` => 1 Inventory
// Managed inventories at this location by a particular World.
def `world: World` => 1 Inventory

// Inventories differ slightly from traditional file systems:
//   - There can be many items (files) defined at a single location. These could have additional operators defined on
//     them like AND/OR, and they could also be abstractly defined; They work just like any Type in `ray.txt`.
//   - Inventory works like directory: It defines a path. But at any path items (file) might be defined. Additionally,
//     it might host additional inventories and items like a directory. So any path is always a directory and a file.
//
// Technically every Object/Node, is *in* an Inventory.
//   - A value holds an arbitrary definition of that Type.
//   - Within it is recursively defines paths to other items (and thus inventories).
//
// When inventory is used as an Item, it is just "the path to that inventory".
//TODO Hosting you inventory is just hosting a world, which in it has locations at which the items are situated.
class Inventory
  //TODO owner = Location top-level,
  owner: Entity //TODO If everything is in an inventory, then inventory.inventory would be the entity. == path which is an entity
  //TODO Want owner to be a persistent Entity, since everything is an entity.
  //TODO path = structure on Location
  path: *[] = []
  def [path: *[]] => Inventory = this +.overwrite { .path = path }
  
  recursive = {
    def items => Item = (this -> ==.instance_of Inventory ? .items : .)[1..].reduce(&)
    def inventories => Inventory = (this -> .inventories)[1..].reduce(&)
  }
  
  // Get children of this inventory.
  //TODO .items might as well be .nodes for a World
  def items => Item
  def inventories => Inventory = items{==.instanceof Inventory}
  
  // Get the items defined at this inventory.
  def get => Item{visibility: Entity, inventory: Inventory}? // TODO These refined types should be implied.
    //TODO Load item as a .ray.txt file, with restrictions.

    //TODO Get a specific type
  
    // Many items might be stored at this location.
    item = sub() //TODO Support sub(), indicating that the method still needs to be implemented.
    item.visibility = path.map(.visibility){!= Visibility.InheritFromInventory}.last
    item.access//TODO Set access
    item.inventory &= this
    //TODO: Might have settings of certain instances to backup the player information to.
    item
  end
end

class Entity
  inventory: 1 Inventory // TODO *in* an inventory vs *has* an inventory.
  def quests => Quest = inventory{==.instanceof Quest}

  //TODO NOt this, but how to overwrite all properties which are not defined, recursively. How to get the type, and default value?
  +def def
    //TODO Adjusting def within a context should only monkeypatch it in that and children context.
    //TODO Property definition under the hood are def too?
    def `field: * => Type: * = default: *` //TODO How to differentiate default from a function body with the implementation
      //TODO Recursively how?
      super `field` => Type = inventory[field]()
      //TODO: What if inventory doesn't have that type stored.
      super `field`= value: Type
        //TODO Use .save/.delete the previous entries.
        //inventory[field] = value //TODO Should automatically implement &=, |= as well.
      end
    end
  end

  //TODO We have a world which is the memory system which is a child work of desktop, then if everything is an entity, the location is a place in that world.
  //TODO World = Inventory = Location, Location = child Inventory / subgraph/abstract description of World, child World = child Inventory
  //TODO Inventory is a refinement of World/Location. It's more strict.

  def world = location.world
  //TODO What if you only want to broadcast a particular part of your location, say the world it's in or?
  //   -> Actual location is one thing, the one broadcasted is another. Implemented as "at two locations", and one of them is chosen to be visible.
  //   -> How to indicate those two locations are supposed to represent the equivalent thing?

  //TODO Actually what you want for online, is a filter over possible worlds to interact with, and 'online' is equated to allow over internet. (what about other bluetooth things and such - included in online)
  // On top of 'visibility', an entity can be set offline instance-side: Indicating only offline communication.
  def online => boolean //TODO for a instance: set this value, for client: poll for data.

  //TODO Specific parameter types can be enforced using Entity instanceof SomeOtherEntityWithConstraints
  def `world: World`
    //TODO How to indicate that that entity ==.(some equiv graph) this.
    return this +.overwrite { // TODO Support +.overwrite as opposed to adding the results of the two to each-other. Type-checking should recognize the +.overwrite is defining at least the thing before the +.
      inventory = this.inventory[world],
      name = this.name{issued_by == world}
      location = this.location{.world == world}
    }
  end
end

using .library@.Git //TODO


  //TODO: You want to be able to host a instance as an item to a world, with some visibility.



//TODO So if a player has made their location known, another player can run an instance of that player in that location.
//      He might not be able to set input for that player, but it's still an instance running that player.
//      But you might want to run an instance, not the player (a specific location)
//      So streaming too, becomes running an instance.
// For strreaming, a player has a particular location which is the streaming location , that is being broadcast.
// TODO So watching a stream is simply following that location.
// So a streamer has a primary location. That location's location might be in a separate world which is the 'streaming window'.
// People watching the stream, would set their primary location, to that location.

// ==.instance_of .location Location is a type.

//TODO Some instance, which holds the 'first discovered by X' status, and issues certificates for that./
class Instance < World
  //TODO A instance is an instance, you can boot up other instances within the current instance.
  //TODO -> Child instances.
  //TODO A instance has many player instances running. (I.e. screens / separate windows)

  //TODO Instance needs a unique identifier more general than MAC, one of the names.

  //TODO Instance might be behind some nameinstance, delegating to many other instances.

  // A world might live on many entities/instances
  //TODO A player, or any entity can (co-)host worlds
  //TODO : From the perspective of this entity,
  hosting: World //TODO These worlds should come from an Item in the instance's inventory = is just (inventory as World){visibility = ??}

  //TODO How to represent that hosting and hosts in World are linked? 'hosts: Instance = Instance{hosting == this}' How is this, FOR ALL query constructed?
  //TODO How does the storage module know whether to store a reference or the whole object. It checks if the Object is stored separately and will use a reference then.
  //     -> Is there ever a time where that's not desired, say when the visibility or something is set differently for each reference of the object.
end

def @`player: String.NonEmpty` => Player = Ether.@`player`
def #`world: String.NonEmpty` => World = Ether.#`world`

def Certificate
  secret: Something
    visibility = //TODO Should only be default, can be overwritten
  end
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end


//TODO #World.#ChildWorld.@UserName where #ChildWorld.name.issued_by = #World
//TODO Equivalent .UI = .#Ether.UI
//TODO Equivalent: .#Ether.@UserName = .@UserName
//TODO .#world.@UserName.
//TODO; Require domain names registers on @"orbitmines.com" to be verified
// TODO; Allow circular using.
//TODO Uploadable public packages to .@name, default to using player names for this. register other organization names for this too.
// using .@"ether.orbitmines.com".UI, <TODO Version>
//TODO: If working in some folder, automatically change versioning numbers to the new ones, if the file is changed.
//TODO Should work with the versioning system somehow? another parameter here the version, which the IDE supports for automatically getting

private class Module
  static Constructor = (root: Module = Module()) => Module //TODO Constructor is parameterless, so you shouldnt need to call it with (), so just naming a variable this should work. BUt what if you would want to pass it a parameter, there's an ambiguity here.
  
  def (node: *) = ..path.reduce(acc = node, current => acc[current])

  `` = {
    def parent: Module?

    def property: *?
    def world: World?
    def player: Player?

    def path => *[] = (..parent <- this).compact.map(.world ?? .player ?? .property) //TODO This, because it's private shouldn't be overwritten? How does that work?
  }

  def `property: * & not ""` => Module
    return this if property ==<String> "."
    return this.parent ?? this if property ==<String> ".."
    return Module(..parent = this, ..property = property)
  end

  if !parent || parent..world
    def #`world: String.NonEmpty` = Module(
      ..parent = this,
      world = (parent..world ? parent..world : global.Ether).#`world`
    ) //TODO Check if not None

    def @`player: String.NonEmpty` = Module(
      ..parent = this,
      player = (parent..world ? parent..world : global.Ether).@`player`
    ) //TODO Check if not None
  end
end

def using at: Entity? = global.Ether, path: Module.Constructor
  environment = caller

  def eval inventory: Inventory
    item: Item = path(inventory)
    //TODO eval item
    //TODO Only allow certain things to be imported/changed by certain imports.
  end

  //TODO; If defined in player.inventory, define super() to call the original functionality.

  //TODO; Check if version exists on desktop if configured for remote, if it does use it.

  eval at.inventory if at // Load
  eval desktop.inventory // Load default settings
  eval player.inventory // Load player overwrites
end
