global = local

`{string: String}` => string
"{string: (substring: String, (punctuation: `{`, expression: *, punctuation: `}`) if substring !`\`⊣)[]}" => string - punctuation

comment //{" "[], comment: String, \n?} | /*{
  {comment: .line#.join(\n)}: (indent: " "[]{length == previous.indent if previous}?, line: String, " "[], "\n"?)[]
}*\ =>

{{expr: (): *}} => expr<local: &caller>; local
({expr: *}) => expr
[{elements: *[]}] => elements

class * | Node

  external ({args: *})
  external [{property: *}]
  <{partial_args: (): *}> => this++ ~~ .partial_args &= partial_args
  {{constraint: (this: static): boolean}} => this++ ~~ .constraints &= constraint

  {` `}({expr: *}) =>
    this &= Program(args: expr)
      {"=>"?, block: (): *} => this = block

  .{property: (\S & not ".")[]} => this[property]

  external external
  external initializer
  external initializer = | assign (x): x

  class = {
    {name: String} (def: Program)
      static = local

      dynamically (this @@ Node)[name] = static if name // dynamically assign the name

      (args: def.args)
        this = local
        .static = static

        def<local: this>(args)
        this

      def<local: static>(def.args) // The constructor is always called with all possible arguments.
      static
  }

  enum

  type: * = static
  // Allow 'var?: type' syntax, because certain types would have to be wrapped in parentheses otherwise.
  ?: (type) => : type?
  initializer : | ∊ | ∈ (type) => this ~~ .type = type
  ∉ (type) => this: not type
  ∍ | ∋ (member) => member ∈ this -- this //TODO This higher precedence than : so it is executed on the type when x ∈ String ∋ x^2
  ∌ (member) => member ∉ this -- this
  dynamically assert this ==.instance_of type

  class ==
    instance_of (type)
      return (this @@ Node).(static === .) if type@ === class@


  // Get the
  @@ = (class) &caller.context.components{.static === class}.last[\@\]

class Example
  field = local