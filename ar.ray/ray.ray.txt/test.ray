
//TODO What about syntax which is more contextual

//TOD If !=.instance_of Instance ; if it already is a , dont case down to a field.
//TODO If there is a single field going to some class like Instance/or its extensions IP/Socket.Address, automatically add an equivalence (as IP) to that class. Is there ever a case where you don't want this equivalence?
  as (== Instance) => .instance
//TODO The inverse of this, calling the constructor on something which has a single extends, like Instance as Character. Only allow if it's a valid type then, so no fields missing.
  as (== Character) => Character(instance: this)

//dynamically location &= (BROADCAST_INSTANCE ? public.read : private.read) INSTANCE
//todo should change the variable INSTANCE to a new var with different permissions.

// Allow .for {from, to, name}, and [a, b]

class Example
  next = () =>

x = Example() &+ Ray()
x.next // Does (Example & Ray).next
x: Ray
x.next // Does Ray.next
x: Example
x.next // Does Example.next


// ALlow (⊢ | ⊣)name.split(" "), begings or starts with

// Editor, can be rewritten into preferred level of description, like there exists instead of #.some

// None acts as 0 in 16 - None = 16

// Every < X[] implements .Unbounded on static.

// TODO .push_back on None makes a new array with 1 entry

//
return A, B if // returns A
return A, B -- if
A, B if // adds B after A if

//TODO .copy implemented, as not being bound to the .history .last version. But a new branched version.


: Location = (##: Ray & Ray) | (##: Ray & Ray)
the default ##: is used if no name
//TODO Or use .expand somehow, NO? it's used for something else?


None implements location and =
//TODO What happens to returned variables? They have a location inside the function, then while their location isn't changed in another function, that function still lives through the variable?


//TODO Reverse .keys and .values
//TODO Things like .map on variable*, needs to be thought through, what is actually on *


//TODO Needs like an example of 2D/3D world with yaw/pitch on location, stored as arcs in a continuous space then discretized by some things like elementary lengths and other things.
//TODO What if that's derived from the space, if space is non-euclidean it's different than a simple coordinate system

//TODO Default of an object is only loaded if accessed, so we can have circularly defined defaults.

parse json to an object by setting fs.directory.file equal to some type which serializes and sets to json automatically restricting possible values

Evaluation order like +/-//* different for each type? how configured?


//TODO This will be difficult to implement, but it's very powerful:
//TODO Requires all functions like &= to be rollbackable (through history probably) or -= in this case if possible. -> Compiler uses history if necessary for these features.
//TODO The -= needs to check possibly changed locations here. but starting with that location
//TODO If there even then are some that cannot be rolled back, it's just not accessible in dynamically.
//TODO So if any variable (implemented with observers again) changes so sub or location, we run/rollback.
//TODO Or if dynamically the speculative if branch change, if resources are dedicated to that if branch.
    sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last
    //TODO Could also automatically rollback previous changes of &=
    dynamically sub.location &= location.copy().push_back<edge: .value = property>(sub).last
    // equivalent to
    dynamically sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last


//TODO Extend UTF-8 with custom symbols, as a new String type. with way of converting to a string in case UTF later supports them


//TODO instance_of which respects .expand and looks into it, vs one that doesn't. Not just instance_of, all of them


//TODO But do allow >/< a type.

//TODO Only monkeypatch within some context, like equiv graph for only a specific context.




// KV pair with everything delegated to value, so you can do ==. (separate class like TransparentKV)


// Superposed values hold their origin.
//   -> The result should be refinable, "now I know it's true, so what's the result".
// refined to 'true', any effects caused should be reset back. -> Need some way to register for nonrollbackable events; a new value has arrived, -> a new version
//TODO With a label?
// Carry program pointer of which value/state effected it, how to access this variable if it's not defined?


// Ambiguity: If all methods on an instance are on the static class, what happens to () and other things which are already defined on Class? How to access them? (Single default method defined on class, which wraps the actual object fully)

//TODO Infinite loops like location.parent, circular, map to None if detected.


//TODO Require other structure than the typical x.method(y), but higher-arity for instance; Also a structure where x&y aren't filled, instead of just a (x) => x.call(ALREADY_FILLED_VALUE)

// .reduce(|) TODO How does it work to pass a binary operator to a reduce which has accumulator and current as the two arguments
//   -> If default is not set for accumulator, the initial value is the first in the array.
//   TODO But how would you?: For .reduce, require a default value for accumulator, how to indicate that?

//TODO You want something like ray[500..999] = 500-length array, instead of setting all those values to the 500-length array. How to differentiate

//TODO If big instanceof iterables are used, like worlds: World = entities{==.instanceof World}, store it separately, don't always filter through all those entities

// 0..9.reduce(|) = (Decimal.Digit) 0.value.context.reduce(|) ; .superpose an array, namely the digit defining 0. -> Then could also have the digit values link back to the superposed object or not?

// <=; node > itself or node < itself, we're in a loop (or repeated value which we're forced to see as the same, or we're not comparing using the difference we have access to - this 'number'line)

//TODO Yield ray methods in context of for so you can to is_last for example?

//TODO Variable call by reference/value per class, and also manually possible?


// TODO - Ambiguities

//TODO Bidirectional function like ray but only single step: l <= (x) => r, ambiguity with <=

// Ambiguity between boolean and false | true, when wanting to check the value ==, checks if it's false or true?
// false != false | true, still executes the branch where it's false.
// But we want == boolean, as in, is exactly the boolean type.

// def a = a vs def (a = a) = a, default clashes with singleline func, same with => for function
// var? vs var ? true : false ; how to know if we need to convert var to a boolean or pass it to option.
//   -> Also var ? true : false , is it var.? true : false, or var.?.true.:.false
// .extends vs a check if it does extend
  // TODO Ambiguity if we use '<', because if I check 5 < 3, it's not 5 extends 3. Is there ever any time you'd need to use extends over <?. Yes a Type Ray which extends some other Ray, so it would be Ray < Ray,
  // What even does Ray extends Ray mean, what happens to all the structure?
// args.for(args) a could mean args.for(args).a, instead of defining a block. Or something like args.for a b = 5, with the default '= 5'
// statement if expression != statement.if.expression, similarly if expression then a else b
// what if I do something like () => boolean, which returns a boolean, the return type is not false | true, as in 'a boolean', but it's 'the type boolean'.
// Referencing a parameterless constructor, can be both the Object() or Object, since it could be interpreted as a property.
// Should changing local, also change 'caller'/'definer'?
// [1, 2, 3] should call global level [], not local level def [property].
// Variable * for any shouldnt interfere with * 2 things. *2 variable or * _, reduce(*) (* is called on the acc and current)
// Somehow the constructor another method thing so that everything can be passed on to static, but then that would have the same problem.
// The boolean definition false, true = needs to be on static. Which is done because the .false/.true values never change based on the type definition.
// If a method doesn't exist on the variable, but it is castable to something which does define that method, say boolean and &/|. Converting it to that value and calling that method should be possible.
//   |-> Version control: if that method is then implemented by a library, a user should be notified the functionality changed (probably unexpectedly)
//   |-> Ambiguity if there are multiple casts to which that method may be applied.
// classes without parameters are now called their constructors instead of requiring a ().
// ~= ^1,1 ambiguity with ^3 as a number or other numbers, it should prefer ^ starts_with because of ~=. There's no ambiguity if we use ^[1,1] -> It's not a numbe.r



method () **: Terminating



// TODO - Examples + Allowances

// Allow
f (property = call(property))

(if Keyboard. ↑ | w .pulsed) <- selection. y ?? hierarchy (
      Keyboard.ctrl && Keyboard.shift => // Skip group & Expand selection
      Keyboard.ctrl => // Skip groups
      Keyboard.shift => // Expand selection
    ) -> (if Keyboard. ↓ | s .pulsed)

// Allow maybe == Some a: 5..10
(maybe == Just a: 5..10).while
   maybe = Just 5
end

// Allow newlines after a |, so we can do things like
func
  | line1
    line1-2

  | line2
    line2-1

  |

//TODO Newline counts as a => when appropriate so
//TODO Allow arbitrary parts of a function to define a parameter, by simple saying UNINITIALIZED_VAR: a, required if no default is provided.

class Time < Quantity.Temporal (calendar: Calendar = UTC) =>
//TODO Allow out-of-order things like <, which are inside the () => {}

// Allow &{method: *}: //TODO Infer (with all special chars)

// Allow multiple changes which make it adhere to the type, as long as nothing is accessed in between
//Allow type def conditionally like this
 variant: ~= ^1,1 ? Binary.Positive{length == 3} : Binary.Positive{length == 2}
//TODO If multiple edits makes it type compliant allow as if a single transaction
// Allow [7 | 11 | 15 | 19]  -> [~ 7 | +4 | +4 | +4] & ~ 1, +2, +3, +4
// Allow \ to be used in a variable at the start \s
// Allow 'def Ray<T = Ray>', Meaning, T is unknown, but it is a Ray.
// Allow chaining of binary operators like Array<3 < length < 5>
// Allow chaining of conditionals with .AND -> Array<length > 3><length < 5>
// Also allow Array<length > 3 | length = 3> What about this syntax: Array<length (> 3 | = 3)>, Array{length > 2 if property}
// Like this == n ? TypeA : TypeB, allow 'match' to be a type definition.
// Allow def (array: Array), to automatically accept varargs.
// Multi-methods should work for things like throw, if top-level defined doesnt accept the error, perhaps the top-level one does.
// If variable with type Option is set, it should automatically implicitly cast it to Some()
// Certain variables like 'throw' need to be accessible even in nested function which aren't defined with that variable in scope. How to type-check and generalize this concept? Is it with some keyword for a variable?
// Allow 'var = () = inline', 'var = () = { multiline }', 'var = () .. end' - Need to only capture the defined variables accessible from that context.
// Allow a wide variety of things in the String of defs, like α/β/.. other languages. Lean allows a ' at the end of variables, to mirror math.
// Type-cast like this: a: Decimal = 5, or a: Binary = 5
// defined inline inheritance: def Point<T < { def +(b) }>
// Allow single-line blocks: while o.last() == '0' => o.pop_last()
// Allow var: Graph = 1, 2, 3
// Allow .map(.property), .if(.property > 2)
// Allow Array<ar.length === 0 ? length = 0 : length < ar.length>
// Allow a < b < c
// Allow def method(n: % 2 == 0)
// Allow def (...args) unused to be def (*)
// Allow false, true = boolean (Because boolean is a FALSE.OR(TRUE) Node, and nothing else could match to this spread operator). TODO How to go into the reverse direction? Say cursor is on TRUE there. (if it's not referencing a graph).
//    -> Should this also define Iterable: .for, for Nodes which don't have any ray selected? Or Actually implement Ray, if the .OR definition is a ray not an Array/graph
// Generalized: Repeated entries in an array like String, single instance mapping 'as X'. Allows for 'repeated X' to 'String'. And then automatic isomorphism might take care of 'String as X' and 'String as X[]'
// spaces for method calls only work for same line, except for body calls
// Point(x=1) x=1 shouldn't be overridden by x=0 in the constructor
// Decimal.Positive{< 2^8} as String should work if Decimal.Positive as String works.
// octets as Binary.Positive{length == 8}[] as Binary.Positive{length == 32} The length == 32 here should be implicit.
// Superpositions in the conversion between Decimal <-> Binary, should be respected.
// IP = -1 <- . -> +1, should automatically check the boundary conditions of whether +1/-1 is supported. And end it there so you don't need to "+1 if 1 <= ~!(as Binary.Positive)" TODO What happens to a subnet where this operation can't be done?
// 'def as :== Binary.Positive = segments as Segment.Binary[]' should be automatically assigning length too because segments have length defined
// '{==.instance_of IP}' Automatically casts to IP.
// When N <- . -> N is evaluated in a class with properties, it equips 'parent: Node <- .hierarchy -> children: Node' as .next/.previous (soi  when it's only a type definition)
// Allow 'unit (define_globally ? | unit.name)' without a :
// 1d 10h 10ms, Should see that 1d does not define .10h so it should check them individually and check if 1d implements 10h
// quantities ,= a, is push_back(a)
// (Base, unit: Unit = Unit.None)[], Should implement x[0].unit, because it binds the variable to it.
// SHould also implement x.unit, to map over x.map(A, B => B)
// If there's a superposition of possible values, but only one fits, we dont superpose the other non-fitting ones, but just use the one that fits.
// TODO Assert should be the same as dynamically assert in that it effects the type of a variable up to that statement.

  def location = Location
  +def location //TODO Allow this syntax. => Should be dynamically there.
    primary: location
  end

class char = u32
dynamically assert this < 0x110000 & !(0xD800 <= this <= 0xDFFF)
end
class char = u32{< 0x110000 && !(0xD800 <= this <= 0xDFFF)}
end

// Allow static to be accessible in defining parameters, say 'class Hypergraph<T>{every(==.instanceof Vertex)}; static Vertex'
// Allow static to go to inherited objects.
// Allow out-of-order defined defaults at?:, path:
// Allow named parameters to access nested fields: def method(parameter.field: Object), and it's then set as 'field'
// Allow var?: type and var: type?
// Allow the . after operator in shortcut of defining x => x & x. : this.#`String.NonEmpty` -> & .#`String.NonEmpty`
// Allow 'defined_segments.length (zero_compression ? <= NUMBER_OF_SEGMENTS : == NUMBER_OF_SEGMENTS)
// Allow abstract class .string to go to all implementations of that class <.
// 'zero_compression ? super() : compress_zeros.super()', define super for all variable instances of the same type (only in that context) : What is repeat the function, not super?
// Allow ' + name: "quecto`name`", "s"?' as a + { name: "" }

+def String = "public" // Allow this
+def String{== "public"}

  location: Location
  +def location //TODO Allow this syntax.
    primary: boolean?
  end
  //OR
  location: Location
    primary: boolean?
  end

// Allow +=  equiv to '= .+ b', so allow '= .method.method2'
// Allow  Ray<T = Ray<T>>

// TODO - Notes on Grammar
// x+y x+y.func = x+(y.func) you want it to be explicitly (x+y).func

// TODO - Notes on Runtime
// Take the example of Decimal.String which should be defined first, then `Decimal.String`, then Decimal. can be defined.
// Lazy evaluation, keep structures like 'false | true | true' around without deciding execution order. ; Associativity proof is somehow relevent here, how does the runtime know about it?
// Pull static out of constructor if possible.
// Dead code like a = b, a = c, 'a = b' is never used. (Unless something like history is accessed somewhere)
// Any statement is executed in a .do block, so that one can implement a debugging .do overwrite.
// This type return should automatically be deduced.
    // def posOrNegThree (s : Sign) :
           match s with | Sign.pos => Nat | Sign.neg => Int :=
         match s with
         | Sign.pos => (3 : Nat)
         | Sign.neg => (-3 : Int)
// Warning in class, if return is used: because it's not used in the 'class definition'
// How is something like the proof that after a .push_back(A), .last = A, unless another push_back is used. How do you represent that, and how is it used by the compiler?
// Native support for running parallel on other machines
// When using multiple implementations of methods, you want enumerations of possible requirements, so for boolean this could be NAND, NOR, NOT & OR, NOT & AND. etc..
// 'external' is allowed to overwrite any method.
// Ambiguity: [[A, B, C], [D, E, F]] flattens currently, how to get it not to flatten?



// TODO - Notes on Version Control
// Accessing a variable of a function (either by partially filling it), but it got renamed in a new version. Alert the user.
// A monkey-patched function added, is suddenly also used by the library. Notify the user it's now overriding functionality that wasnt, there before.
// Use something l;ike Model @ remote as the thing which takes the type used for API. but still run instances locally? How? And then on a change in the API jnotify user.
// For .ray.txt editor we can inject labels before functions and hide them with some IDE plugins for non-Ether editors. So still support version control in-line

// TODO - Notes on Type Checking
// If blocks like if array.length > 2 ... end, change the type of array within that block.
// Functions should relax their arguments to 'actually used this from the type'. (So type refinements)
// Any 'Program' object, carries with in what is accessible from that context, that way after each line, we can check whether a variable is present
// Taking the 'if' definition as an example, the type that gets returned needs to be a dependent type based on 'expression', then either 'yes => Return' or 'else => Return' needs to be implied.

// TODO - Notes on Theorem proving
// For the theorem prover, you might want to store a specific proof instead of only saving the tactic by which it is solved, needs some effective way of storing and referencing this; probably in a directory outside the current file
//   -> In the background run some (in)equivalence of functions algorithm to check equivalences automatically if possible.
// Tests is the same as theorem proving, but instead of whole types and proving them, we work with specific values of the types.
//   -> Combine both approaches
// Theorem proving that multiple implementations are the same, after a theorem is found -> possibly add to possible implementations
// runtime; Multiple implementations but prefer the one over the other for speed, is that done automatically? deduce which one is faster for which case?
// example; As an example usage: Use theorem-prover to automatically generate all the possible boolean implementations. How?
//    assert that all logic operations are available when only nand or nor is provided, or when not, and and or are provided. etc.. and all possible permutations
//    -> Are these all the minimals: nand, (not, and), nor, (not, or), (and, xnor), (or, xnor), (or, xor), (and, xor)

// TODO - Editor
// goto label in an IDE should bring the label back one space. ; if then a type defined instead add it back.
// If an automatic isomorphism is found, and the user is trying to implement it, notify the user it's not necessary.
// Function in the editor where you select, press a key, then allow the perform operation on that selection like select capped text, .tolowercase it. done.
//   -> Similarly, in natural language describe the thing you want to do to that selection. Same with object.[describe] for where the cursor is.
// Eye-tracking should switch primary/secondary location, if the windows are side to side, if overlayed, the top one takes priority.
// version control selectors at functions in classes in the editor
//TODO Super + subscript means what in UI.

// TODO - Implementing languages.
Translate everything like ifblocks etc. to other languages, which are implemented in .ray.txt with primitives to the implementation . How to say that something like the if/else construction shouldn't be rewritten to the goto's but instead are the primitives. How to use the rewrite-blocks of code syntax to rewrite to a javascript-like syntax.

// TODO - Features
// Observables which check if a variable is changed, dynamically assert would make use of that.
// Decimal % mod 2, should go both in .prev/.next directions and start at the base case 0. What decides this?
// equivalences: Implicit casts (lean: coercions), chained together Pos -> Nat -> Int "if there is a path to Int from Pos" - allow loops.
//     -> Get a graph of possible coercions
// Boot into a context, which doesn't allow access upper-level properties. Something like program(`*`: () => None). Shouldn't overwrite local etc..
// Evaluating infinities: "There exists ; is just some" def even(n: ) => Nat.some(half => n == double(half)). ; TODO How does this evaluate on the infinite .some ; Nat<every> is different from Array<length> one is referring to an instance the other to the static type Nat. Or dont use Nat<every>
// Native support for eventual consistency
// Math
//   sum/product sum icons, being .reduce(*)/.reduce(+)
//   Something like an integral implemented as an dx = infitesimal step, is that just .next and in a discrete system that means a single step minimally?
// Might want to catch the runtime error of a type somewhere, for instance arbitrary user input which needs to match some type.
// .flatten = .reduce(push_back)
// Automatic isomorphism
// Property decorators like: 'rendered secondary: instance?'



  // TODO .unrolled() -> Allows loops by defaul




def bidirectional
  +1
reverse
  -1
end

bidirectional!
+!(5) = -5

-1 <- x -> +1, how else
// inverse-1 notation used to go to the reverse direction of a method



// instantiations of a type using something like WaveFunctionCollapse
