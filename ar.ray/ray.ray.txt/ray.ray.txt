global = local

// Defined by context:
//  external = { do, goto, *, Node { `*`, `*`= } } // TODO: External should nestedly check local.definer
//  `arbitrary structure`=
//  def def(): Constructor - def defines 'return'
//  local
//  caller (= local) TODO Or is it nil
//  TODO Should be the constructor that calls into the program:
//  constructor (= local) = { name = "<text file name or nil>", definer (= local) } TODO Or is is nil?
//  definer (= local) TODO Or is it nil
//  return

def * = external // TODO any type Might not need to be externally defined. self-referential hypergraph-like structure
// TODO: Type of program is the same signature as Program and <T> extends Program -> Rename Program to Function? Program more general than function: it can be anywhere in some state.
def do<T < Program>(program: T) => T = external
class goto
  def (location: Program, predicate: Expression?) = external //TODO, Hijacks control-flow (Maybe if predicate is provided), which needs to be an option for functions, yielding control to a parameterless "program" -> or one where the parameters are already filled instead of goto the way of doing it.

  def if predicate: Expression = this<predicate: predicate>
end


def +def
  //TODO Define super in nested 'defs'
end

//TODO def
//TODO Array
//TODO 0..9.reduce(|) / "0".."9".reduce(|)
//TODO Decimal -> Binary / Binary -> Decimal & Decimal.String -> Binary
//TODO .map, .map on single value, effecting all .OR?; No that's the same as calling on the static def, the method meant for the instance. (Allow both variants)
//TODO "as String" should also accept "as Digit[]"
//TODO private
//TODO .zip/.zip_longest (ziplongest returns with _length to the max) for parameterless, and parameters [this, b].zip
//TODO push_back(void) should only create the array one longer.
//TODO .for on object, but it gets overwritten if type of Array. What is used then to get the object instead. Use .properties.for
//TODO 'def primary => location', should not implement primary. since location is a variable too.
//TODO Infinity
//TODO {} is a 'single'
//TODO Calling "()" should not call the () implementation, it's some special non-string token.
//TODO Disallow cast of None to item, because every method is overwritten with different return types. It's cast to an Item{} with all fields set to : None
//TODO .keys and .keys.enumerate to enumerate possible values of possible superpositions.
//TODO .values
//TODO .join works for arbitrary values
//TODO .empty = .length == 0
//TODO [] global is special, because local children would call it if defined locally, and global.[] does not refer to the array instantiation either, because we want global[property] to be accessible.
//TODO .sorted, given some order.

def void end

// The default functionality is that every variable is already Many.
// This however, allows for: `(predicate ? Many : 1) Object`.
def Many x = x

def namespace
  def `name = *`(definition: () => *)
    definer[name] = local
    name

    definition(local: local)

    return local
  end
end

def class
  //TODO Allow ==.instance_of class.

  def `name = *`(definition: (Args = *) => *)
    definer[name] = definition
    definition.name = name

    def (...args: Args)
      static = definition
      this = local

      definition(local: this, ...args)

      return this
    end

    return definition
  end
end

def single
  def `name = *`(definition: (Args = *) => *)
    static = class name, definition
    instance = static()

    definer[name] = instance
    instance
  end
end

class Node
  //TODO this/static shouldnt be defined for things like functions, so Node shouldn't be class?

  def `*` = external

  extends = private def < constructors: Array<(*) => *> => constructors.for constructor
    //TODO; By default call super if it's not called at the beginning/end of the block? & if parameterless
    this.private super &= constructor<local: caller>
    this.private super[constructor.name] = constructor<local: caller> if constructor.name
    //TODO Ensure the caller implements all undefined methods (unless abstract) abstract if any methods aren't defined. Is there ever a case where you want to extend abstract but only pass along the methods, yes?
    // TODO: How does type extension work?
  end

  def [] = Array<this>
  def ?? default = this as boolean ? this : default
  def ?
    //TODO Without parameter should return Option<>, with parameter :, boolean expression eval.
  end

  def as : == boolean = true //TODO: How to 'as the type boolean not an instance'

  // TODO Not is prefix?
  not = def Â¬ = Node{!= this} //TODO .not should be not instanceof ?, not boolean for instance.
  or = def | //TODO
  and = def & //TODO

  // Attach a normalizer
  static Normalizer = (x: static) => static
  normalizer: Normalizer?
  dynamically if normalizer
    +def =(x) = super(normalizer(x))
  dynamically on(normalizer) = this = this
end


  // TODO Dynamically on.
    +def =(x)
      super() // Trigger normalizer when it's changed.
    end
  end

// Allow syntax 'not Node'
def not node: * = node.not

//TODO Does Node < Expression or Expression < Node, either way we want both methods on both. And a Node, needs access to definitional structure
//   |-> .expand should expand the single node into the whole expression (or one layer down)

class Expression
  def == b //TODO
  end
  def != b = !(this == b)

  def while program = global.while(this, program)
end

class Iterable<T = *>
  for callback: (Args: *[]?) => *
    // Allow no Args, which is just iterating without using the variable
    //TODO: callback.parameter s = Array & Object, named at Object, .length etc. at Array; 'parameters' interprets as an array.
    //TODO + continue
    //TODO + return = caller.return
  end

  // Instead of all functions like .every/.map iterating over every 'Ray.value', we instead return the Ray itself.
  //TODO But things like .compact should still be on .value.
  //TODO Or you want a method on this like .location to access the location in the ray. (But then that would have to be filled) (And how to differentiate between others,  and not just this one)
  def $

  def any => this.reduce(|) = this.unordered.first
  def unordered =>
   this{$.every(.)}
    = //TODO Should be first available but how (if this is partial)

  // .find is just {filter}.first or {filter}.next .last, or .any = @.reduce(|)
  def find<ordered: boolean = false> //TODO
  // TODO .find.last

  def compact = this{!= None}
end
def AbstractDirectionality<TVertex> < Iterable
end

class Ordered<T = static> //Todo set T to caller's constructor
  def <= b: T = this == b || this < b
  def < b: T
  def >= b: T = this == b || this > b
  def > b: T
end

def Boundary<T>
  value: Boundary<T>? //TODO T could be on value, Or you want a specific type on Boundary
  end: Ray<T>
end
def Ray<T = Ray<T>> value: T? < AbstractDirectionality<Ray<T>>
  initial: Boundary<T> = Boundary<T>(end: this)
  terminal: Boundary<T> = Boundary<T>(end: this)

  static Unbounded //TODO
  end
end

private class Structure<T = Ray, HyperContinuations: boolean, HyperEdges: boolean = false> = Unbounded{count < Infinity}
  //TODO What's the value encoded on Edge?, and what's the value encoded on the boundaries? (Or do we always use edge)
  static Edge =

  static Vertex = Ray<T>{
    initial = (HyperContinuations ? Many : 1) Boundary{ //TODO These =, need to be ==.instance_of?
      end = (HyperEdges ? Many : 1) Vertex,
      value = (HyperEdges ? Many : 1) Boundary{
        end = (HyperEdges ? Many : 1) Vertex,
        value = (HyperEdges ? Many : 1) Vertex.initial
      }?
    },
    terminal = initial // By default a structure is symmetric
  } //TODO .unrolled

  static Unbounded{every(==.instanceof Vertex)} < AbstractDirectionality<Vertex>
    //TODO These set Vertex to a different value
    def acyclic //TODO Disallow loops
    def connected
    def consistent
  end
end
def Hypergraph<T = Ray> < Structure<T><HyperContinuations = true, HyperEdges = true>

end
def Graph<T = Ray> < Structure<T><HyperContinuations = true>
end
def Array<T = Ray> < Structure<T><HyperContinuations = false> = .acyclic.connected.consistent

end
def Tree<T = Ray> < Structure<T><HyperContinuations = true, HyperEdges = false> = .acyclic.connected.consistent
  // Tree has a single 'parent' on each vertex.
  static +def Vertex = super{initial: 1 Boundary{
    end: 1 Vertex,
    value: Boundary{
      end: 1 Vertex,
      value: Vertex.initial
    }?
  }} //TODO The Vertex.initial here should refer to the new value, not the old.
end

class if predicate: Expression, yes?: () => *
  def (else?: () => *)
    goto exec if predicate // 'if' can be used here, since goto defines a special if-block. It's not self-referential here.

    return else?(return: caller.return)
   exec:
    return yes?(return: caller.return)
  end

  // "then" is defined, so we can have an inline block like: "if expression then yes else no"
  def then yes: () => *
    this.yes = yes
    return this
  end

  def elsif expression: Expression, elsif: () => *
    def (else?: () => *) = this.else
      if expression
        return elsif(return: caller.return)
      else
        return else?(return: caller.return)
      end
    end

    def elsif = this.elsif<this: local>
    def else = this.else<this: local>

    return local
  end

  def else(else) = this<else: else>

  return this
end

class try program: () => *
  def <Args>(catch?: (args: Args) => *)
    error: Args?

    program(throw: (args: Args) => error = args; goto capture)
    return
   capture:
    catch(error) // TODO: Type-checker should know that it must be set in Ordered to get here.
  end

  def catch(catch) = this<catch: catch>
end
// Asserts & dynamic asserts, are simply part of the type definition.
def dynamically
  (expression: Expression) //TODO Dynamically the value is equal to the expression.
  (block: () => *)
  //TODO speculative.if: If the runtime doesn't yet know the value of the expression it can choose to just run the if-branch.
  //TODO Define <speculative.if> for the block/expression. speculative.if<assume: true>
  //TODO You could specutively, say it's either that operation or the other. and have the types depends with dynamically assert, xor'ed with the other value.
  //TODO Basically turn possibly infinite tasks into a branch of execution until we know.
  //TODO Parameterless functions are automatically dynamic.
  //TODO Infinite loops should be dismissed as possible values. If a loop is detected, stop committing resources there (until there's a change, then recheck)

  def assert(expression: Expression) = external
  //TODO dynamically assert expression if

  def if(predicate: Expression, yes?: () => *) = external //TODO
end
def assert(expression: Expression) = throw '' if expression // TODO


def while expression: Expression, program: () => void
  return do
   check:
    goto done if expression

    program(break: () => goto done, return: caller.return)
    goto check
   done:
    return
  end
end

// A function is a Node for which "(*) => *" is defined.
Function = +def Node{(Args: *) => Return: *}

  // do end.while() is a do-while loop. TODO Could also only define it on "() => void"
  def while expression: Expression
    return do ...args
     exec:
      this(break: () => goto done, ...args)

      goto exec if expression
    end
  end

  //TODO: Evaluate right-to-left f compose g compose h = f.compose(g compose h)
  â = def compose(g: (: g_Args) => Args) = (args: g_Args) => Return = this(g(args))
end

// Anything called on Option is automatically equivalent to 'variable?.'
def Option<T> = Some(value: T) | None
{ Some, None } = Option
+def Some
  def `* = property`
    ret = value[property]
    return ret == Some(*) ? ret : Some(ret)
  end
end
+def None
  def as : == boolean = false

  // TODO as boolean, and maybe other things defined on Node should still work, but how?
  def `*` = this
end

def Optional<T>
  def `*: TODO Defined on T` => Option<TODO T[property] type>
end
def Required<T>
  //TODO Strip option from T.
end
def Query<T>
  //TODO Set each property to the base class without defaults defined on T.
end


def Range
  // TODO Depending on the 'default space selected', range is either the refined Array, or a graph. (Graph because looped paths can exist)

  // TODO Range should be bounds which are Rays (already have the graph equipped)
  // TODO Infinity, is just the terminal reference (which doesn"t exist on the line) How to differentiate initial/terminal infinity.

  // TODO Implemented as things like .if() ?

  //TODO Implement range as method on empty string ."".
end

