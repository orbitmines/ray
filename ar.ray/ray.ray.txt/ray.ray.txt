// Defined by context:
//  external = { do, goto, *, Node { `*`, `*`= } } // TODO: External should nestedly check local.definer
//  `arbitrary structure`=
//  def def(): Constructor - def defines 'return'
//  local
//  caller (= local) TODO Or is it nil
//  TODO Should be the constructor that calls into the program:
//  constructor (= local) = { name = "<text file name or nil>", definer (= local) } TODO Or is is nil?
//  definer (= local) TODO Or is it nil
//  return

def * = external // TODO any type Might not need to be externally defined. self-referential hypergraph-like structure
// TODO: Type of program is the same signature as Program and <T> extends Program -> Rename Program to Function? Program more general than function: it can be anywhere in some state.
def do<T < Program>(program: T) => T = external
class goto
  def (location: Program, predicate: Expression?) = external //TODO, Hijacks control-flow (Maybe if predicate is provided), which needs to be an option for functions, yielding control to a parameterless "program" -> or one where the parameters are already filled instead of goto the way of doing it.

  def if predicate: Expression = this<predicate: predicate>
end
def [args: Array] => args

def < constructors: Array<(*) => *> => constructors.for constructor
  //TODO; By default call super if it's not called at the beginning/end of the block? & if parameterless
  caller.private super &= constructor<local: caller>
  caller.private super[constructor.name] = constructor<local: caller> if constructor.name
  //TODO Ensure the caller implements all undefined methods (unless abstract) abstract if any methods aren't defined. Is there ever a case where you want to extend abstract but only pass along the methods, yes?
  // TODO: How does type extension work?
end

def +def
  //TODO Define super in nested 'defs'
end

global = local

//TODO def
//TODO Array
//TODO 0..9.reduce(|) / "0".."9".reduce(|)
//TODO Decimal -> Binary / Binary -> Decimal & Decimal.String -> Binary
//TODO .map, .map on single value, effecting all .OR?; No that's the same as calling on the static def, the method meant for the instance. (Allow both variants)
//TODO "as String" should also accept "as Digit[]"
//TODO private
//TODO .zip/.zip_longest (ziplongest returns with _length to the max) for parameterless, and parameters [this, b].zip
//TODO push_back(void) should only create the array one longer.
//TODO .for on object, but it gets overwritten if type of Array. What is used then to get the object instead. Use .properties.for
//TODO 'def primary => location', should not implement primary. since location is a variable too.
//TODO Infinity
//TODO {} is a 'single'
//TODO Calling "()" should not call the () implementation, it's some special non-string token.
//TODO Disallow cast of None to item, because every method is overwritten with different return types. It's cast to an Item{} with all fields set to : None
//TODO .keys

def void end

// The default functionality is that every variable is already Many.
// This however, allows for: `(predicate ? Many : 1) Object`.
def Many x = x

def namespace
  def `name = *`(definition: () => *)
    definer[name] = local
    name

    definition(local: local)

    return local
  end
end

def class
  def `name = *`(definition: (Args = *) => *)
    definer[name] = definition
    definition.name = name

    def (...args: Args)
      static = definition
      this = local

      definition(local: this, ...args)

      return this
    end

    return definition
  end
end

def single
  def `name = *`(definition: (Args = *) => *)
    static = definer.class name, definition
    return static()
  end
end

class Node
  def `*`=(value) = external //TODO These dont need to be external
  def `*` = external

  def [] = Array<this>
  def ?? default = this as boolean ? this : default
  def ?
    //TODO Without parameter should return Option<>, with parameter :, boolean expression eval.
  end

  def as : == boolean = true //TODO: How to 'as the type boolean not an instance'

  // TODO Not is prefix?
  not = def ¬ = Node{!= this} //TODO .not should be not instanceof ?, not boolean for instance.
  or = def | //TODO
  and = def & //TODO
end

//TODO Does Node < Expression or Expression < Node, either way we want both methods on both. And a Node, needs access to definitional structure
//   |-> .expand should expand the single node into the whole expression (or one layer down)

class Expression
  def == b //TODO
  end
  def != b = !(this == b)

  def while program = global.while(this, program)
end

class Iterable<T = *>
  for callback: (*[]) => *
    //TODO: callback.parameter s = Array & Object, named at Object, .length etc. at Array; 'parameters' interprets as an array.
    //TODO + continue
    //TODO + return = caller.return
  end

  def compact = this{!= None} //TODO For abstract directionality both ways?.
end
def AbstractDirectionality<TVertex> < Iterable
end

class Ordered<T = *>
  def <= b: T = this == b || this < b
  def < b: T
  def >= b: T = this == b || this > b
  def > b: T
end

def Boundary<T>
  value: Boundary<T>? //TODO T could be on value, Or you want a specific type on Boundary
  end: Ray<T>
end
def Ray<T = Ray<T>> < AbstractDirectionality<Ray<T>>
  initial: Boundary<T>
  value: T?
  terminal: Boundary<T>
end

private class Structure<T = Ray, HyperContinuations: boolean, HyperEdges: boolean = false> = Unbounded{count < Infinity}
  static Vertex = Ray<T>{
    initial = (HyperContinuations ? Many : 1) Boundary{
      end = (HyperEdges ? Many : 1) Vertex,
      value = (HyperEdges ? Many : 1) Boundary{
        end = (HyperEdges ? Many : 1) Vertex,
        value = (HyperEdges ? Many : 1) Vertex.initial
      }?
    },
    terminal = initial // By default a structure is symmetric
  } //TODO .unrolled

  static Unbounded{every(==.instanceof Vertex)} < AbstractDirectionality<Vertex>
  end
end
def Hypergraph<T = Ray> < Structure<T><HyperContinuations = true, HyperEdges = true>
end
def Graph<T = Ray> < Structure<T><HyperContinuations = true>
end
def Array<T = Ray> < Structure<T><HyperContinuations = false>
  //TODO: Disallow loops, .connected, .consistent
end
def Tree<T = Ray> < Structure<T><HyperContinuations = true, HyperEdges = false>
  //TODO: Disallow loops, .connected, .consistent
  // Tree has a single 'parent' on each vertex.
  +def Vertex = super{initial = 1 Boundary{
    end = 1 Vertex,
    value = Boundary{
      end = 1 Vertex,
      value = Vertex.initial
    }?
  }} //TODO The Vertex.initial here should refer to the new value, not the old.
end

class if predicate: Expression, yes?: () => *
  def (else?: () => *)
    goto exec if predicate // 'if' can be used here, since goto defines a special if-block. It's not self-referential here.

    return else?(return: caller.return)
   exec:
    return yes?(return: caller.return)
  end

  // "then" is defined, so we can have an inline block like: "if expression then yes else no"
  def then yes: () => *
    this.yes = yes
    return this
  end

  def elsif expression: Expression, elsif: () => *
    def (else?: () => *) = this.else
      if expression
        return elsif(return: caller.return)
      else
        return else?(return: caller.return)
      end
    end

    def elsif = this.elsif<this: local>
    def else = this.else<this: local>

    return local
  end

  def else(else) = this<else: else>

  return this
end

class try program: () => *
  def <Args>(catch?: (args: Args) => *)
    error: Args?

    program(throw: (args: Args) => error = args; goto capture)
    return
   capture:
    catch(error) // TODO: Type-checker should know that it must be set in Ordered to get here.
  end

  def catch(catch) = this<catch: catch>
end
// Asserts & dynamic asserts, are simply part of the type definition.
def dynamically
  def assert(expression: Expression) = external
  //TODO dynamically assert expression if

  def if(predicate: Expression, yes?: () => *) = external //TODO
end
def assert(expression: Expression) = throw '' if expression // TODO


def while expression: Expression, program: () => void
  return do
   check:
    goto done if expression

    program(break: () => goto done, return: caller.return)
    goto check
   done:
    return
  end
end

// A function is a Node for which "(*) => *" is defined.
Function = +def Node{(Args: *) => Return: *}

  // do end.while() is a do-while loop. TODO Could also only define it on "() => void"
  def while expression: Expression
    return do ...args
     exec:
      this(break: () => goto done, ...args)

      goto exec if expression
    end
  end

  //TODO: Evaluate right-to-left f compose g compose h = f.compose(g compose h)
  ∘ = def compose(g: (: g_Args) => Args) = (args: g_Args) => Return = this(g(args))
end

// Anything called on Option is automatically equivalent to 'variable?.'
def Option<T> = Some(value: T) | None
{ Some, None } = Option
+def Some
  def `* = property`
    ret = value[property]
    return ret == Some(*) ? ret : Some(ret)
  end
end
+def None
  def as : == boolean = false

  // TODO as boolean, and maybe other things defined on Node should still work, but how?
  def `*` = this
end

def Optional<T>
  def `*: TODO Defined on T` => Option<TODO T[property] type>
end
def Required<T>
  //TODO Strip option from T.
end
def Query<T>
  //TODO Set each property to the base class without defaults defined on T.
end

def Integer<n> = sign = "-"?, integer = Positive
  static def Positive = Array{length == n}().last~
end

private class Digit = String[].reduce(|)

  def value(digit: this = this)
    array = this.reduce(array = [] => array.push_back(void))

    this.for d
      `d` = this{<= d}.reduce(cursor = array => cursor.next)~
    end

    return local[digit]
  end
end

// TODO: Strings as a definition depend on number, circularity here.
{
  Binary: Digit = "0" | "1"
  Ternary: Digit = "0".."2".reduce(|)
  Quaternary: Digit = "0".."3".reduce(|)
  Quinary: Digit = "0".."4".reduce(|)
  Senary: Digit = "0".."5".reduce(|)
  Septenary: Digit = "0".."6".reduce(|)
  Octal: Digit = "0".."7".reduce(|)
  Nonary: Digit = "0".."8".reduce(|)
  Decimal: Digit = "0".."9".reduce(|)
  Undecimal: Digit = ("0".."9", ("a" | "A")).reduce(|)
  Duodecimal: Digit = ("0".."9", ("a" | "A")..("b" | "B")).reduce(|)
  Tridecimal: Digit = ("0".."9", ("a" | "A")..("c" | "C")).reduce(|)
  Tetradecimal: Digit = ("0".."9", ("a" | "A")..("d" | "D")).reduce(|)
  Pentadecimal: Digit = ("0".."9", ("a" | "A")..("e" | "E")).reduce(|)
  Hexadecimal: Digit = ("0".."9", ("a" | "A")..("f" | "F")).reduce(|)
}.for Base, digit

  //TODO Because String has digit as String defined, any Array of digit Strings should automatically be defined, to as String too. with .map
  +def String = `Base`.Digit
    def as : == `Base`.Digit.value = `Base`.Digit.value(this)
  end
  //TODO String as Binary.Positive = "0101010" = Digit.value[] = Positive
  // TODO: Binary.Positive as String; Automatic isomorphism

  class `Base` < number = sign = "-"?, integer = Positive

    //TODO Equip a default directionality. (Line: One with forward/backward from a specific point, but it isn't necessarily selected there.)

    //TODO Because sign is a String, Positive is castable to a String, `Base` is castable to a String
    static String = static as String

    static Digit = digit
    //TODO This should not be in the constructor, but taken outside of it.


    // TODO Some for of this.toString which would be sign.toString, integer.toString which would use 'String'. But then for static, on the types.


    // We use 'Positive' here, since a 0, in this construction can be signed. (Even though for most operations that difference won't matter)
    static class Positive = integer = Array<Digit.value>
      static def String = Array<Digit as String>

      def `fraction = Positive.String` => Real.Positive = integer, ".", fraction

      static class Multiple<exponent: Positive> = Positive
        def as :== Positive = integer << exponent //TODO This is a decimal shift, when working with binary values you want to access them as binary if you want that shift.
      end
    end

    static class Real = sign = "-"?, real = Real.Positive
      static String = static as String

      static class Positive = integer = `Base`.Positive, ".", fraction = `Base`.Positive
        static String = static as String

        //TODO Support non-integer multiple exponents for reals.
        static class Multiple<exponent: `Base`> = Positive
          def as :== Positive
            if exponent == 0
              this
            elsif exponent > 0
              integer, fraction.0 ?? 0, ".", fraction[1..]
            else
              integer[..-1], ".", integer[-1] ?? 0, fraction
            end
          end
        end
      end

      static class Multiple<exponent: `Base`> = Real
        def as :== Real = sign, real as Positive.Multiple<exponent>
      end
    end

    static class Multiple<exponent: Positive> = `Base`
      def as :== `Base` = sign, integer as Positive.Multiple<exponent>
    end

    if Base == "Decimal"
      private multiples = {
        qm = -30 // quectometer
        rm = -27 // rontometer
        ym = -24 // yoctometer
        zm = -21 // zeptometer
        am = -18 // attometer
        fm = -15 // femtometer
        pm = -12 // picometer
        nm = -9  // nanometer
        µm = -6  // micrometer
        mm = -3  // millimeter
        cm = -2  // centimeter
        dm = -1  // decimeter
        m = 0    // meter
        dam = 1  // dekameter
        hm = 2   // hectometer
        km = 3   // kilometer
        Mm = 6   // megameter
        Gm = 9   // gigameter
        Tm = 12  // terameter
        Pm = 15  // petameter
        Em = 18  // exameter
        Zm = 21  // zettameter
        Ym = 24  // yottameter
        Rm = 27  // ronnameter
        Qm = 30  // quettameter
      }
      private SI = multiples.keys.reduce(|)

      // Allows syntax 1m
      global.def `digits: Decimal.Positive.String, si: SI` => Distance.Positive = digits, si
      // Allows syntax 1.0m
      +def Decimal.Positive
        def `fraction: Decimal.Positive.String, si: SI` => Distance.Real.Positive = integer, ".", fraction, si

        //TODO Should overwrite number.def`node: not String` since it's more specific
        // Allows syntax 1 m
        def `si = SI` => Distance.Positive = this, si
      end
      // Allows syntax 1.0 m
      +def Decimal.Real
        def `si = SI` => Distance.Real.Positive = this, si
      end

      static class Distance = `Base`.Multiple<exponent = multiples[si]>, si = SI
        static class Positive = `Base`.Positive.Multiple<exponent = multiples[si]>, si = SI
        static class Real = `Base`.Real.Multiple<exponent = multiples[si]>, si = SI
          static class Positive = `Base`.Real.Positive.Multiple<exponent = multiples[si]>, si = SI
        end
      end
    end
  end
end
Distance = Decimal.Distance // re-export as Distance

+def Binary.Positive

  def ~! = this.map(!)
  def ~`operator: boolean.Operator.Binary` b: Binary.Positive = this.reverse.zip_longest(b.reverse).map(l, r => (l ?? false)[operator](r ?? false)).reverse
  def ~`operator: boolean.Operator.Binary` b: Binary.Positive{.length == length} = this.zip(b).map(operator) //TODO: Or can the compiler deduce the reversing stuff is not necessary?
end

def `digits: Decimal.Positive.String` => Decimal.Positive = digits
+def Decimal.Positive
  def `fraction: Decimal.Positive.String` => Decimal.Real = integer, ".", fraction
end

def 0`"x" | "X"``digits: Hexadecimal.Positive.String` => Hexadecimal.Positive = digits

//TODO: Possibly move these primitives to specific languages, and only work with arbitrary-length in the default case.
//TODO: -b: Something uX might only implement b: uX, casts lose information and likely need to overflow
def u`length: Decimal.Positive.String` = Binary.Positive{.length == length}
  // TODO Number arithmetic
  // - overflow, what to do? mod, or>?
end
def i`length: Decimal.Positive.String` = Binary.Positive{.length == length} // TODO, Use Binary vs Binary.Positive
  // TODO Number arithmetic
end

class number < Ordered<number>
  def - => number
  def - b: number => number

  // Allows for the syntax 1 Object
  def `node: not String` = node{@.count == this}

  // TODO Generic number interface which others should extend, things like >/< should come from another interface which is "NumberLine"
  // TODO Infinity is a looped integer. -infinity a .reverse"d loop. .reverse needs to be preserved for them to be differentiated?
  // TODO: external defines that number > number is done by some other operator, not looking through successors/predecessors.
end

class boolean = false, true = Binary.Digit.value // TODO This should automatically implement "0" | "1" as boolean, through Binary.Positive. : Generalized to: Anything that is implementing Array<T>, like Positive, should also apply to just a T.
  // TODO Verify that these are correct work for all cases.

  static class Operator = Unary | Binary
    static Unary = "!"
    static Binary = "&&" | "||" | ("nand" | "!&") | ("nor" | "!|") | ("xor" | "x|") | ("xnor" | "x!|")
  end

  def !
  or this !& this
  or this !| this
  or this x| true
  or this x!| false
  end

  def && b: boolean
  or !(this !& b)
  or !(!this || !b)
  end

  def || b: boolean
  or !(this !| b)
  or !(!this && !b)
  end

  nand =
    def !& b: boolean
    or !(this & b)

    // An implementation using goto"s so that a conditional goto is the only (necessary) primitive.
    or
      goto 2nd_check if a
      goto 1
     2nd_check:
      goto 0 if b
   1: return true
   0: return false
    end

  nor =
    def !| b: boolean
    or !(this || b)
    end

  xor =
    def x| b: boolean
    or !(this x!| b)
    or (this & !b) || (!this & b)
    end

  xnor =
    def x!| b: boolean
    or !(this x| b)
    end
end
{ false, true } = boolean // Could also be 'false, true = boolean' in this case.

//TODO Maybe an instantiation of String/char, which doesn't say how exactly it's implemented (u32/UTF), to signal it's not important that that system retains its place. 'Name' would be where this could be used.
class String = Unbounded{length < Infinity}
  static NonEmpty = String{length > 0}
  static Unbounded = char[]
    ()
    (block) //TODO Accept "String" \n property='b' end
    //TODO: Any Array definition is an expandable object, which at one level of description has that new Node, on the other the array of things.
    //TODO: Want to allow things like String.push_back(u32), but it should encapsulate the u32 into an expandable single node.

    // TODO How do other languages implement String?

    def ignore_case //TODO Return superposition with ignored case
  end
end
class char = u32
  dynamically assert this < 0x110000 & !(0xD800 <= this <= 0xDFFF)
end

def Range
  // TODO Depending on the 'default space selected', range is either the refined Array, or a graph. (Graph because looped paths can exist)

  // TODO Range should be bounds which are Rays (already have the graph equipped)
  // TODO Infinity, is just the terminal reference (which doesn"t exist on the line) How to differentiate initial/terminal infinity.

  // TODO Implemented as things like .if() ?

  //TODO Implement range as method on empty string ."".
end

