index | distance (start = first) =>


//TODO Bidirectional function like ray but only single step: l <= (x) => r, ambiguity with <=

local @= location to change the location the code gets executed



//TODO Version control
Two merged branches with a decided order (so non-parallel) is creating a new branch with values of .expand on the old changes = in their respective branches
you want a .expand across version control histories. So my local keystroke history collapses to a single 'commited' history which the same on .expand but then for that particular repository so we need .expand(location) or something
|-> would be across branches, since local keystroke history is just a branch on top of the current branch, then a commit would all those changes since tha last commit and switch that branch to it.
Commit changes is rewriting the deltas from keystrokes to whole strings. So need rewrite logic defined for that somewhere
// TODO Casaul ordering of functions, or somehow having a particular instantiation of a function and then checking whether another instantiation is before it. Whether concurrent and the like.
//TODO Things like, we enact changes on functions/etc.. which are in turn saved somewhere to the current version, then we need a way to say : update these functions on those locations. By saying 'local.keys except x' @ 'All remotes' = 'new version'
//TODO Additional fields like timestamp are in some global order (some repository which keeps track of that)
//TODO Want things like only commit to history if it's a significant change, like the NW instead of joystick position
//TODO %/.history, for inventory, should turn the whole inventory nested, back in time.
//TODO Individual history per field, but a branch takes nestedly the history with it?
//TODO Needs to be at least git functionality
//TODO Changed signatures/types/functionality
//TODO Transaction system also makes use of this?
//TODO Every change is a commit, but a group of changes can be bundled into another commit (to mimic git)
//TODO  |-> That bundling is just an index to certain changes for a git, and parent/child commits are the next place that index is specified.
//TODO Branches/tags are indexed commits, branch is a moving index to some latest change.
//TODO .index maps to an object which as a type returns any properties with any subgraph/part of the object. (or another index)
//TODO Global timeline means what? (Option when reverting locally to revert everything around it to that too)
//      |-> Up to some parent?
//      |-> reverse of .expand (.collapse but then just a higher-level of description)
//      |-> This also includes setting already made changes into a new group which then becomes the 'git commit'
//TODO Needs a history conversion to something like git to support it, both ways.
//TODO Is .history an acyclic Tree.Vertex?
//TODO What if I set a variable with a history and I want to retain that history (and not the history of the variable it's set to)
   //TODO Or retain both?
   //TODO The .=(value) in history (encoded on the edge) carries with it the information of where it came from, with that history attached.
//TODO; Is syncing just another object with a different location, probably yes. So .save syncs an object. (What if they hasve similar histories, use that to check which changes need to be applied) - What if they don't overlap at all, you still want then to use = on all the fields.
//  |-> Many sync locations ; mirrors. Managed inventories are mirrors. .save = .push
//TODO Is syncing just setting that 'old object = new object', and then figuring out how the histories overlap (which is default behavior for =.)
//TODO The timestamp is just Ordered. Can only merge two repositories (and reorder the events) if ordered is the same type = or an equivalence exists between the two types.
//TODO -> That's just an overlapping graph, which is filled by looking up in the history graph. .previous. < this < .next. ; require two simultaneous events to be on two branches, which are then immediately merged. ; what if there';s a merge conflict between these two. There won't be because it's two different repositories.
//TODO -> What if I have a repository with a global order, and one which is a child repository, and I want to merge them, then there's a possible merge conflicts with two simultaneous events. -> Or are all the fields just .OR/.AND'ed.
//TODO What happens to the two merged branches. If no conflicts, keeping them parallel in the history is fine.
//TODO   |-> And what happens when there's a conflict.
//TODO Uncommitted files, and staged changes, like those added with git add, are simply visibility set to local/private.
//TODO    |-> Remove files from repository by changing visibility.
//TODO  -> Doesnt work with the following: v -- But what if: "local"/"private" & not -active-branch-
//TODO We have a "local" branch with changes keystrokes and all. Then the action of committing is, setting to another "local" branch the collective changes (or all individual keystrokes).
//TODO -> Then pushing is just remote = local commited branch.
//TODO Allow changes to history, you'd use that for 'another "local" branch the collective changes', not the one with keystroke information.
//TODO History is aware of other places the same inventory is kept. -> So the .location of the inventory.
//TODO  |-> It's different than location in some way, since we don't continuously update is necessarily.
//TODO Cherry-pick is a chain of commits apply to current branch
//TODO Managed inventory is mirror, but what if it's distributed like a 'remote repository', where both can write. You'd want it to be to the same object with different locations.
//TODO   |-> Same object with different locations, vs different but synced objects
//TODO   |-> If any locations are remote, behind the scenes, we implement it as a local repository and sync with different location
//TODO     |-> Location needs to be aware of which instance it's pointing to?
//TODO     |-> Functions might be remote functions like http API calls -> Abstract network away
//TODO   |-> Local might not know the value of access, only that it itself is included? ; How to support that?
//TODO   |-> Every object has one with location for local instance memory, and remote locations.
//TODO Keep track of where which remote is, or include that in some update. Only send required updates.
//TODO Last updated, things like that?
//TODO Define mirrors which aren't defined on the other locations, so only define it for locally (visibility = "local"?)

//TODO So caller could be at a location with a different instance too.
//TODO Different values for fields based on who is looking at them. So access 'caller ==.instance_of global.entity' for instance.
//TODO  -> Dynamic variable? -> No. change it to a parameterless method

//TODO Or is it visibility for anyone with the encryption key? How's that defined.
//TODO Can have many encryption keys to access the history of the chat.
repository defines encryption? (Not necessarily individual items?), No not necessarily. Can be child values doing their own thing.
//TODO Can have visibility to the encrypted value, but not the actual value, how's that difference known
//Different visibility for different entity (callers) //TODO Different value for different entities.

//TODO Access is public, but only certain types of operations are allowed, like only +1, and only one per account, and only an account itself can set it, how to verify that?.
//      -> This would be distributed db for likes.
// TODO: Say a public copy a that 'likes' record is hosted by the player, copied by the Ether server, and then another player
// TODO Is allowed to have a 'private' commit to that record. So only the player can access it, but it acts as if it was on top of that. So commit.visibility is possible.
// TODO -> What is it was a blockchain, that wouldn't work because the previous commit hash or the next one wouldn't have the information.
// TODO   -> How to handle that? Always appended after the current history? But what if there's anotherr later overwrite of that value you'd want to overwrite your change. How to differentiate between wanting that change vs not, or in the +1 like case it doesnt matter, when does it matter?
//TODO    Y9ou could have something like a distributed chat, and you'd want something like if it was received late, insetad of putting it back inserted at that place in the commit chain, put it last and notify the channel with 'was sent 3 hours ago' then a context window from the perspective of that chat, where it is inserted in between. (And in message history insert it there as a, 'was received later but wass inserted at this time'
//TODO -> SO YOU WANT TO ALLOW DIFFERENT STATES IN REPOSITORIES, BUT STILL ALLOW THEM TO WORK TOGETER. (mY LOCAL HISTORY IS DIFFERE4NT THAN YOURS, BUT STILL NBEEW UPDATES ARE PUSHED TO BOTH.),M SAY FOR WHEN I KNOW I SENT MY MESSAGE BEFORE/AFTER SOME OTHER MESSAGE, BUT YOURS WAS SENT AROUND THE SAME TIME. WE MIGHT NOT AGREE ON THE ORDER.
//TODO Encryption is just some equivalent (with key) but differently structured value.
//TODO What are some other things that follow that pattern?: It's Setting a variable like visibility to something that can cast down to Entity like the string "private".

//TODO Private commits can be done, even if the access is not set to you.

//TODO What if history is too expensive to keep, for instance all the +1 likes per item. How does it work for the distributed case?
//TODO BVut then what do you do with location information? It's stored on player, not at the location? Or you have a history of stareting locations, with changes applied to them, Instead of a player variable at every change. So location would have to compute the player history. So you have to have access to a specific version of the world in this case.
//TODO Location history is an overlapping graph.
//TODO How to store distributed approximations of some value, like a blooming filter for likes. How do I indicate I don't mind an approximate value.

//TODO Cached .length for instance, so its history is deduced from going to different history values (since it's a function), but it can have cached history. (HOw to differentiate between the two)

//TODO Instead of having different variables for the different locations, commits might be private, different visibility (so branches might be private) and if there's a clash like both remote and me create the same branch, a merge needs to happen.
//TODO -> Want to support both.

//TODO Just like conflictin histories in chats still working, you have unordered arrays, which allow any order and should still work together.

//TODO Broadcast which partial information you have on your node. (This is what sharding does)

//TODO A quest which is like peer.share_information unless already has that information, where peer. is 'generating', or peers change dynamically and we want to dynamically share it with peers if we have that information

// What if I have a history on aq top-level parent and I want
   to inject it an another top-level parent object.
   Just all changes in a single step (.expand?)
   (Basically +'ing repositories) -> Each change might have additional timing information, so we
   could shuffle that order around.
// What if I want a subdirectory to be it's top-level directory.
   WHat happens to the history of its top-level parent?
   (Like how the git history vs a top-level directory works now)
   Then the whole history subgraph is in a single .expand and
   applied as a single step on the top-level directory.
   Still a particular branch is selected in the top-level directory
   about the sub-directory. So it has a history of selecting a branch
   then selecting another branch. (And being tied to the latest value
   of that branch). So instead of every change being tracked, only the
   branch changes are tracked.
   What would be the use-case for the top-level not deciding on a
   branch and .OR'ing possibilities

// Or define it as, the top-level parent has an order
   any substructure is just a subgraph of that
   graph. That's probably better.
   {.location == ''}, inventory might not be filled. It might just be
   somewhere in a world at location without inventory.
// what if the object directory is mentioned elsewhere
   as a reference. The the location would be set, but that doesn't
   count as inventory?. What if it does?

// You want to be able to start a new top-level repository with or without the subgraph of all the previous changes
   to that directory.
// Branch is a pointer to an edge on where to continue it, the current value being on .value.
   Because we can have different branches started from that same vertex. Which could
   continue on their own. The current branch keeps being at that vertex ( not continuing in those
   new branches).
// Variables are not top-level, but the context is. (So the context has a global order
   of variable changes within it) What about variable changes outside it? Those should
   also be recorded in its order? (so we can undo it) -> It just references other commits
   in external 'repositories'.
// Visibility, might only want parts of a history to be visibile to certain entities.
   Like: A branch and it's sucessive updates. ("private branch")
// You want the option to merge many in-sequence commits into a single one. Like we have
   history on every keystroke of a string, but we just want to set it to the information of the new string.

// But what if the world still wants a global order.
   Then parent inventory is set to the world. So changes are tracked there, not locally.

// Big one: what if the change, changes the location? Like graph spatial rewrite.
   -> History on Edges?

   Then: What if access to a location's history is lost.
// TODO Something like .push_back is set on the array, but the change effects an Edge?
// TODO Is basically two levels of description: One is push_back which is equivalent to .last.terminal.value =. which is equivalent to a change at .last to .terminal.value =.

// What about making a new repository out of a child directory which has it's oiwn history. Could do "from this point" it's a new repository. Or we could take the subgraph order from the parent. and then continue with that.

// .% tracks across many values?
   because a parent tracks its children
   How to differentiate location between children
   for things like the subgraph of the top-level history
   graph.

// Merge conflicts.
// want certain merge conflicts to be resolvable through some other means. Say both writing to a counter, you'd stack the +1 changes.
   (this would be taking the common ancesstor, then applying all changes from both branches in any order)
   (This isn't really pratical thouogh because of large numbers, so instead you would do what?)
   (In this case you';d have to be able to differentiate between two different +1 on the same number. How are those events differentiated, time, caused by etc..)
   (caused by is stored on player, so need somne way to get Player.All{} check it there)

//Type conflicts are merge conflicts, for example of distributed databases


// Version control allows local changes which ignore only +1 requirements, but those changes dont get sent upstream






class Item
  // how it's made, how it's discovered, how it's constructed.
  //  -> The non-evaluated function so **%
  //TODO What does discovered by a player look like?

  // Items require Quests ; In order to find items you need quests.
  //Similar to function, who called?
  obtained_by: Quest

  issuer: World = global.desktop
  certificate: Certificate

  //TODO -> So you want certificates to be given for having been at certain places. (Then on those places give them out as an item), Or only that managed inventory has access, so acts as a certificate
  //TODO A specific directory for "Managed by other's"

  //TODO We have copy as well, but we could also copy by ref, or have both set refs to a single one.
  //  -> All object setting/getting becomes moving between inventories.
  def move location: Location
  //TODO Transaction
  end

  //TODO If has mirrors, schedule quests (can free memory; resource after quest is completed, can be a quest goal)
  dynamically if inventory
    // TODO On change, if has access, save. Otherwise, save local copy.
    def save
      // TODO If inventory has changed, we don't remove, -> keep track of all changes on item
      //TODO Write to inventories
    end
    def delete

    end
  end

  def as : Shape TODO: Shape is just a type of graph implemented on .ray, nD-object, render function. Including a 2D-icon

  // Items are Quests ; Your items might be quests to find for others.
  def as :== Quest = this ==.instanceof Quest ? this : TODO

  // Items are Minimaps ; We can look at items from the outside to get a perspective, ..., overview of what it is.
    // TODO Perspective switch to a 'high-level overview'
end


public key Player{public_key & challenge that they have the private key, like a timed message, or a specifically tailored message by this instance}


def Quest
  // Require things like "I've communicated with these replica servers before making this calculating -> when strong consistency is required." -What if they're not online, like offline players storage etc.. (For certain things like calculating player statistics which are kept local only, it would be "make sure your instance checks in with out server before X time", and we'll consider your changes) - So these are quests to complete for the replica servers


  // schedule quests (can free memory; resource after quest is completed, can be a quest goal)
  // Version control needs a way to access and what to do with paused functions

  dynamically
    sub = this[`property: *`]

    // Speculatively merge a detected loop in the inventory, if not found, we recursively describe it: A.B.A.B.A.B...
    speculative if<assume: false> current = (<-inventory){== sub}
      inventory.push<edge: .value = property>(current)
    else
      current = Ray(sub)
      inventory.push<edge: .value = property>(current)
      sub.inventory &= current
    end
  end
  //TODO Speculative //= Quests
  //TODO Speculative programs which return something in turn possibly reevaluate all effects caused by its result being changed.


  // Quests require Items ; Cannot see, ..., complete a quest, ..., puzzle without certain items.
  revealed_by: Item // TODO Might be an item owned by another Entity

  //TODO Which classes of quests can be made?

  // TODO Conditions which need to be met before the quest can be completed.

  // Quest rating
  // - Difficulty rating -> Needs some idea of relative difficulty for the Entity
  //   - Difficulty also has time information in certain cases; how long does it take.
  // - Effectiveness rating -> In the case of effecting other items.

  // Quest selection by NPCs
  // - Difficulty rating vs reward.

  // Creating quests for one-self, or others.

  //TODO Quests are also, places to spend resources on infinitely generating/speculative execution places
  //     -> If the result would be found, would that result into efficiency, or what else?

  // Rewards
  // - When is a quest completed?
  //    - Entity checks completion.
  //    - Self checks completion
  // - What is rewarded?
  //   - Nothing, only a certificate on the quest.
  //   - Item(s) issued by an Entity.
  //   - 'Found item' might itself reveal more Quests -> This is infinitely generating.
  //   - 'Found item' might affect other items. -> Predicted, vs actual effect.
  //     - What items are effected?
  //     - How are they effected?
  // - How is quest completion checked?
  //   - An Entity checks whether a function holds for another Entity (based on their knowledge for that entity).
  //        -> (For instance: Whether some item is in their inventory, which is exposed to the Entity, which is a key)

  // TODO Do we know the reward (Item) of this quest -> And if so how does knowing this reward prevent us from already having it, and do we know the Effect-> of completing it?

  def completed => boolean = completed?.certificate
    //TODO Certificate might only be temporary, so time information on it. (Might have to repeatedly complete a quest, say a login) Or certificate might no longer be valid.
    certificate: Certificate?
  end
  def active = !completed
end



class Entity
  inventory: 1 Inventory // TODO *in* an inventory vs *has* an inventory.


// For strreaming, a player has a particular location which is the streaming location , that is being broadcast.
// TODO So watching a stream is simply following that location.

def Certificate
  secret: Something
    visibility = //TODO Should only be default, can be overwritten
  end
  //TODO pub/secret
  issued_by: Entity
  issued_on: Date//TODO
end


//TODO Version control, after change the filter would include/exclude new entries, like a new maxlength of username, add merge clause on how to deal with it. Basically database changes are merge conflict resolves

