// Defined by context:
//  external = { do, goto, *, Node { `*`, `*`= } } // TODO: External should nestedly check local.definer
//  `arbitrary structure`=
//  def def(): Constructor
//  local
//  caller (= local) TODO Or is it nil
//  TODO Should be the constructor that calls into the program:
//  constructor (= local) = { name = "<text file name or nil>", definer (= local) } TODO Or is is nil?
//  definer (= local) TODO Or is it nil

def * = external // TODO any type Might not need to be externally defined.
// TODO: Type of program is the same signature as Program and <T> extends Program -> Rename Program to Function? Program more general than function: it can be anywhere in some state.
def do<T < Program>(program: T): T = external
def goto(location: Label) = external //TODO, Hijacks control-flow, which needs to be an option for functions, yielding control to a parameterless 'program' -> or one where the parameters are already filled instead of goto the way of doing it.

global = local

//TODO class
//TODO if
//TODO def
//TODO Label (has a name & program)

//

def void end

def Node
  def `*`=(value) = external
  def `*` = external
end

//

def while expression: Expression program: () => void
  return do
   check:
    goto done if expression

    program(break = goto done)
    goto check
   done:
    return
  end
end

class Expression
  def while program = global.while(this, program)
end

class Program // TODO: Program is like Ray, it's a function equipped with an AbstractDirectionality which is the control-flow graph
  def (*): * = external // TODO: Because Program extends (*) => *, it automatically extends Function.

  // do end.while() is a do-while loop. TODO Could also only define it on '() => void'
  def while expression: Expression
    return do ...args
     exec:
      this(break = goto done, ...args)

      goto exec if expression
    end
  end
end

// A function is a Node for which '(*) => *' is defined.
def Function<(Args = *) => Return = *> = Node<(Args) => Return>
end