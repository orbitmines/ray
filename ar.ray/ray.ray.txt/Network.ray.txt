namespace Network

              // ETHER
  DEFAULT_PORT = 37839

  class IP
    static NUMBER_OF_SEGMENTS => Decimal.Positive
    static SEGMENT_LENGTH => Decimal.Positive
    static NUMBER_OF_BITS = NUMBER_OF_SEGMENTS * SEGMENT_LENGTH

    static +def Segment
      static Binary = Binary.Positive{length == SEGMENT_LENGTH}
    end

    static String = static as String

    def segments => Segment[]

    def binary_form => Binary.Positive = segments as Segment.Binary[]

    // CIDR notation
    def / prefix_length: Number{0 <= . <= NUMBER_OF_BITS} => static
      return this if prefix_length == NUMBER_OF_BITS

      binary_form = this.binary_form
      binary_form[prefix_length..] = 0 | 1

      binary_form as Segment[]
    end

    - = .. // Allow '-' as a range operator.
    //TODO Range operator.

    static class v4 = (segments: Segment[]{length == NUMBER_OF_SEGMENTS}).join(".") < IP
      static NUMBER_OF_SEGMENTS = 4
      static SEGMENT_LENGTH = 8

      static Segment = Decimal.Positive{< 2^8}
    end

    static class v6 = (left: Segment[]).join(":")?, zero_compression: defined_segments.empty ? "::" : "::"?, (right: Segment[]).join(":")? < IP
      def defined_segments = left, right
      dynamically assert defined_segments.length (zero_compression ? < NUMBER_OF_SEGMENTS : == NUMBER_OF_SEGMENTS)

      static NUMBER_OF_SEGMENTS = 8
      static SEGMENT_LENGTH = 16

      static Segment = Hexadecimal.Positive{length <= 4}

      def segments => Segment[] = left, 0[]{length == NUMBER_OF_SEGMENTS - defined_segments.length}(), right
    end
  end
  IPv4 = IP.v4
  IPv6 = IP.v6

  Port = Decimal.Positive{< 2^16}

  class Socket
    static class Address = (ip: IPv4) | "[",(ip: IPv6),"]", (":", port: Port = DEFAULT_PORT)?
      protocol //TODO
    end
  end

end

+= Network

// Allow string CIDR notation
[IPv4, IPv6].for IP
  def String{==.instance_of (ip: IP.String) + "/" + (prefix_length: Decimal.Positive{<= IP.NUMBER_OF_BITS}.String)}
    def as :== IP = ip as IP / prefix_length
  end
end
