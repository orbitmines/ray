//TODO Decimal -> Binary / Binary -> Decimal & Decimal.String -> Binary
//TODO .map, .map on single value, effecting all .OR?; No that's the same as calling on the static def, the method meant for the instance. (Allow both variants)
//TODO "as String" should also accept "as Digit[]"
//TODO private
//TODO .zip/.zip_longest (ziplongest returns with _length to the max) for parameterless, and parameters [this, b].zip
//TODO push_back(void) should only create the array one longer.
//TODO .for on object, but it gets overwritten if type of Array. What is used then to get the object instead. Use .properties.for
//TODO 'def primary => location', should not implement primary. since location is a variable too.
//TODO Infinity
//TODO {} is a 'single'
//TODO Calling "()" should not call the () implementation, it's some special non-string token.
//TODO Disallow cast of None to item, because every method is overwritten with different return types. It's cast to an Item{} with all fields set to : None
//TODO .keys and .keys.enumerate to enumerate possible values of possible superpositions.
//TODO .values
//TODO .join works for arbitrary values
//TODO .empty = .length == 0
//TODO [] global is special, because local children would call it if defined locally, and global.[] does not refer to the array instantiation either, because we want global[property] to be accessible.
//TODO .sorted, given some order.
//TODO Is there even a difference between single and namespace?
//TODO IO =.shadow = IO %=

class Node
  //TODO How to define the + label: *

  // Attach a normalizer
  static Normalizer = (x: static) => static
  normalizer: Normalizer?
  dynamically if normalizer
    +def =(x) = super(normalizer(x))
  dynamically on(normalizer) = this = this
end

def equivalence (from: * < class) -> (to: *)
  +def from.static{== from} //TODO Support many to*s //What if from is type (how to distinguish?) then we'd want ==.instance_of, is_constructor defined on class/namespace with parameters?
    def as(:== to.type) = to //TODO .type needs to be there
  end
end

class Expression
  def while program = global.while(this, program)
end

// TODO unless


class try program: () => *
  def <Args>(catch?: (args: Args) => *)
    error: Args?

    program(throw: (args: Args) => error = args; goto capture)
    return
   capture:
    catch(error) // TODO: Type-checker should know that it must be set in Ordered to get here.
  end

  def catch(catch) = this<catch: catch>
end
// Asserts & dynamic asserts, are simply part of the type definition.
def dynamically
  (expression: Expression) //TODO Dynamically the value is equal to the expression.
  (block: () => *)
  //TODO speculative.if: If the runtime doesn't yet know the value of the expression it can choose to just run the if-branch.
  //TODO Define <speculative.if> for the block/expression. speculative.if<assume: true>
  //TODO You could specutively, say it's either that operation or the other. and have the types depends with dynamically assert, xor'ed with the other value.
  //TODO Basically turn possibly infinite tasks into a branch of execution until we know.
  //TODO Parameterless functions are automatically dynamic.
  //TODO Infinite loops should be dismissed as possible values. If a loop is detected, stop committing resources there (until there's a change, then recheck)

//And things like dynamically assert shouldn't throw directly, but check all conditions and report them all together.

  // Take the comment above or besides an assert as the error message.
  //TODO The comment on the side only counts if there's a newline after the comment.
  def assert(expression: Expression) = external
  //TODO dynamically assert expression if

  def if(predicate: Expression, yes?: () => *) = external //TODO
end
def assert(expression: Expression) = throw '' if expression // TODO


// What is chaining a function with => mean A => +1 => +3, means a successive step in the function chain.

// A function is a Node for which "(*) => *" is defined.
Function = +def Node{(Args: *) => Return: *}

  //TODO: Evaluate right-to-left f compose g compose h = f.compose(g compose h)
  âˆ˜ = def compose(g: (: g_Args) => Args) = (args: g_Args) => Return = this(g(args))
end

def Optional<T> = { T*.for `key`: value? }
def Required<T> = { T*.for `key`: value ==.instance_of Option<V> ? V : value }
def Query<T>
  //TODO Set each property to the base class without defaults defined on T.
end

// Generalize range/intervals over arbitrary surfaces
/// Castable to reduce(|)
def Range
  // TODO Depending on the 'default space selected', range is either the refined Array, or a graph. (Graph because looped paths can exist)

  // TODO Range should be bounds which are Rays (already have the graph equipped)
  // TODO Infinity, is just the terminal reference (which doesn"t exist on the line) How to differentiate initial/terminal infinity.

  // TODO Implemented as things like .if() ?

  //TODO Implement range as method on empty string ."".

  // as T
end
/**
 * Range
 */
export interface IRange {
  or: (b: IRange) => IRange
  // and: (b: IRange) => IRange
  all: () => boolean
  contains: (x: number) => boolean
  more: (current: number, positive?: boolean) => boolean
  invert: () => IRange
}
export type Bound = { at: number, inclusive: boolean }
export class Range implements IRange {
  constructor(
    public lower: Bound,
    public upper: Bound,
  ) {
    if (lower.at > upper.at)
      throw new Error('Lower bound is greater than upper bound');
  }

  all = () => this.lower.at === -Infinity && this.upper.at === Infinity

  contains = (x: number): boolean => {
    return (this.lower === undefined || (this.lower.inclusive ? x >= this.lower.at : x > this.lower.at))
      && (this.upper === undefined || (this.upper.inclusive ? x <= this.upper.at : x < this.upper.at));
  }

  more = (current: number, positive: boolean = true) =>
    positive ? this.upper.at > current : this.lower.at < current

  or = (b: IRange): IRange => new MultiRange([this, b])

  invert = (): IRange => {
    if (this.all()) return new Range({ at: Infinity, inclusive: false }, { at: Infinity, inclusive: false });

    const ranges = []
    if (this.lower.at === -Infinity) ranges.push(new Range({ at: this.upper.at, inclusive: !this.upper.inclusive }, { at: Infinity, inclusive: true }));
    if (this.upper.at === Infinity) ranges.push(new Range({ at: -Infinity, inclusive: true }, { at: this.lower.at, inclusive: !this.lower.inclusive }));

    return ranges.length === 1 ? ranges[0] : new MultiRange(ranges)
  }

  public static Eq = (x: number) => new Range({ at: x, inclusive: true }, { at: x, inclusive: true })
  public static Gt = (x: number) => new Range({ at: x, inclusive: false }, { at: Infinity, inclusive: false })
  public static Gte = (x: number) => new Range({ at: x, inclusive: true }, { at: Infinity, inclusive: false })
  public static Lt = (x: number) => new Range({ at: -Infinity, inclusive: false }, { at: x, inclusive: false })
  public static Lte = (x: number) => new Range({ at: -Infinity, inclusive: false }, { at: x, inclusive: true })

  public static Between = (lower: number, upper: number) => new Range({ at: lower, inclusive: true }, { at: upper, inclusive: true })
}
export class MultiRange implements IRange {
  constructor(public ranges: IRange[] = []) {}

  all = (): boolean =>
    this.ranges.some(range => range.all());
  contains = (x: number): boolean =>
    this.ranges.some(range => range.contains(x));
  more = (current: number, positive: boolean = true): boolean =>
    this.ranges.some(range => range.more(current, positive));
  or = (b: IRange): IRange => new MultiRange([...this.ranges, ...(b instanceof MultiRange ? (b as MultiRange).ranges : [b])])

  invert = (): IRange => { throw new Error('Not implemented') }

}


// TODO Dynamically assign to loops
export interface Loop extends Many<Ray> {
  disallow_loops: () => Many<Ray> //TODO Some implementation using conditionally
  /**
   * A type pointer to the result of an unrolled loop.
   */
  unrolled: () => Many<Ray>
  /**
   * Modular unroll: after unrolling a loop still exists between the first and last instantiation.
   */
  unrolled_mod: () => Many<Ray>
  /**
   * Pointer to the instantiations of this loop.
   */
  instances: () => Many<Many<Ray>>
}

// OR is parallel structure, AND is sequential structure
