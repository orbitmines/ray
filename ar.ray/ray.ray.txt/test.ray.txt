
//TODO Something like .move to a field is what 'using' uses

// TODO: This needs to be resolved before anything else does:
//TODO Something like is_boundary checks whether any of the entries (Many<>) are at a boundary, but that changes behavior of a superposed abstract interpretation when it shouldn't. (It should individually check is_boundary, and superpose the results)

//TODO Properties are different that just rays on value, they can be rays on another ray too.
//TODO .copy implemented, as not being bound to the .history .last version. But a new branched version.
//TODO How to remove from &/|. Just -, but what if we have number | number, and we want to - one.

//TODO = on variable, main object being a variable at a location
Only added to graphs to histories

// ~~, like --, skips the () around, and applies some change but returns the original object.
// So you dont have to write
a = Value
a.change
return a
but just a ~~ a.change ~~ a.change

// TODO If we have something like class Location = Ray, we want to also be able to say, a single location = Multiple Rays, and the variable itself holds Many of those locations @
// TODO -> So @ maps to loop over all those rays. @@ or something should map to that specific instance's multiple rays.
// TODO -> For most things this difference wont matter, but for things that extend Ray, this does matter.

//TODO What to do with functionality like [index: 0] on IP, when it extends both a string, and a -1 <- . -> +1. Basically it has two structures defined on it.

You want = to be called on object, changing the type possibly. Since it's on a variable - variable is some object. So that would mean that = without effecting the current value, would first have to copy it over to another place. (And the object is tied to a location - which is kind of nice)or you can change its location to move it

You want .bound_type on object then, but the object itself is a more specific type.

//Allow type def conditionally like this
 variant: ~= ^1,1 ? Binary.Positive{length == 3} : Binary.Positive{length == 2}

     variant:
            switch //TODO Allow switch to be used like this in a type definition

None implements location and =
What if an object is instantiated and used within a function/constrctor only, whats it location like, none for instance
|-> Object.method.() with [context] accessible as the last location.
//TODO What happens to returned variables? They have a location inside the function, then while their location isn't changed in another function, that function still lives through the variable?
.inventory = .caller

// Allow [7 | 11 | 15 | 19]  -> [7 | +4 | +4 | +4]

# todo functions which calling them requires the top-level context which is calling has certain variables defined as a way to pass the variables?

//Parameterless property = , sets that variable to an expression. It's realized when another property on it is accessed? (or it's set to some other property
// |-> It's not the same as dynamic, dynamic changes if the dependant parameters of it changes. Or is it?

what if .inventory is changed, history is kept track off in the new location and old, that the location changed and thus the value is gone/new
what if the lvariable is used at two location, two .,inventory, but one variable.

.history, .history is simply up to some entry in the path

//TODO Reverse .keys and .values

//TODO dynamically could see through history if something was added/removed and not need to run the whole thing again

//TODO external fills things like Network.Host when spawning a child instance.

//TODO Say I have defined Entity{==.instanceof Player}, how do I check it against an entity? ==.some

//TODO After a filter, the object changes into a possible Option<> for certain cases, like Name.

// TODO (<-ray) is yielding .value's, what if we want the rays instead?

// TODO .ray folder to be the downloads
None != instanceof Item

//TODO Needs like an example of 2D/3D world with yaw/pitch on location, stored as arcs in a continuous space then discretized by some things like elementary lengths and other things.

// TODO; Every value type T, is automatically decorated with Many. How is it indicated that it's a single result, and never many?
// TODO; But how do you iterate possibilities.
// TODO: It's an arbitrary graph, so how are we delegating resources on every property access etc.
//          -> How do you write a generating function which acceptsthis. It's .that_function.reduce(|), and .that_function is possibly non-halting.
// TODO: Ambiguity: .reduce(|) on an Array value, what does the .for go to? Now I'm using .for to iterate the possibilities of String[].reduce(|), not String. Because String[].reduce(|) is type 'String': Take Digit for example.
// .value, but then what about rays. And things like probabilities. In the case of multi-methods it's determined by the args.

//TODO Default of an object is only loaded if accessed, so we can have circularly defined defaults.

.: sets bound type
parse json to an object by setting fs.directory.file equal to some type which serializes and sets to json automatically restricting possible values

Evaluation order like +/-//* different for each type? how configured?

//TODO Partial equality .match how?
//TODO Equivalence graph
//     - Forced equivalence how?

//TODO This will be difficult to implement, but it's very powerful:
//TODO Requires all functions like &= to be rollbackable (through history probably) or -= in this case if possible. -> Compiler uses history if necessary for these features.
//TODO The -= needs to check possibly changed locations here. but starting with that location
//TODO If there even then are some that cannot be rolled back, it's just not accessible in dynamically.
//TODO So if any variable (implemented with observers again) changes so sub or location, we run/rollback.
//TODO Or if dynamically the speculative if branch change, if resources are dedicated to that if branch.
    sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last
    //TODO Could also automatically rollback previous changes of &=
    dynamically sub.location &= location.copy().push_back<edge: .value = property>(sub).last
    // equivalent to
    dynamically sub.location &= dynamically location.copy().push_back<edge: .value = property>(sub).last


//
Some better way of defining this cursor on Ray/Boundary/Edge without making these links

def Boundary<T, E> //TODO Boundary = Ray, where next/previous is the next/previous boundary.
  end: Vertex
  value: <E Boundary>
  continuation: 1 Edge<T, E>
end
def Edge<T, E> = Boundary //TODO Edge = Ray, where next/previous steps is next edges.
  value: E
  list: Boundary<T, E>
end

== usually ignores location, what if we dont want it to. Because 5 == 5, === if we dont want to ignore location.
5 == 5 // true
5 === 5 // false //TODO So the locations of these two are different, how>
var = 5; var === var // true
//TODO Which other operations would need location on it?

//TODO Array * number, repeat x times.
//TODO Array.fill with value

//TODO Need some way to extract only the specific type from a larger type. Of remove information if bound_type is more than that type.

TODO uppercase, lowercase, swapcase

If multiple directionalities on a class we might prefer only to use the first one defined? if they're not &'ed. So that's the case for extends in the case of IP. So use &= to do it, default is only first defined.

Because a variable is linked to a location, that location defined additional type information like dytnamically asserts which are part of that type. (By keeping track of location we have access to this)

//TODO instance_of which respects .expand and looks into it, vs one that doesn't. Not just instance_of, all of them
~= is match, as in Partial equals
for partial match ~= use regex ^/$ for end beginnging. Are functions which create initial/terminals at the beginning of some structure./

'-- . if this ~= ^"::ffff"'. If branch doesnt precede the --, so it's only for that line.
'--' shoudld be allowed to start as a this. like ' -- .embed_ipv4 if this ~= ^"::ffff"'
Allow multiline '--'
Allow returning out of a -- statement.

.recur is repeat the same method but for another instance.

If @ is used in something like as:== string, it should overwrite default behavior of doing a map on that function. Like the as string in IPv6

// (Base, unit: Unit = Unit.None)[] != [Base, unit: Unit = Unit.None][], one is (A, B, A, B), the other ([A, B], [A, B])

==.at_least (Covers at least the provided  -> >=
==.@ //TODO All cases are covered by both sides.
==.@.some = A@.intersection B@ -- .some// There's a case covered by = there's an intersection between A and B.
==<type> Check equality up to some Type. (Only fields and structure defined on that type will be checked)
== = ==.in(default_equivalence_graph) (Judgemental equality: Does there exist a path from a to b in the equivalence graph.)
==.syntactic (evaluation is ignored so 2 + 2 !=.identical = 4)
  -> is .in(equiv_graph) where the equiv_graph is just the same structure.
  -> Better name than syntactic?
==.castable_to <type>, TODO Or make {as IP} to automatically only include castable variants.
  -> Equivalence graph, convertable to.
==.castable_to.in(equiv_graph)
==.equivalent = ==.castable (but default ==. is already .equivalent)
default ==.in(x.as@ TODO Somehow expand to all possible .as@ )
==.in(equivalence_graph) = equivalence_graph.find(this).path_to(x) //TODO Or this & x can both be rewritten to the same thing in that equivalence graph.
    // (A->) is A.reduce(|) (includes A)
    |-> (A->)@ .intersection (B->)@ .some (* are refs to value)
        //TODO .intersection should take the type of equality to check for
        //TODO Should be both ways (<-A->)
==.subgraph_of = x.as_subgraph ==.instance_of
==.instance_of (All properties of B are defined on A: A.zip(B).every(a, b => a instanceof b) && Structure is equal: A ==.isomorphic B)
    //TODO |-> These properties should be the ray which defines the properties somehow. .both the property descriptor and the result should be the same (instance of)
    //TODO |-> What function equality is used?
    // Refinement: Array ==.instanceof Hypergraph
//Is just .value ==
==.value (Equal in value, ignores structure) For graphs/array this is the same as a normal ==, but for Ray's the equipped ray is ignored. (So only implement it for ray)
==.isomorphic (Equal in structure, ignores values)
==.type (Type equivalent, both A and B have the same coverage of values)
+def Function
  ==.historical //TODO Either explicitly state function should be recorded, or when history is accessed that means it gets recorded.
                // -> Historically, this function seems to have done the same thing. What if never used? Return false.
  ==.extensional //TODO Where is the body defined? Is it the same as a variable? (on the .expand)
  ==.intensional
  // TODO          When there are multiple implementations, what happens?
                   More elaborate intensional equality would be?
                     Definition (+ Different contexts in which the definition finds itself)
                     Separate compilation layers it goes through
                     (and some possible unknown compilation layers (ex. physics))
                     "(perceived) Actual execution layer"
                   VS control-flow at each layer
end

//TODO 'dynamically assert @{.primary == primary}.count == 1', should check whether any of the @ values, yields true for any of the primary values. --> So you dont need to primary@.every(x => .primary@.some(x))
// TODO So default behavior of == is, A has any of B, replicated for every B.

//TODO What about equivalence graphs which are infinitely generating, we simply ask is instanceof that type (say number), if it is we assume it's on the line. so yes reachable.

//TODO .map by default yields the .value, other things yield the ray it's on.

//TODO What about the history of the object -> that's deemed to be part of the syntax
instance_of which forces non-superposition; This is probably not supported: Always allow types.

//TODO .random on Array/Graph/..
//TODO Optional method like Entity.move on tick.

// .sum = .reduce(+)

// ? = CLASS@

// How to populate Arrays/graphs by default

// What's the graph interpretation of an inductive type like 'def Option<T> = Some(T) | None'

// Calling a method which accepts a boolean, with the boolean type: Abstract interpretation natively supported.
//   -> The result should be refinable, "now I know it's true, so what's the result".
//   -> Partial evaluation, leads to external values being abstractly interpreted as well.
//     -> I should be able to later say, similarly, that the result is now refined to 'true', any effects caused should be reset back.
//   -> So .OR possibilities need to carry with it information of why and how to possibly change them

// .OR: How do we know/use a proof that a single true is enough, to discard the superpositions.

// Does every type like 'boolean' automatically include all the methods defined on it. So boolean.nor is the superposed method, which can later be called with a new 'this' value, how is that intuitively done?  (How does on static fill generics which might be required to call methods)
// If all methods on an instance are on the static class, what happens to () and other things which are already defined on Class? How to access them? (Single default method defined on class, which wraps the actual object fully)

//TODO def visibility: Entity = inventory.previous?.value.visibility ?? "local"
// This loop should automatically yield to None.

//TODO ? is unknown so it superposes by default.

// How to map over every key in an object, default map-like things defined on every context? -> How to do this while ignoring things like 'local': Things like local are private - so pri. Private doesn't prevent it from being overwritten though.

//TODO {} filter is both ways. so if .reverse is called it is filtered.

//TODO dynamically should either be a quest or be lazy, with completable when resources are available.

//TODO Require a binary function like x.b(y), where x and y are given like [].function (parameters)
// ? both allowed as a?: b as a: b?, because certain types would have to be wrapped in () otherwise

// .reduce(|) TODO How does it work to pass a binary operator to a reduce which has accumulator and current as the two arguments
//   -> If default is not set for accumulator, the initial value is the first in the array.
//   TODO But how would you?: For .reduce, require a default value for accumulator, how to indicate that?

//TODO You want something like ray[500..999] = 500-length array, instead of setting all those values to the 500-length array. How to differentiate

//TODO If big instanceof iterables are used, like worlds: World = entities{==.instanceof World}, store it separately, don't always filter through all those entities

// 0..9.reduce(|) = (Decimal.Digit) 0.value.context.reduce(|) ; .superpose an array, namely the digit defining 0. -> Then could also have the digit values link back to the superposed object or not?

//TODO iterable.0 supported = iterable[0]

// <=; node > itself or node < itself, we're in a loop (or repeated value which we're forced to see as the same, or we're not comparing using the difference we have access to - this 'number'line)

//TODO Yield ray methods in context of for so you can to is_last for example?

//TODO Variable call by reference/value per class, and also manually possible?

// == allows coercions/casts/equivalences, we want one that's also exactly equal without those?

// TODO - Ambiguities
// def a = a vs def (a = a) = a, default clashes with singleline func, same with => for function
// var? vs var ? true : false ; how to know if we need to convert var to a boolean or pass it to option.
//   -> Also var ? true : false , is it var.? true : false, or var.?.true.:.false
// .extends vs a check if it does extend
  // TODO Ambiguity if we use '<', because if I check 5 < 3, it's not 5 extends 3. Is there ever any time you'd need to use extends over <?. Yes a Type Ray which extends some other Ray, so it would be Ray < Ray,
  // What even does Ray extends Ray mean, what happens to all the structure?
// args.for(args) a could mean args.for(args).a, instead of defining a block. Or something like args.for a b = 5, with the default '= 5'
// statement if expression != statement.if.expression, similarly if expression then a else b
// what if I do something like () => boolean, which returns a boolean, the return type is not false | true, as in 'a boolean', but it's 'the type boolean'.
// Referencing a parameterless constructor, can be both the Object() or Object, since it could be interpreted as a property.
// Should changing local, also change 'caller'/'definer'?
// [1, 2, 3] should call global level [], not local level def [property].
// Variable * for any shouldnt interfere with * 2 things. *2 variable or * _, reduce(*) (* is called on the acc and current)
// Somehow the constructor another method thing so that everything can be passed on to static, but then that would have the same problem.
// The boolean definition false, true = needs to be on static. Which is done because the .false/.true values never change based on the type definition.
// If a method doesn't exist on the variable, but it is castable to something which does define that method, say boolean and &/|. Converting it to that value and calling that method should be possible.
//   |-> Version control: if that method is then implemented by a library, a user should be notified the functionality changed (probably unexpectedly)
//   |-> Ambiguity if there are multiple casts to which that method may be applied.
// classes without parameters are now called their constructors instead of requiring a ().
// ~= ^1,1 ambiguity with ^3 as a number or other numbers, it should prefer ^ starts_with because of ~=. There's no ambiguity if we use ^[1,1] -> It's not a numbe.r

// TODO - Notes for Examples
// Partial extends like Number.
// .Real.Positive should be castable to .Real
// "01101010" ~|| "10101000", or something like "0" || "1" is defined, because, there's a cast from Binary.Positive.String -> Binary.Positive, which defines those methods. And they're not defined on String. (And "0" || "1", works because String as Digit.value, which automatically finds an isomorphism the other way, which is then castable to boolean)
// Partially extending like Decimal/Decimal.Positive, Every Decimal.Positive is a Decimal, since sign is Option
// "A program/function with parameters which gets evaluated gets called"

def a 1 2 3 4 5
a<3: c>(1 2 4 5)
a<3: c, 5: e>(1 2 4)

(def method). <T> // Defines on the constructor.
def Array.method // Defines on Array (on static)
end

."method!@$8" // .`"a"`, method calls.

// Executing a piece of code in between each statement becomes:
// TODO: How to stop this from recursively calling itself: "Any redefinition of 'do' will use its previous implementation of 'do' within it, to prevent recursive stacks"
//   -> Different way of monkey-patching, monkey-patching 'def' would also do that. Some way of saying, recursively do = super()
do = def do block
  clock = some_clock_func()
  ret = super()
  time_elapsed = clock.time_elapsed()
  return ret
end

// def method(a, `a`) ; method("b", b = 5)

def Object
  list1: Array
  list2: Array
end
// Allow something like this
def Object{ list1.disjoint(list2) }
end
def Object
  list1: Array
  list2: Array
  dynamically assert list1.disjoint(list2)
end
def Object<T> args { list1.disjoint(list2) }
  list1: Array
  list2: Array
end
def Object<T> args
  list1: Array
  list2: Array
  { list1.disjoint(list2) } // TODO If a { } is evaluated, it is evaluated as a 'dynamically assert', if the definer is = this, it gets applied to that object, as opposed to Binary{.length == length}
end

program(throw: (args: Args) => void
  error = args;
  goto capture
end)
program(throw: (args: Args) => void = {
  error = args;
  goto capture
})
program(throw: (args: Args) => {
  error = args;
  goto capture
})
program(throw: (args: Args) => void = error = args; goto capture)
program(throw: (args: Args) => error = args; goto capture)

// Binary{length == 1} should be not castable, but should be boolean. or Binary.Positive[] = boolean[]

// Take the comment above or besides an assert as the error message.

// Automatic isomorphism example in Number as String definition. + example of how repeated Strings map to an array.
// Show that generic type parameters are accessible in monkeypatch, even if not defined in monkeypatch
// The only difference between a class and a normal def is that static and this are defined.
// When using '1 Object', you still allow the compiler to use many objects there for abstract interpretation, it's just that for type checking you expect there to be just one.

// TODO - Examples + Allowances
// Allow 'def Ray<T = Ray<T>>', Meaning, T is unknown, but it is a Ray.
// Allow chaining of binary operators like Array<3 < length < 5>
// Allow chaining of conditionals with .AND -> Array<length > 3><length < 5>
// Also allow Array<length > 3 | length = 3> What about this syntax: Array<length (> 3 | = 3)>, Array{length > 2 if property}
// Like this == n ? TypeA : TypeB, allow 'match' to be a type definition.
// Allow def (array: Array), to automatically accept varargs.
// Multi-methods should work for things like throw, if top-level defined doesnt accept the error, perhaps the top-level one does.
// If variable with type Option is set, it should automatically implicitly cast it to Some()
// Certain variables like 'throw' need to be accessible even in nested function which aren't defined with that variable in scope. How to type-check and generalize this concept? Is it with some keyword for a variable?
// Allow 'var = () = inline', 'var = () = { multiline }', 'var = () .. end' - Need to only capture the defined variables accessible from that context.
// Allow a wide variety of things in the String of defs, like α/β/.. other languages. Lean allows a ' at the end of variables, to mirror math.
// Type-cast like this: a: Decimal = 5, or a: Binary = 5
// defined inline inheritance: def Point<T < { def +(b) }>
// Allow single-line blocks: while o.last() == '0' => o.pop_last()
// Allow .map(.property), .if(.property > 2)
// Allow Array<ar.length === 0 ? length = 0 : length < ar.length>
// Allow a < b < c
// Allow def method(n: % 2 == 0)
// Allow def (...args) unused to be def (*)
// Allow false, true = boolean (Because boolean is a FALSE.OR(TRUE) Node, and nothing else could match to this spread operator). TODO How to go into the reverse direction? Say cursor is on TRUE there. (if it's not referencing a graph).
//    -> Should this also define Iterable: .for, for Nodes which don't have any ray selected? Or Actually implement Ray, if the .OR definition is a ray not an Array/graph
// Generalized: Repeated entries in an array like String, single instance mapping 'as X'. Allows for 'repeated X' to 'String'. And then automatic isomorphism might take care of 'String as X' and 'String as X[]'
// spaces for method calls only work for same line, except for body calls
// Point(x=1) x=1 shouldn't be overridden by x=0 in the constructor
// Decimal.Positive{< 2^8} as String should work if Decimal.Positive as String works.
// octets as Binary.Positive{length == 8}[] as Binary.Positive{length == 32} The length == 32 here should be implicit.
// Superpositions in the conversion between Decimal <-> Binary, should be respected.
// IP = -1 <- . -> +1, should automatically check the boundary conditions of whether +1/-1 is supported. And end it there so you don't need to "+1 if 1 <= ~!(as Binary.Positive)" TODO What happens to a subnet where this operation can't be done?
// 'def as :== Binary.Positive = segments as Segment.Binary[]' should be automatically assigning length too because segments have length defined
// '{==.instance_of IP}' Automatically casts to IP.
// When N <- . -> N is evaluated in a class with properties, it equips 'parent: Node <- .hierarchy -> children: Node' as .next/.previous (soi  when it's only a type definition)
// Allow 'unit (define_globally ? | unit.name)' without a :
// 1d 10h 10ms, Should see that 1d does not define .10h so it should check them individually and check if 1d implements 10h
// quantities ,= a, is push_back(a)
// (Base, unit: Unit = Unit.None)[], Should implement x[0].unit, because it binds the variable to it.
// SHould also implement x.unit, to map over x.map(A, B => B)
// If there's a superposition of possible values, but only one fits, we dont superpose the other non-fitting ones, but just use the one that fits.
// TODO Assert should be the same as dynamically assert in that it effects the type of a variable up to that statement.

  def location = Location
  +def location //TODO Allow this syntax. => Should be dynamically there.
    primary: location
  end

class char = u32
dynamically assert this < 0x110000 & !(0xD800 <= this <= 0xDFFF)
end
class char = u32{< 0x110000 && !(0xD800 <= this <= 0xDFFF)}
end

// Allow static to be accessible in defining parameters, say 'class Hypergraph<T>{every(==.instanceof Vertex)}; static Vertex'
// Allow static to go to inherited objects.
// Allow out-of-order defined defaults at?:, path:
// Allow named parameters to access nested fields: def method(parameter.field: Object), and it's then set as 'field'
// Allow var?: type and var: type?
// Allow the . after operator in shortcut of defining x => x & x. : this.#`String.NonEmpty` -> & .#`String.NonEmpty`
// Allow 'defined_segments.length (zero_compression ? <= NUMBER_OF_SEGMENTS : == NUMBER_OF_SEGMENTS)
// Allow abstract class .string to go to all implementations of that class <.
// 'zero_compression ? super() : compress_zeros.super()', define super for all variable instances of the same type (only in that context) : What is repeat the function, not super?
// Allow ' + name: "quecto`name`", "s"?' as a + { name: "" }

+def String = "public" // Allow this
+def String{== "public"}

  location: Location
  +def location //TODO Allow this syntax.
    primary: boolean?
  end
  //OR
  location: Location
    primary: boolean?
  end

// Allow +=  equiv to '= .+ b', so allow '= .method.method2'

// TODO - Notes on Grammar
// x+y x+y.func = x+(y.func) you want it to be explicitly (x+y).func

// TODO - Notes on Runtime
// Take the example of Decimal.String which should be defined first, then `Decimal.String`, then Decimal. can be defined.
// Lazy evaluation, keep structures like 'false | true | true' around without deciding execution order. ; Associativity proof is somehow relevent here, how does the runtime know about it?
// Pull static out of constructor if possible.
// Dead code like a = b, a = c, 'a = b' is never used. (Unless something like history is accessed somewhere)
// Any statement is executed in a .do block, so that one can implement a debugging .do overwrite.
// This type return should automatically be deduced.
    // def posOrNegThree (s : Sign) :
           match s with | Sign.pos => Nat | Sign.neg => Int :=
         match s with
         | Sign.pos => (3 : Nat)
         | Sign.neg => (-3 : Int)
// Warning in class, if return is used: because it's not used in the 'class definition'
// How is something like the proof that after a .push_back(A), .last = A, unless another push_back is used. How do you represent that, and how is it used by the compiler?
// Native support for running parallel on other machines
// When using multiple implementations of methods, you want enumerations of possible requirements, so for boolean this could be NAND, NOR, NOT & OR, NOT & AND. etc..
// 'external' is allowed to overwrite any method.

// TODO - Notes on Version Control
// Accessing a variable of a function (either by partially filling it), but it got renamed in a new version. Alert the user.
// A monkey-patched function added, is suddenly also used by the library. Notify the user it's now overriding functionality that wasnt, there before.
// Use something l;ike Model @ remote as the thing which takes the type used for API. but still run instances locally? How? And then on a change in the API jnotify user.

// TODO - Notes on Type Checking
// If blocks like if array.length > 2 ... end, change the type of array within that block.
// Functions should relax their arguments to 'actually used this from the type'. (So type refinements)
// Any 'Program' object, carries with in what is accessible from that context, that way after each line, we can check whether a variable is present
// Taking the 'if' definition as an example, the type that gets returned needs to be a dependent type based on 'expression', then either 'yes => Return' or 'else => Return' needs to be implied.

// TODO - Notes on Theorem proving
// For the theorem prover, you might want to store a specific proof instead of only saving the tactic by which it is solved, needs some effective way of storing and referencing this; probably in a directory outside the current file
//   -> In the background run some (in)equivalence of functions algorithm to check equivalences automatically if possible.
// Tests is the same as theorem proving, but instead of whole types and proving them, we work with specific values of the types.
//   -> Combine both approaches
// Theorem proving that multiple implementations are the same, after a theorem is found -> possibly add to possible implementations
// runtime; Multiple implementations but prefer the one over the other for speed, is that done automatically? deduce which one is faster for which case?
// example; As an example usage: Use theorem-prover to automatically generate all the possible boolean implementations. How?
//    assert that all logic operations are available when only nand or nor is provided, or when not, and and or are provided. etc.. and all possible permutations
//    -> Are these all the minimals: nand, (not, and), nor, (not, or), (and, xnor), (or, xnor), (or, xor), (and, xor)

// TODO - Editor
// goto label in an IDE should bring the label back one space. ; if then a type defined instead add it back.
// If an automatic isomorphism is found, and the user is trying to implement it, notify the user it's not necessary.
// Function in the editor where you select, press a key, then allow the perform operation on that selection like select capped text, .tolowercase it. done.
//   -> Similarly, in natural language describe the thing you want to do to that selection. Same with object.[describe] for where the cursor is.
// Eye-tracking should switch primary/secondary location, if the windows are side to side, if overlayed, the top one takes priority.

// TODO - Implementing languages.
Translate everything like ifblocks etc. to other languages, which are implemented in .ray.txt with primitives to the implementation . How to say that something like the if/else construction shouldn't be rewritten to the goto's but instead are the primitives. How to use the rewrite-blocks of code syntax to rewrite to a javascript-like syntax.

// TODO - Features
// Observables which check if a variable is changed, dynamically assert would make use of that.
// Decimal % mod 2, should go both in .prev/.next directions and start at the base case 0. What decides this?
// Like leans open Namespace in, flatten context to 'local' local += Namespace, + being defined on object
//      Should overwrite any variables already defined, but not things like local etc.., so only the things used in the "bare object fields"
// equivalences: Implicit casts (lean: coercions), chained together Pos -> Nat -> Int "if there is a path to Int from Pos" - allow loops.
//     -> Get a graph of possible coercions
// Boot into a context, which doesn't allow access upper-level properties. Something like program(`*`: () => None). Shouldn't overwrite local etc..
// Methods like hour`"s"?`, from rails. Define it as an 'undefined method', which doesn't resolve to a type. But how does it then reduce to an actual value (like ms?)
// Type: 'Terminating', TODO How to give function body types? -> Program{.expanded().length < Infinity} - expanded because otherwise groups count as length = 1, or is length automatically going inside?
//      Top of the file: assert local instanceof Terminating (or something like that)
//      The statement of terminating is basically saying: all loops are eventually escaped from. And length is finite.
// Evaluating infinities: "There exists ; is just some" def even(n: ) => Nat.some(half => n == double(half)). ; TODO How does this evaluate on the infinite .some ; Nat<every> is different from Array<length> one is referring to an instance the other to the static type Nat. Or dont use Nat<every>
// Native support for eventual consistency
// Math
//   sum/product sum icons, being .reduce(*)/.reduce(+)
//   Something like an integral implemented as an dx = infitesimal step, is that just .next and in a discrete system that means a single step minimally?
// Might want to catch the runtime error of a type somewhere, for instance arbitrary user input which needs to match some type.
// .flatten = .reduce(push_back)
// Automatic isomorphism
// Property decorators like: 'rendered secondary: instance?'

// TODO What if a library defines Nothing, different from the one here. How to decide what is used, A newly instantiated variable or that?
// Single-line function
def Maybe a = Just a | Nothing
ef Maybe(a) = Just a | Nothing
def Maybe(a)
  return Just a | Nothing
end




.caller is using .inventory?

.random on graph/array to fill with random possible values, you want a .length or .count to be there. or .edgecount to limit it somehow. Or infinitely randomly generating for array for instance. Or some parameter probability on the length of the thing. But in the graph case there'd need to be that parameter of probability of how big it'd be, otherwise each edgecount would be infonitely generating.
So some way of saying .random with a 50% change at each bit to stop generating larger ones. Or (20% etc.) What's the math on average/usual length based on thay probability

Have some func like secure be the thing that nestedlty changes the .random function so
= secure array.random
= secure array.shuffle
secure acceps expression or block //TODO secure, like the definition of throw, recursively adds a variable in context.
or something like
seed seed (randomizer?: )
  array.shuffle
end

probabilistic // typed that it needs to be added to 100 how? or <= 1
case 0.3 // = 1.0 or 0.<>
case 0.3
case 0.4
// support thing like
case PI
case 1-PI
end
r 0.3() | 0.3() | 0.4() -- @.random
 0.3(), 0.3(), 0.4() -- random
Support nested probabilities like
0.5() | 0.5( 0.3() | 0.7() ) //TODO The nested here fills .expand?
array.random should return a probability 1/length for each entry or if they're fecorated with probabilities the type = the array
as T is forcing a collapse of the probability.
How do you get multiple values from this OR/AND'ed ; you can do 0.3(A | B) | 0.7(A & B), but do you ever need to combine probabilities like 0.3 | 0.7 & 0.2 | 0.8 - but then how'd you het OR
Use -- as parentheses around the whole block
r@.random

What if the value is random, but you want the stuff synced to be a particular value

define .finite .infinite
is_irrational = .length {finite}
what's it called when the integer might be infinitely large
real is integer{finite}
Fraction is [].unbounded

2^8 -1 max username length?

communicate .length value for partially filled array like file size, but then for any value

username needs to be string without all the special \n chars etc.

how to move a claimed username to another player, then no name is selected and a new name needs to be selected.

Continue without username is setting username to uuid, reserve uuids within main world. so give out one name within uuid range and another outside. server chooses the uuid

.sort is {every . previous<=this<=.next

if boundtype is < infinite, .infinte should return false

distance is a transfinite number relative to normal integers if no elementary length is defined

protected this




// observer on a variable defined on an outside location, basically pubsub system (needs to poll for data somehow, or get pushed an update)


// .max/.min on Array<number>

// TODO: Does this assigning to false | true also change Two.first to ref on .value to the Node.

  def () // TODO Generically define this for types like boolean and others, so basically, when evaluated as a program, only then reduce query defs like (true | false) otherwise retain program structure. Probably recursively keep doing that. so call (), then result call () again etc.. until impossible.
  end

class Program // TODO: Program is like Ray, it's a function equipped with an AbstractDirectionality which is the control-flow graph
// .previous is undo the last operation, .next is program execution.
// If not used, replace 'Program' with function.


(0, 1) != [0, 1] //TODO (0, 1) is .push_back, which is relevant for types.

// what about 0..10..20 // Goes to 20 through 10, relevant for graph




// Any ray has the range operator.
0..10.for i
end
(0..10).for i
end
0..(9 + 1).for i
end
0..10.for a b
  // TODO If two arguments are passed, we step with 2 and fill both?
end

// Range operator is always binary, because we can have '0..' and '..10', and thus always same type to same type? -> That doesn't need to be the case though. Allow 'this' as a type. So this | <custom type>, not including 'this' disregards that as an option?; it's actually b = this if a = undefined.
def x: Option<this> .. y: x == None ? this : <custom, type>
end

// Allow binary operators defined outside the classes?
def x: Number .. y: Number
end

// Complicated structures like a(3, 5) is simply a[arbitrary structure]
// TODO But what if we have static things defined on the function, or fields on the function
// a(5) = 5[a] (= 5.a if a is a variable)
// a[5] = 5(a)
"x"(this) = 1 // "Get the variable called x at (arg)" -> So "x" would be "All places where the variable x is defined"
// TODO Would you ever need to access this, or is it just an interesting semantic connection?



  def <...targs>
    // TODO Dynamic namespaces, if there exists a dependency on the args execute again for the type namespace vs the untyped one.
  end


def def
  def `*`(definition: (*) => *) = external
end

//TODO: Type like Terminating, which only says that we're looking for specific data-like structures to construct something like JSON, which doesn't have any additional logic in there
//Type like { `number`: Option<number> } -> var: [number]: Option<number> = {} -> var: Map<number, number>

//TODO Something like 'using' would just be setting/getting from some global variable (which is accessible across many programs). so '= external'. And sets things to something like paths.

// TODO Transactions
//    - Rollback if anything fails
// TODO Coroutines
//    - sync: Run concurrently, return when all are done, race: First one to finish, the rest is cancelled. rush: same as race, but they're allowed to finish, the ones that didnt finish first., defer: Run after current context finishes (no matter how it exists)
// TODO Await for an event to trigger, and then do things like race, with many awaits, and then continue in the code

//TODO Remove the need for end, using indentation as the syntax. Optional?

var: Type // TODO Is Single/Many but not None.
var?: Type // TODO Is None/Single/Many because it's Option<Type>

Boundary{ end = Vertex{@.length == 1} } // = Boundary{ end = Vertex{&{length = 1}} }
//TODO Generalize that *. or [property]. goes to the unary operators, not binary+ ones. But binary is a unary operator itself, it just takes the .property as an argument. But ."String" does not exist on * binary operator, so this works. If it would, then what? Then it's a superposition of
//TODO Ambiguity with number{*length == 1} -> Where you want the result of *length to be 1.


//TODO Many<> is by default a hypergraph of possibilities so it's not .length, but .count, in array they're the same.

  // TODO .connected
  // TODO .unrolled() -> Allows loops by default
  // TODO .consistent() -> Every Boundary refers back to itself, every vertex and boundary refer to each-other.
  //   Array has .consistent

// Tree ==.instance_of Graph ==.instance_of Hypergraph
// Array ==.instance_of Graph ==.instance_of Hypergraph
var: Graph = 1, 2, 3

//TODO .max/.min are defined on number itself, and also on number array? Or generally: Everything defined on Array which isn't on T, is defined on T.

// Graph type does not have an indication of selection at a point. But its definition is centered around a point: For all Nodes, this holds.
// def connected end; How to disallow disconnected pieces? In a graph where each connection is forced to be two-way, each Node is reachable from each other Node. (Going both forward and backward)
// Graph Type need to allow loops at every step, and then an easy way to type for not having loops
// How to define graph structure with different edges/hyperedges


//TODO Are higher-inductive types simply the structured types?
// How do you define a Sphere?, Torus etc? 2d grid (2d overlapping graphs vs 2-dimensional until the other side of the sphere is reached) with modular unroll?


// Query by default

' Like this we can construct valid syntax as a simple sentence without punctuation and such


// & for every object; this.targs & targs

// When to allow {}

// TODO Variables which are not allowed to change? Often used for generics too?

//TODO How to compiler rewrite entire function blocks in some other way with complicated pattern

// Something like Nat defines +1 func, then on type static type calling Nat.+1 => Should again return Nat, because nothing changed even if superposed

// What if we dont know T? Allow Generics.Subclass (How to fill it afterwards then?) Should this be?
   //  -> So we allow to access variables of a function without the function being fully initialized.
   //  -> How to determine what can be accessed? Statically accessible variables, but also when not depended on args.
   //  -> But we also want access to variables if we can access them at runtime. TODO

   // 0.fn(+1), 0.ray(+1): "Equip 0 with a +1 ray"
   // .ray(+1) equips .previous() with !+1 which is -1
   0.ray(+1).if(x => x < 10).for i
   0.ray(+1).if(< 10).for i
   0.ray(+1).if(10 >=).for i

   // TODO Some other syntax for .ray ?
   0 -> +1
   -1 <- 0 -> +1
   -1 | -2 <- 0 -> +1 | +2
   0 -> +1 -> +2 // What does chaining this mean?


// What does function inheritance mean, but what about additional logic in there? - called with super()?, what if multiple inheritance?


Maybe(5).switch
  Just a 1
  Nothing: 2
  [type]:
  [type like Just a if a > 10]:
  [type like Object] Object
     x = 5
     y = 10
  end
  Object(x: 5 y: 10)
  Object(x: 5 y) if y > 10
  Just 5
  Just a = 5: // Automatically bind a
  Just 5..10 =>
end
if maybe == Just a = 5..10 // a =, is a name attached to the type, == defaults to using instance_of if a type? TODO what if type == type?
end
//if Just 5..10 == maybe
// TODO: Similar to binding a variable, bind comparison as a function
(maybe == Just a = 5..10).while
   maybe = Just 5
end

// Reflection lke .methods, both on static and def.

// Inline function var = () (=> Return) = ''; var = () = '' ambiguity with a = b = c





// for nested code, use something like | at the beginning of the line instead of some block, and then always till the newline
//TODO How to pattern match the syntax if it's interleaved like that. Two separate graphs.
// TODO, How does this work for non-text contexts?
def javascript
  |.ts
  |  export namespace Query {
  |    export class Instance {
  0.ray(+1).if(< 5).for i
  |      method = () => {}         //TODO How to use variables.
  end
  |    }
  |  }
end

// TODO: match groups inside arbitrary structure method name
// Default structure is to create a Node with many rays through it.
// Need better way of connecting in sequence or branching.
// Array refines .length to take a single value.

// Block/Program should be instanceof Graph (control-flow graph)? Use program instead of block?
// How to empty.
// How to allow disconnected.
// How to consistency check.
// Where to put the loop things for .unrolled and such

// TODO Tagging arbitrary parts of structure.
// For arrays it's simple, we just use what other languages do too.
a, b, c = 1, 2, 3
first, ..middle, last =

// Doing it with assignment
def method a: Object, b = a.field, c = a.field2
end
//
def method a: Object [ field, field2 [ nested ] ]
def method a: Object { field: Function, field2: reassigned_field { nested } } // TODO Difference between reassignment to a field vs type
  { field, field2 { nested }, field3 [a1, ..a2, a3],
    field4 = Just field4a // What if it's Nothing here, don't bind?
    // Variable binding of a nested method in a type definition.
  } = a
end
// (Tagging of name inside a comparison)
maybe == Just a = 5..10
// TODO What about complicated structures/graphs?


// TODO What about a ray definition, which is two-directional. Which is just defining what !+1 is
def bidirectional
  +1
reverse
  -1
end

bidirectional!
+!(5) = -5
+5! = -5 // What does this call, it should know the function +(5)

def + a
reverse
  -a
end


// TODO What about initial loops?
def Branching
  def test
    // Intermediate variable declarations for blocks. branch1 = ..
    branch1 = branch
      return 1
    branch2 = branch
      return 2 // TODO Allow to operate on intermediate results, while all returns are pending.
    end

    dead_code
  end

  def test2
    (branch1 = branch
      return 1
    branch2 = branch
      // no return
    branch3 = branch
      // no return
    branch4 = branch
      goto branch2 // Need some way of doing gotos, in order to represent loops. Reversing direction of something like this is relevant for what?
    end).

    after_branch_2_and_3
  end

  def test3
    this.i == 00
    i = 0

    branch
      this.i = 11
      i = 1
    branch
      this.i == 22
      i = 2
    branch
      // What is i here?
      // Either: Each branch has a separate i, or it could be any of 0, 1, 2, depending on the order.
      // What about the "this" context. this.i is?
    end
  end
end


  def ?
    a
  :
    b
  end


//TODO Is i++ < 10 not also a program? Because that would make Expression/Program .while ambiguous, unless you define Expression as "more top-level" than Program, how would you do that?
true.while

end
(i < 10).while
end
(i++ < 10).while // TODO: Should be accessible as the original expression, and the resulting value.
end
variable.while
end






def Block
  // TODO For meta-programming things like line-number and things of blocks being defined. That way a debugger can be made very easily.
end


// TODO; How to implement try/catch with similar passing of variables for control-flow like break.





// Non-zero decimal: Decimal.Positive<!= 0>

// Might want a construction like Object, which is context which allows stuff to be set to it, but all properties like `*`=, and local etc.. aren't in there so you can still set fields like local without it effecting behavior.




def Array<length > 2>
  var = ++some_other_var // TODO: What if length changes? Is it reverted? Is there a use-case where you want it reverted?, or is it only part of the constructor
  if predicate

  end
end

// Multiple implementation
Array.method |= (arg1) ; name = method(name) | implementation
// | is one of the implementations, &, is call all.

// dynamic asserts can carry type information of multiple objects, like A.disjoint(B). How to account for that? It's type information living in some graph above the object?
//   -> It affects both A and B as types, in the A.disjoint(B) case. Dependent on some other variable.

// How do compilers search for possible implementations of a function?
// Define a bunch of rewrites for the compiler like this. And then it needs to do analysis on what is better
// These rewrites should be defined maybe for specific targets
+def Binary
  // TODO: This needs to be like an optional: Or. so not overwrite this specific case. Indicated by "|=" not "="
  def *(b: Decimal % mod 2 = 0) |= this << (b / 2) // Shift left by some amount.
  // TODO: Default equality should be two-way? So this << (b / 2) with b being % mod 2, should rewrite this * b
  def << b = this.push_back(0[]{length = b})
end
// TODO: Need to have some way of saying: we're going into these directions: Only implemented with *, we don't want <<. for example.
// TODO: How to match to a specific program type: Like some way a part of a method is formed, and rewrite that into another pattern.
// It's just subgraph matching: Automatically put .to_subgraph() (is that true for all branches?, or is it a limited subgraph)
{
  return *
  dead_code: * // TODO: Need to match that there's no label used for goto here. How is that checked?
} -> {
  // TODO: Somehow need to encode "it's the only branch that leads to this"
  return *
}
// TODO: Is it possible to say you dont have to set the 'return *' to a type, but that it automatically sees the overlap?

// static parts of the constructor are filtered out using the same rewriting strategies used for compiler optimizations. and then the type of the block changes.


// What about graph-like control-flow
// TODO Access control-flow of a function through a variable, and decide which compiler options to pass to it.
//      -> What about other languages, similarly just a control-flow graph yes?
// Then checking intensionality is just comparing those graphs. (TODO (Equality; is only a reflexive equivalence graph) vs equivalence; Need to be able to check 'does it exist on the equivalency graph' of equivalent rewritten programs)
// TODO Control-flow graph types for other languages.
// TODO Control-flow vs syntax/grammar graphs/types. Access those too.
// TODO: The compiler might completely replace/delete functions and so just checking the inner workings of a function,
// TODO:   might not be the actual resulting execution. How to account for that? It might need requirement definitions as well. Something like + in javascript might also just be a function definition, so there's no direct control-flow, but only a definition with control-flow.


// What about infinite loops.
// What are function decorators?


// Monkey-patch, but only for code within some namespace or your project's context.
//      -> What is monkey-patching a function?
//      -> +def
//      -> access something like super.
//      -> monkey patch delete the method instead of multimethod.

// Why doesn't a do end block, change the 'return' value? or for i end,

// Defining a bidirectional ray on a class/function. This is different from just defining .next/.prev functions. It's a new wrapped object, which has that as its value.
//   How? We have things like 0 -> +1
// Variables accessible at runtime how? What decides we can access it.

// Partial assignment for an arbitrary object sets that variable to optional in the function. But it is unclear how that deforms the object.


// static variables are also accessible as a parent context, not just static.

// ".environment:" "Any Node is part of some path of context" - it's a Ray, and all .prev change what 'this' is like, namely: Allow any context to access .<var>, which will access it from that context. But they are not part of the definition.
//     -> What kind of effect has a looped context? Doesn't really effect .this, but it allows .previous contexts to access child variables. So basically: this means a global variable unless something after me defines it too.


// What does an initial loop mean in .txt form? Don't know where it starts?
// Might also have initials, but they;re not interpreted as a control-flowe graph, but rather as the inputs, like Chyp
// Controlflow graph is Hypergraph/Graph<T{.reverse.length < Infinity}> // TODO .reverse needs to be applied to the single node, which is different than calling it on the graph, what is the syntax for that? THe T{} is not right, because T is only the Value, not the Ray defined in the graph.

// Accessing variables while function in running.
// func = branch () => while true = { var++ }
// func.var (while running).
// TODO How to access contexts and functions called by this function (nested analysis)

// Array, also refines Ray type to single .next.


// 1 + 1 = 2 as a type: just structure.

// Multi-methods are defined as 'method & method & method'

// private/public/protected ; local/this is private/protected (public setting of a private field shouldnt overwrite the private one? or how does that work in other languages)
//   -> Just a flag set on the edge that encodes the name of the property.

Array<length > 2><length == 2> => 'void'/None/some type.

// How is return defined? It goes to a program which could have a chain of other operations defined on it. a.b.c.d, a is hit a return? then .b

// "run at compile time" ; constexpr ; when can this be inferred?

// Matching a looped String until some lookahead function is matched -> It's just that the order of the .OR is first checking the lookahead, then the loop.

// An evaluator, which can be possibly infinite function length, which doesn't define methods out-of-order.

// instance_of needs to somehow give access to a partially matched type. And things like dynamically assert shouldn't throw directly, but check all conditions and report them all together.

// Some generic way of populating all objects with an object id, so that equality then has to check that, but dont do this by default.

// TODO What is inheritance if two array types are extended say. 'Decimal.Positive' / 'Binary', is it an AND, or OR?

// Define 'return' as a goto?

// Object{} is like Object.filter()

// Array.some parameterless = is it non-empty?

// Type loop

// Refinement changes the type of a method, so that should be allowed, how?


// Lean: On a 32-bit architecture, USize is equivalent to UInt32. On a 64-bit machine, it is equivalent to UInt64.
//   -> How to conditionally get the architecture for this definition.

// Defining invertible bijective functions.
def map(mapping)

reverse(this)
  this.map(mapping.invert) // TODO Need to have access to the parameters?
end

def + b
reverse
  this - b
end
def - b
reverse
  this + b
end
// TODO This should somehow be simplified
-b <- x -> +b

//TODO How does inverting with a memory of what was done work? (Even if there was information loss on the Node)
//TODO Similarly, bidirectional Programs, which go backwards, either through all possibilities where it came from, or memorized which paths were taken, how?


// A Node has a definition (which is possibly in sequence) => which is the program that generated it. And successive methods called on it for it to become what it did.
//    -> Node definition and history coincide: You want all the updates up to some place, and access that as a Node.


// As a rewrite rule on program: -> variable = node; def actual_variable variable.history.last end; def actual_variable=(value) variable.history.push_back(value) end

// Should None define '=' with memory of where it came from, instead of doing `*`=. This way you say Obj.Subclass = '', calls Subclass.=, which sets definer[name] = ''
// Setting the current value '= expression'
// `*`(`*`=) returns `*`=.

//TODO How to get `*`, to still be able to use methods on the object, without recursively calling itself.

// (args: ...) = var.()[args] // var.() to distinguish it from var(). So when () is called, .() is called on `*`.

// Program selects an initial as a starting point. So labels reference the thing before a statement.

// Reflection: get method information of parameterless method some other way

// How to translate injecting code in inaccessible functions, like creating an alias for elsif called elseif, you need to inject code inside the elsif function.

// method names check with instance_of so method name is a type. But which instance_of?

// Dynamic space as a type how?

// Last value is the return value? What if it's a code block like if?

// No function body -> Not an implementation. See boolean for example, only uses or. And nothing in the 'def' block

& on object
| on function, object

// Simplest reduce case: (0..9.reduce(|)) is just placing the | decorator on each of the edges. -> Probably an efficiency thing/

// instantiations of a type using something like WaveFunctionCollapse


// inverse-1 notation used to go to the reverse direction of a method


// Types:
// "this function has different return types, depending on the value of its argument" ; match
// "this sorting function returns a permutation of its input"


// Defined on statement means it can be used like "statement if ..." TODO (how to generally define this)
def Statement
  def if predicate: Expression
    return global.if predicate
      return this()
    end
  end
end
// what decides presedence in the goto if overwrite on statement. Because goto < statement?
// & How to Maybe Hijack depended on the argument expression



