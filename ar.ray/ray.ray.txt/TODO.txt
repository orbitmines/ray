// Location
- Eventually replace file systems
- Locations differ slightly from traditional file systems:
  - There can be many items (files) defined at a single location.
  - Any location is both a directory and a file; it defines both values and a (hierarchical) structure.
- Alternate values to mirrors than what's currently there:
 - Randomizer: mirror to collapse to a particular value not the probability.
- = is defined on the variable, since the variable is location aware.
- Mirror/managed
- Abstraction: Subgraph, not just a point. (Composition, Not Location < Ray)
- How to Use Path, like /property/property (so a function; could be in a dynamic space)
   -> Location can be a function too - a sequence of descriptions
-  What if I wanted to know the history of where it came from? So from disk to instance (to memory) to instance ... , until it came to me. -> So the instance can choose whether to provide that information.
- For things like an interface, .next but a .move updates the whole location (which could be a graph like a 2d visual field, tilted by some yaw/pitch)

// Networking
- Managed items by another instance (mirrors)


// Equality/Equivalence
- == usually ignores location, what if we dont want it to. Do we use ===? OR something more intuitive?
//TODO Path implements ~= ; / ~= ^/.@ meaning files beginning with /.@

// Quests
Infinite maps etc..
We could have equivalence graphs which are infinitely generating, how would we deal with a simple check then?
- Quests: Loading partially (in/out-of-order) + reading from disk

// Writing compiler optimizations
// dead code after return if there's no goto to a label there.

// Transactions & dynamically

// Language features
- -- / space false, true .map(!)
- ~~
Like '--', the operator '~~', wraps around an entire
array = [1, 2, 3]
array ~~ .[1] = 'B' // returns [1, 'B', C]

   (0 -> +1){< 10}.for i
   0{< 10}.for i // Since numbers are by default equipped with the numberline, and 0 is not real, but the Decimal.Positive.


confidential.read none.write mac_address: Binary.Positive{length == 48} =
  secure Binary.Positive{length == 47}.random ~~ .[6].push_after(1)

