// Maybe allow one to define syntax dynamically. (Would be awful for language versioning though, if I introduce something which clashes with other syntax)

def Nothing
end

def AMethod
  variable = 5

  def method
  end
end

// Options for generics
def Generics (T) (args)
  variable = args.5
end
def Generics T
   def constructor args
      variable = args.5
   end
end

// TODO Pattern matched function names? Called instance_of
// TODO Is this used for anything other than numbers? You can at least dynamically get the name.
// TODO This is probably quite useful for meta programming, so instead of defining a loop and calling def in the loop, we
// TODO    have a single instantiation. -> Or the compiler needs to be aware of that there's a dynamic method def, and don't loop through it all.
// TODO                                 -> Probably want that anyway.
def 0-9.repeating
    return Number([method name]) // TODO: How to get method name; this.name? Or is name to often used by the user this.constructor
end
def "(0..9).repeating"."(0..9).repeating" // TODO: What's a nice syntax for this
end
// 0..9.repeating = 0..(9.repeating)
// x+y x+y.func you want it to be (x+y).func
// TODO So you want to be able to use variables within a function's name.
def NUMBER.repeating // TODO How to differentiate between NUMBER.repeating (arbitrary name) and the function.
end
def NUMBER // TODO differentiate between NUMBER and variable NUMBER; aka is it an overwrite of the variable or the thing itself
end
def Generics // The pattern "generics"
end

a.5
a[5]
a<5>
a(5)
// Are all these somehow the same?
a.5 a[5] are
a<5> a(5) are
// Are these two subgroups the same? (I believe I asked this question before in the Ruby writer project back in 2017)
a(5) is saying getting property 5 has some result.
// Complicated structures like a(3, 5) is simply a[arbitrary structure]
// TODO But what if we have static things defined on the function, or fields on the function
// a.property = 1
// a(5)
// you dont want a("property") to be 1.

// Partially filling in arguments of a function.
def a arg1 arg2
end
const c = a(arg2: b)
c(d) // <-- uses arg1
def a 1 2 3 4 5
  // TODO How to allow variables the names of numbers, while still declaring numbers normally?
  //        -> It's just a different context, so something like global.5 is a number object.
end
a(3: c)(1 2 4 5)
a(3: c, 5: e)(1 2 4)
// TODO: What if another argument is added, then all the functions normally called, do as if they need to be called again.
//          -> Is this a problem, or should we use something special for partially filling a function. That's probably a better option.
a|3: c, 5: e|


// Something like a def for def. Which is just .property =
// TODO someway to say: This function is automatically added to every context. Some default object or something.
//      -> Same with =, static, this etc..
// TODO This circularly defines itself, how to support that?
def def name ...args
    [].name = args
end
// You want something like undefined, if = is called on .undefined, it defines the property. That way we can have:
def = args
end
// a.property is now undefined
a.property = args
end
// a.property called undefined.=(args)
// which is the same as doing.
a.def property args
end

// TODO You want if without a .if to always reflect the upper-level if. Not a this.if? Generalized to?
// You want if similarly to be a function TODO Do you?
def if
end
// TODO So how does else work?
if a
else
end

def Generics (T = Default) args
   // Normal stuff here is like a static {} block
   // This is not true if args is on top like this. Need some way to allow for both.
   //   -> No not necessary, if it doesn't use args it's static.
   //   -> Similarly, .args if used anywhere in the "class", it's stored as the variable .args
   //      -> This way you also dont have these useless constructors which are only this.var = var
   //   -> Similarly, generics like .T are stored in a variable. Can it be changed? Yes?
   //   -> a<5> if a has more parameters, returns a function with one parameter filled in.
   variable = args.5

   // define subclasses
   static.Subclass <T>
   end
   static.def Subclass <T> // <-- generic overrides the context of Generics
   end
   // Allow Generics<T>.Subclass
   // What if we dont know T? Allow Generics.Subclass
   // What if T has a default and we want to match any. Use something like?? Generics<Unknown>.Subclass
   //  -> So we allow to access variables of a function without the function being fully initialized.
   //  -> How to determine what can be accessed? Statically accessible variables, but also when not depended on args.
   //  -> But we also want access to variables if we can access them at runtime. TODO

   // So stuff like this
   for a in b
     args. // uses .args so included
   end
   b.for a
     args.
   end
   // TODO Not the for(int i) stuff like other languages but stuff like.
   // 0.add(+1) gives you a ray which has a +1 direction selected.
   // Something like a 0.next(x => x + 1), or some other way of doing this easily.
   // 0.fn(+1), 0.ray(+1): "Equip 0 with a +1 ray"
   // .ray(+1) equips .previous() with !+1 which is -1
   // TODO Allow unary functions like +1, for closures which acts as a binary with the same name x+y -> How to do that
   // TODO .if acts as a .filter
   0.ray(+1).if(x => x < 10).for i

   end
   // Which could be shortened to
   0.ray(+1).if(< 10).for i
   end
   // also allow
   0.ray(+1).if(10 >=).for i
   end
   // TODO How to differentiate < 10 from .<10 function, or how to do these arbitrary names properly


   // There is the ambiguity of whether this should be saved as static or not.
   test = 6
   // Could give one the ability to reference "Generics" through a keyword "static".
   // so .static is the class.
   // Analyses would yield no dependence on previous instructions (or it will) and then we can take it out of the constructor.
   static.test = 6
   // How to get defined methods on the class if we don't know args.
   // Because you want to allow things like
   args.for a
     // What if I want to call a out of order -> Now it wouldn't work, but for a class you'd want to be able to.
     // Not in this case, but calling out of order, means the order of functions being defined must be done first.\
     // If the variable is already defined, it uses the order.
     // There might not be an order which allows you to call it? Or can we always put the method up first.
     // -> We might have a situation like


     // -> Many defs of a function, take the last one. Have some console warning for the dead code if it isn't used in between.
     a()

     // TODO: How to put this in the other context. Why isnt 'this' reassigned?
     this.def a // TODO How to use the variable here for def. -> Allow, but it overwrites the variable a in the context.
       b()
     end
     this.a =
       b()
     end
     this.a = <T> args
       b()
     end
     this.a = b

     // This .for, and = accept blocks like "end", how does this work exactly in function parameters?
     // Ruby uses &block.
     // Difference between a block accepting with a function parameter, vs an argument of that block.
     // Block is just a callable function, so it's simply the last parameter.
     args.for args a
     end
     args.for(args) a
     end
     args.for -> a
     end
     args.for do a
     end

     // If .for has no other arguments we allow
     args.for a
     end
     args.for a b = 5 // TODO How is this default separated from a variable declaration, might need something like "do"
     end
     // Differentiate a b = 5 from variable declaration, as in b = 5, not a, b = 5

     def for f: Function
     end
     def block arg f: Function
     end

   end

   def a
   end
   a =
     b()
   end

   // can keep doing generic stuff.
   def <TT> arg2
   end

   // __call__
   def (args)
   end
   // or like this
   def () args
   end
   def () <T> args
   end
   // ambiguous with .() (x y z)
   // vs.            (x, y, z)
   def a(args)
   end

   // Like haskell?
   def x + y
   end
   // or normal
   def + y
     this + y
   end
   // Allow unary construction with arbitrary special characters.
   def +
   end
   def @
   end
   // What if a thing like parenthesis is used?
   def ( x y z
   end
   result = ( x y z
   result = ((x y z)
   result = ((x, y, z)

   // g.(()
   // ambigious with
   def (()
   end
   // Arbitrary names are allowed so spaces should be possible too. This arbitrary-ness will not work well with the parser in text.
   def " "
   end
   // g. ()

   // How to decide where the "this" cutoff is, is it the whole program, is it one-level up or??
   // "this" is just a variable but where is it defined?
   this.variable
end
def Generics T args
end
// Allow <> () wherever, [] too?
def Generics <T> args
end
def Generics <T> args < Inheritance // What does function inheritance mean, just get the context, sure, but what about additional logic in there?
    super <- is it the "this" of the inherited structure, or is the return value for a function?

end
def Generics <T> args < Interface<T> // First argument already filled, so dynamically we want to allow for checking what we can define in the function without certain args.
end

// What are function decorators?
// What about graph-like control-flow
// What about monkey-patching, vs overriding the whole variable. Monkey patch could be without args, even if the original function has them.
//      -> What is monkey-patching a function?
// How to differentiate return value of a function, vs returning the Instance as a Function definition.
//      -> Default return is returning "this" -> For normal functions either "this" meaning the class, skipping the local context. Or not, and use normal return semantics.
// Variables accessible at runtime how? What decides we can access it.
// Closures
