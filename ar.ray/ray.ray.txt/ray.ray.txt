// Defined by context:
//  external = { do, goto, *, Node { `*`, `*`= } } // TODO: External should nestedly check local.definer
//  `arbitrary structure`=
//  def def(): Constructor
//  local
//  caller (= local) TODO Or is it nil
//  TODO Should be the constructor that calls into the program:
//  constructor (= local) = { name = "<text file name or nil>", definer (= local) } TODO Or is is nil?
//  definer (= local) TODO Or is it nil

def * = external // TODO any type Might not need to be externally defined. self-referential hypergraph-like structure
// TODO: Type of program is the same signature as Program and <T> extends Program -> Rename Program to Function? Program more general than function: it can be anywhere in some state.
def do<T < Program>(program: T): T = external
def goto(location: Program, predicate?: Expression) = external //TODO, Hijacks control-flow (Maybe if predicate is provided), which needs to be an option for functions, yielding control to a parameterless 'program' -> or one where the parameters are already filled instead of goto the way of doing it.

global = local

//TODO class
//TODO def
//TODO Array
//TODO 0..9.reduce(|)
//TODO Decimal -> Binary / Binary -> Decimal

//

def void end

def Node
  def `*`=(value) = external
  def `*` = external
end

class if expression: Expression, yes?: () => *
  def (else?: () => *): *
    goto exec, expression

    return else?()
   exec:
    return yes?()
  end

  // 'then' is defined, so we can have an inline block like: 'if expression then yes else no'
  def then yes: () => *
    this.yes = yes
    return this
  end

  def elsif expression: Expression, elsif: () => *
    def (else?: () => *): * = this.else
      if expression
        return elsif()
      else
        return else?()
      end
    end

    def elsif = this.elsif<this = local>
    def else = this.else<this = local>

    return local
  end

  def else else: () => *
    return this<else = else>
  end

  return this
end

def while expression: Expression, program: () => void
  return do
   check:
    goto done if expression

    program(break = goto done)
    goto check
   done:
    return
  end
end

class Expression
  def while program = global.while(this, program)
end

// TODO Any Function should be a program
class Program // TODO: Program is like Ray, it's a function equipped with an AbstractDirectionality which is the control-flow graph
  def (*): * = external // TODO: Because Program extends (*) => *, it automatically extends Function.

  // do end.while() is a do-while loop. TODO Could also only define it on '() => void'
  def while expression: Expression
    return do ...args
     exec:
      this(break = goto done, ...args)

      goto exec if expression
    end
  end
end

// A function is a Node for which '(*) => *' is defined.
def Function<(Args = *) => Return = *> = Node<(Args) => Return>
end

def Two = Array<length == 2>
class boolean = false = Two.first | true = Two.last do
  // TODO Verify that these are correct work for all cases.

  not =
    def !
    or this !& this
    or this !| this
    or this x| true
    or this x!| false
    end

  and =
    def & b: boolean
    or !(this !& b)
    or !(!this | !b)
    end

  or =
    def | b: boolean
    or !(this !| b)
    or !(!this & !b)
    end

  nand =
    def !& b: boolean
    or !(this & b)

    // An implementation using goto's so that a conditional goto is the only (necessary) primitive.
    or
      goto 2nd_check, a
     1:
      return true
     2nd_check:
      goto 0, b
      goto 1
     0:
      return false
    end

  nor =
    def !| b: boolean
    or !(this | b)
    end

  xor =
    def x| b: boolean
    or !(this x!| b)
    or (this & !b) | (!this & b)
    end

  xnor =
    def x!| b: boolean
    or !(this x| b)
    end
end

def Binary = Array<boolean>
def Decimal = Array<0..9.reduce(|)>

def u`_length = Decimal` = Binary<length == _length>
  // TODO Number arithmetic
end
def i`_length = Decimal` = Binary<length == _length>
  // TODO Number arithmetic
end